---
title: Phenotypic evolution is less constrained in complex food webs or Food-web complexity alters the fitness landscape of an insect herbivore 
author:
  - name: Matthew A. Barbour
    email: matthew.barbour@ieu.uzh.ch
    affiliation: a,b
    footnote: Corresponding Author
  - name: Christopher J. Greyson-Gaito
    affiliation: a,c
  - name: Arezoo Sootodeh
    affiliation: a
  - name: Brendan Locke
    affiliation: d
  - name: Jordi Bascompte
    affiliation: b
address:
  - code: a
    address: University of British Columbia, Department of Zoology, 6270 University Blvd., Vancouver, BC, V6T 1Z4, Canada
  - code: b
    address: University of Zurich, Department of Evolutionary Biology and Environmental Studies, Winterthurerstrasse 190, Zurich, 8057, Switzerland
  - code: c
    address: University of Guelph, Department of Integrative Biology, 50 Stone Rd. East, Guelph, ONT, N1G 2W1, Canada
  - code: d
    address: Humboldt State University, Department of Biological Sciences, 1 Harpst St., Arcata, CA, 95521, USA
abstract: "Species-interaction networks provide a mechanistic link between community and population ecology, as they describe who interacts with whom in a community. Similarly, fitness landscapes provide a mechanistic link between population and evolutionary ecology, as they describe the influence of natural selection on phenotypic variation. It remains unclear, however, how the network structure of species interactions shapes the fitness landscape. Understanding this relationship is likely key for developing a predictive ecology across scales of biological organization. To examine the relationship between network structure and the fitness landscape, we conducted a field experiment that manipulated the network of trophic interactions (simple vs. complex) influencing the fitness of an insect herbivore. We then quantified the fitness landscape of herbivores in each treatment by measuring herbivore survival as a function of multiple phenotypic traits. We found that more traits were under selection in the simple vs. complex trophic network. This occurred because different natural enemies impose different selection pressures on herbivore traits, thereby minimizing relative fitness differences among herbivore phenotypes in the complex network. Our work suggests that more complex trophic networks allow phenotypic variation to persist, which could facilitate subsequent adaptive evolution of populations to environmental change." 

bibliography: mybibfile.bib
output: rticles::elsevier_article
---


```{r setup, include=FALSE}

## Load required libraries ----
library(car)        # for homogeneity of variance test
library(tidyverse)  # for managing data
library(cowplot)    # pretty default ggplots
library(broom)      # for tidying multiple linear models
library(visreg)     # for quick visualizations of model effects
library(viridis)    # for color palette
library(lme4)       # for generalized linear mixed models
library(piecewiseSEM) # for calculating model R-square
library(latex2exp)  # using Latex notation for axes labels

## Load and manage data ----

gall_selection.df <- read_csv("gall_selection_data.csv") %>%
  # convert appropriate variables to characters instead of integers
  mutate(Plant_Position = as.character(Plant_Position),
         Gall_Number = as.character(Gall_Number)) %>%
  unite(Gall_ID, Gall_Number, Gall_Letter, remove = FALSE) %>%
  
  # subset data for analysis
  filter(phenology == "early", Location == "tree",
         platy > 0 | ectos > 0 | pupa > 0) %>%                  # eliminate unknown sources of mortality
  filter(Treatment.focus == "Ectoparasitoid exclusion" & ectos < 1 | Treatment.focus == "Control") %>% # excluding any larva that were parasitized by an ectoparasitoid in the exclusion experiment.
  mutate(Foodweb = ifelse(Treatment.focus=="Control","Complex","Simple"),
         gall_survival = as.numeric(ifelse(pupa > 0, 1, 0)),
         egg_parasitoid = as.numeric(ifelse(platy > 0, 1, 0)),
         sc.Diam = as.numeric(scale(Gall_Height_mm)), 
         sc.log.Clutch = as.numeric(scale(log(gall_individuals))), 
         sc.log1p.Pref = as.numeric(scale(log1p(Density_per_100_shoots)))) 
dim(gall_selection.df)

table(gall_selection.df$Treatment.focus, gall_selection.df$ectos)

## Create separate datasets for quantifying selection gradients ----
#control_df <- gall_selection.df %>%
#  filter(Treatment.focus == "Control") #%>%
  #mutate(sc.gall_size = as.numeric(scale(Gall_Height_mm)), 
  #       sc.clutch_size = as.numeric(scale(gall_individuals)), 
  #       sc.log.clutch_size = as.numeric(scale(log(gall_individuals))), 
  #       sc.female_preference = as.numeric(scale(Density_per_100_shoots)),
  #       sc.log1p.female_preference = as.numeric(scale(log1p(Density_per_100_shoots))))
#dim(control_df)

#treatment_df <- gall_selection.df %>%
#  filter(Treatment.focus == "Ectoparasitoid exclusion", ectos < 1) #%>%  # excluding any larva that were parasitized by an ectoparasitoid in the exclusion experiment.
#dim(treatment_df)
  #mutate(sc.gall_size = as.numeric(scale(Gall_Height_mm)), 
  #       sc.clutch_size = as.numeric(scale(gall_individuals)), 
  #       sc.log.clutch_size = as.numeric(scale(log(gall_individuals))), 
  #       sc.female_preference = as.numeric(scale(Density_per_100_shoots)),
  #       sc.log1p.female_preference = as.numeric(scale(log1p(Density_per_100_shoots))))

#mean(filter(gall_selection.df, Treatment.focus == "Ectoparasitoid exclusion")$ectos) # less than 3% of larva were parasitized by an ectoparasitoid in the exclusion experiment.

## Custom functions to avoid repetitive code ----

## Test for overdispersion
overdisp_fun <- function(model) {
  ## number of variance parameters in 
  ##   an n-by-n variance-covariance matrix
  vpars <- function(m) {
    nrow(m)*(nrow(m)+1)/2
  }
  model.df <- sum(sapply(VarCorr(model),vpars))+length(fixef(model))
  rdf <- nrow(model.frame(model))-model.df
  rp <- residuals(model,type="pearson")
  Pearson.chisq <- sum(rp^2)
  prat <- Pearson.chisq/rdf
  pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE)
  c(chisq=Pearson.chisq,ratio=prat,rdf=rdf,p=pval)
}

## Test for multicollinearity (from: https://jonlefcheck.net/2012/12/28/dealing-with-multicollinearity-using-variance-inflation-factors/)
vif.mer <- function (fit) {
    ## adapted from rms::vif

    v <- vcov(fit)
    nam <- names(fixef(fit))

    ## exclude intercepts
    ns <- sum(1 * (nam == "Intercept" | nam == "(Intercept)"))
    if (ns > 0) {
        v <- v[-(1:ns), -(1:ns), drop = FALSE]
        nam <- nam[-(1:ns)]
    }

    d <- diag(v)^0.5
    v <- diag(solve(v/(d %o% d)))
    names(v) <- nam
    v
}

## Transform logit to probability
inverse_logit <- function(x) exp(x)/(1+exp(x))

## Calculate selection gradients following method of Janzen and Stern 1998, Evolution
Beta_avg_grad <- function(.) {
  mean_fitness <- mean(predict(., type = "response")) 
  brackets <- predict(., type = "response") * (1 - predict(., type="response"))
  mean(brackets) * fixef(.)[-1] / mean_fitness ## need to divide by mean fitness to put on relative fitness scale.
}

## Calculate intensity/opportunity for selection
intensity_of_selection <- function(.) {
  mean_fitness <- mean(predict(., type = "response")) # inverse_logit(fixef(update(., .~. -sc.gall_size -sc.clutch_size -sc.female_preference)))
  relative_fitness <- predict(., type = "response") / mean_fitness 
  var(relative_fitness)
}

## Compute the matrix describing the curvature of the fitness landscape
curvature_fitness.landscape <- function(gammas, # matrix of nonlinear and correlational selection gradients 
                                        betas){ # vector of directional selection gradients
  gammas - betas %*% t(betas)
}

## Bootstrap fitness estimates
bootstrap_fitness <- function(logistic_model, fixed_effects, newdata, bootstraps, intervals=c(0.025,0.975)){
  model_matrix <- model.matrix(formula(fixed_effects), newdata)
  
  # Absolute fitness
  get_absolute_fitness <- function(.) inverse_logit(model_matrix %*% fixef(.))
  
  if(is.null(bootstraps) == FALSE){
    get_bootstraps_absolute_fitness <-bootMer(logistic_model, FUN = get_absolute_fitness, nsim=bootstraps, parallel="multicore", ncpus=32)
  
   get_intervals_absolute_fitness <- apply(get_bootstraps_absolute_fitness$t, 2, function(x) x[order(x)][c(round(bootstraps*intervals[1],0),round(bootstraps*intervals[2],0))])
   
  absolute_fitness_df <- data.frame(newdata, 
                    average = get_absolute_fitness(logistic_model), 
                    lower = get_intervals_absolute_fitness[1, ],
                    upper = get_intervals_absolute_fitness[2, ],
                    t(get_bootstraps_absolute_fitness$t))
  } else {
    absolute_fitness_df <- data.frame(newdata, 
                    average = get_absolute_fitness(logistic_model))
  }
  
  
  # Relative fitness
  get_relative_fitness <- function(.) get_absolute_fitness(.)/mean(get_absolute_fitness(.))
  
  if(is.null(bootstraps) == FALSE){
    get_bootstraps_relative_fitness <-bootMer(logistic_model, FUN = get_relative_fitness, nsim=bootstraps, parallel="multicore", ncpus=32)
  
  get_intervals_relative_fitness <- apply(get_bootstraps_relative_fitness$t, 2, function(x) x[order(x)][c(round(bootstraps*intervals[1],0),round(bootstraps*intervals[2],0))])
    
  relative_fitness_df <- data.frame(newdata, 
                    average = get_relative_fitness(logistic_model), 
                    lower = get_intervals_relative_fitness[1, ],
                    upper = get_intervals_relative_fitness[2, ],
                    t(get_bootstraps_relative_fitness$t))
  } else {
      relative_fitness_df <- data.frame(newdata, 
                    average = get_relative_fitness(logistic_model))
  }
  
  # Organize data
  return(list(absolute_fitness = absolute_fitness_df, relative_fitness = relative_fitness_df))
}

## Number of bootstrap replicates
n_boots_analysis <- 30
n_boots_plots <- 100

```


Introduction
============

The fitness landscape provides a unifying framework for linking the ecology and evolution of populations (Lande 2007; McPeek 2017). The average fitness of a population is a common currency in ecology and evolution, but usually goes by different names in each field. Ecologists refer to it as per-capita population growth rate ($dN/Ndt$), whereas evolutionary biologists call it the natural log of population mean fitness ($ln(\bar W_N)$. In addition to having different names, ecologists and evolutionary biologists have typically focused on different processes that shape the fitness landscape. For example, population ecologists have long studied the effect of a population's density on its per-capita growth rate (i.e. density-dependence, CITE Foundational and current work). In contrast, evolutionary biologists have focused on how the mean trait value of a population influences its average fitness, as this describes the direction and magnitude of natural selection (CITE foundational and current work). Therefore, the fitness landscape describes the joint ecological and evolutionary dynamics of a population in a given environment.

Community ecologists have extended the ecological side of the fitness landscape by incorporating network theory. Species-interaction networks, such as a food web describing who eats whom, provide an explicit representation of the biotic environment as they describe the interdependency of populations within an ecological community. This has provided an effective framework for predicting how changes in the biotic environment (e.g. density of directly and indirectly connected species) will impact population dynamics within species-rich communities. At the same time, evolutionary biologists have long recognized that changes in the biotic environment can alter the dynamics of natural selection. However, the biotic environment in which populations are evolving often remains a bit of a "black box" that's labelled by a general ecological process such as competition, predation, or mutualism. Because of this, it remains difficult to predict how changes in the biotic environment will affect the direction and magnitude of natural selection. Such predictions are urgently needed given the rapid changes in the biotic environment that most populations are currently experiencing throughout the world. 

Here, we integrate species-interaction networks and the fitness landscape to empirically test how changes in the biotic environment -- network of species interactions -- affect the dynamics of natural selection. Specifically, we conducted a field experiment that manipulated the diversity of insect parasitoids that were able to impose selection on an abundant insect herbivore (*Iteomyia salicisverruca*)(Fig. 1). The larva of this herbivore species induce tooth-shaped galls when they feed on the developing leaves of willow trees (*Salix* sp., @Russo2006). These galls provide protection from generalist predators (e.g. ants, spiders), thus the network of interacting parasitoids provides a realistic representation of the biotic environment this insect herbivore is experiencing. Therefore, our manipulation of parasitoid diversity alters the diversity of interactions, or food-web complexity, that this insect herbivore experiences.

Changes in food-web complexity could influence a resource population's fitness landscape in at least two ways. First, if a more diverse community of consumers is more effective at suppressing resource densities (@Ives2005), then this will result in lower mean fitness of the resource population. A reduction in mean fitness, all else equal, will intensify natural selection (@Hunter2018). On the other hand, if consumers impose different selection pressures on resource traits, then more diverse communities could dampen the strength of selection acting on a given trait. This is because a greater diversity in selection pressures is equivalent to greater uncertainty in the selective environment. Thus, a more diverse consumer community may relax the net selection pressures acting on resource traits. Here, we evaluate these hypothesized relationships through an experimental test of how changes in food-web complexity alters the fitness landscape of a resource population.


Materials & Methods
===================

## Study Site

We conducted our study within a four-year old common garden of coastal willow (*Salix hookeriana*) located at Humboldt Bay National Wildlife Refuge (HBNWR) (40&deg;40'53"N, 124&deg;12'4"W) near Loleta, California, USA. This common garden consists of 26 different willow genotypes that were collected from a single population of willows growing around Humboldt Bay. Stem cuttings of each genotype (25 replicates per genotypes) were planted in a completely randomized design in two hectares of a former cattle pasture at HBNWR. Willows in our garden begin flowering in February and reach their peak growth in early August. During this study, willows had reached 5 - 9m in height. Further details on the genotyping and planting of the common garden are available in @Barbour2015. 

## Food-Web Manipulation

We setup our food-web manipulation across 128 plants soon after galls began developing on *S. hookeriana* in early June of 2013. 
These 128 plants came from eight different plant genotypes, spanning the range of trait variation observed in this willow population (@Barbour2015). 
On treatment plants (8 replicates per genotype), we enclosed 14 galled leaves with 10x15cm organza bags (ULINE, Pleasant Prairie, WI, USA) to exclude three parasitoid species that attack during larva development (hereafter larval parasitoids). 
This treatment did not exclude the egg parasitoid *Platygaster* sp. which attacks prior to gall initiation (note that in Cecidomyiid midges, larva initiate gall development CITE). 
On control plants (8 replicates per genotype), we used flagging tape to mark 14 galled leaves per plant (~30 larva), allowing the full suite of parasitoids to attack *Iteomyia*. 
Marking galls with flagging tape ensured that we compared control and treatment galls with similar phenology when we collected galls later in the season. 
Our food-web manipulation altered the average number of trophic interactions that *Iteomyia* was exposed to from BLANK on control plants to BLANK on treatment plants. 
Thus, we refer to galls on control plants as being exposed to a 'complex' food web, whereas galls on treatment plants were exposed to a 'simple' food web.
In late August, we collected marked and bagged galls from each plant, placed them into 30 mL vials and <!-- allowed them to complete development--> kept them in the lab for 4 months at room temperature. 
We then opened galls under a dissecting scope and determined whether larva survived to pupation (our measure of fitness) or were parasitized. Since we were interested in selection imposed by interactions with parasitoids, we restricted our data to larva that either survived to pupation, was parasitized by an egg parasitoid (*Platygaster* sp.), or was parasitized by a larval parasitoid. For the food-web treatment that excluded parasitoids, we further restricted our data by removing any instances of parasitism by a larval parasitoid. This represented less than 3\% of the observations in this food-web treatment and allowed us to focus our inferences of selection on those imposed by the egg parasitoid.  
Together, we had survival estimates for 1,306 larva from 607 galls, 111 plants, and 8 plant genotypes.

## Measuring Gall Traits

We collected data on three different traits that we anticipated would experience selection based on our previous work (@Barbour2016) and others work with Cecidomyiid midges (@Weis1983, @Heath2018). 
First, we measured gall diameter as the size of each gall chamber to the nearest 0.01 mm at its maximum diameter (perpendicular to the direction of plant tissue growth). 
Our previous work has shown that a larger gall diameter provides a refuge for larva from parasitoid attack (@Barbour2016). <!-- Consider whether it is important to make the distinction that diameter was measured at the multi-chambered gall level in previous work -->
Second, we measured the clutch size of adult female midges by counting the number of chambers in each gall (@Weis1983). 
All larva collected from the same multi-chambered gall were scored with the same clutch size. 
Third, we measured female preference for oviposition (egg-laying) sites as the density of larva observed on a plant in an independent survey. Specifically, we randomly sampled five branches per tree and summed the number of individual gall chambers observed. We then converted these counts to a measure of gall density per 100 shoots by counting the number of shoots on the last branch we sampled. All larva collected from the same plant were scored with the same female preference.
The measurement of larval densities on plants in the field is a commonly used index for measuring oviposition preference (@Gripenberg2010); however, caution must be taken in inferring 'preference' as larval densities can be influenced by processes other than preference (@Singer1986). Fortunately, a couple of features of our study system suggest that larval density on a plant may be a good proxy for female preference. For example, since our data comes from a randomized placement of willow genotypes in a common garden, there is no consistent bias in which willow genotypes that females are exposed to while searching for oviposition sites. Also, egg predation is a minor source of mortality for galling insects in general (@Hawkins1997), thus we do not expect any prior egg predation to bias our estimates of observed larval densities. 

### Quantifying the Fitness Landscape

To characterize the shape of the fitness landscape in simple and complex food webs, we first used a generalized linear mixed model to quantify selection surfaces on individual traits. We used a binomial error distribution (logit link function) since larval survival (0 or 1) was our response variable and measure of fitness. We specified linear and quadratic terms for each gall trait as well as linear interaction terms between each gall trait as fixed effects in the statistical models. To account for the correlated structure of clutch size (gall level) and female preference (plant level) as well as any independent effects of willow genotype on larval survival, we specified gall ID nested within plant ID nested within plant genotype as random effects. Since we were interested in characterizing the fitness landscape -- the relationship between mean trait values and population mean fitness -- we assumed the mean value of our random effects (i.e. setting them to zero) to estimate selection gradients. Also, the fitness landscape assumes that traits distributions are multivariate normal. To better meet this assumption, we log-transformed clutch size and added a small constant (1) to female preference before log transforming, since our surveys occassionaly estimated zero larval densities. We then scaled all phenotypic traits to mean=0 and SD=1 in order to calculate standardized selection gradients that were comparable across traits and with other studies of natural selection. We used the method of @Janzen1998 to calculate directional ($\beta_{z_i}$), quadratic ($\gamma_{z_i,z_i}$), and correlational ($\gamma_{z_i,z_j}$) selection gradients and used parametric bootstrapping (1000 replicates) to calculate their 95% confidence intervals (@Bolker2009). We estimated directional selection gradients by excluding quadratic terms and statistical interactions in the model. Note that for visualizing the fitness landscape we restrict trait axes to $\pm 1$ SD of the mean trait value as this contains the majority of the trait distribution that selection is acting on.

Rather than imposing selection, parasitoids may themselves influence the expression of herbivore traits. Any influence on trait expression would bias selection gradients acting on those traits. In our system, it was plausible that parasitoids may influence chamber growth by promoting larval feeding (cite), speeding up larva development (cite), or killing larva before they complete their development (cite). Therefore, our estimates of selection on chamber diameter may be positively or negatively biased. To estimate this bias, we subset our data to only include galls where there was variation in larval survival (1 > survival > 0) within the same gall. We then calculated "apparent" selection differentials for each gall by comparing the average chamber diameter of all larva (before "selection") to the average chamber diameter of surviving larva and analyzed separate one-sample t-tests for each food-web treatment. This analysis is based on the assumption that larva within each gall come from the same clutch and therefore should have similar chamber diameters regardless of whether they are parasitized. In general, we found that our estimates of directional selection on chamber diameter were positively biased (Appendix). In other words, our analyses were overestimating the magnitude of selection acting on gall diameter. Therefore, we adjusted our estimates of directional selection on chamber diameter ($\beta_{diam}$) by subtracting the biased selection differentials. Note that selection gradients and selection differentials for chamber diameter were virtually the same (Appendix). 

### Quantifying Selective Constraints

The strength and pattern of selective constraints can be measured as the slope and curvature of the fitness landscape (Arnold 1992).

We can translate selection surfaces of individuals to the fitness landscape of a population

To characterize the net effects of food-web complexity on the slope and curvature of *Iteomyia*'s fitness landscape, we took advantage of existing theory that links selection surfaces of individuals to the fitness landscape of the population (Phillips & Arnold 1998, Arnold 2003). Specifically, the slope of the fitness landscape corresponds to the column vector of directional selection gradients:

```{r LATEX NEED TO CHECK two, eval=FALSE, include=FALSE}
$$\text{Slope} = \beta = \begin{pmatrix} \beta_{diam} \\ \beta_{clutch} \\ \beta_{pref} \end{pmatrix} $$
whereas the curvature of the fitness landscape is a function of the directional, nonlinear, and correlational selection gradients: 
$$\text{Curvature} = \gamma - \beta \beta^T$$
where \gamma represents the matrix of nonlinear and correlational selection gradients:
$$\gamma = \begin{pmatrix} \gamma_{diam,diam}&& \\ \gamma_{diam,clutch}&\gamma_{clutch,clutch}& \\ \gamma_{diam,pref} & \gamma_{clutch,pref} &\gamma_{pref,pref} \end{pmatrix}$$
```


Note that we ommitted the upper triangle of the matrix for clarity since it is simply the reflection of the lower triangle. Assuming that there is additive genetic variance and covariance between these traits under selection, then the slope and curvature of the fitness landscape give insight to how the population's mean trait value will change in the next generation as well as how additive genetic variance and covariance changes within a generation.

While making quantitative predictions about trait evolution requires knowledge of the additive genetic variance and covariance of these traits, the slope and curvature of the fitness landscape still give qualitative insight to the evolutionary trajectory of a population. 

If we assume that there is additive genetic variance and covariance between these traits, then the matrix describing the curvature of the fitness landscape gives qualitative insight to the selective constraints acting on the population. For example, the diagonal of the curvature matrix dictates (qualitatively) whether the additive genetic variance in each trait will increase ($+$), decrease ($-$), or stay the same ($0$). Similarly, the off-diagonal of the curvature matrix dictates whether selection favors trait integration (positive covariance), a tradeoff (negative covariance), or no change in genetic covariance. In other words, we can get qualitative insight to how food-web complexity influences constraints on the fitness landscape by counting the number of negative sign values along the diagnoal (which imply a decrease in additive genetic variance) and the number of positive or negative signs along the off diagonal (which imply changes in additive genetic covariance that lead to either trait integration or tradeoffs).  

All analyses and visualizations were conducted in R (@R2018). 

I need to go back to estimate a common alpha coefficient if the treatments do not differ from each other.

```{r Effects of food-web complexity on absolute fitness, cache=TRUE, include=FALSE}

## FIT GLMMs ---

# Null Model
null_glmer <- glmer(gall_survival ~ 1 +
                      (1|Genotype/Plant_Position/Gall_Number),
                    data = gall_selection.df,
                    family = binomial(link = logit), control=glmerControl(optimizer = "bobyqa"))

# Model assuming no effect of food-web treatment
trait_glmer <- glmer(gall_survival ~ (sc.Diam + sc.log.Clutch + sc.log1p.Pref)^2 + 
                      I(sc.Diam^2) + I(sc.log.Clutch^2) + I(sc.log1p.Pref^2) +
                      (1|Genotype/Plant_Position/Gall_Number),
                    data = gall_selection.df,
                    family = binomial(link = logit), control=glmerControl(optimizer = "bobyqa"))

# Model allowing for an effect of food-web treatment
foodweb_glmer <- glmer(gall_survival ~ Foodweb*(sc.Diam + sc.log.Clutch + sc.log1p.Pref)^2 +
                         Foodweb*(I(sc.Diam^2) + I(sc.log.Clutch^2) + I(sc.log1p.Pref^2)) +
                         (1|Genotype/Plant_Position/Gall_Number),
                       data = gall_selection.df,
                       family = binomial(link = logit), control=glmerControl(optimizer = "bobyqa"))

# Model excluding quadratic and trait:trait interactions. This is necessary for accurately estimating directional selection gradients (Betas, Lande and Arnold 1983)
betas_glmer <- glmer(gall_survival ~ Foodweb*(sc.Diam + sc.log.Clutch + sc.log1p.Pref) +
                         (1|Genotype/Plant_Position/Gall_Number),
                       data = gall_selection.df,
                       family = binomial(link = logit), control=glmerControl(optimizer = "bobyqa"))

## STATISTICAL TESTS ----

# There is clear evidence that the traits we have measured influence larva survival
anova(null_glmer, trait_glmer, test="Chisq")

# There is also clear evidence that our food-web treatment altered natural selection
foodweb_test <- tidy(anova(trait_glmer, foodweb_glmer, test="Chisq"))
rsquared(list(trait_glmer, foodweb_glmer), method="delta") # 3-4% increase in amount of variance explained when including effect of food-web treatment

## EVALUATING MODEL ASSUMPTIONS ---

# There is no evidence of overdispersion
overdisp_fun(foodweb_glmer)

# There are no clear patterns in the distribution of the residuals (= good)
visreg(foodweb_glmer)
```

```{r Model Modification}

# In terms of the gammas, there was only evidence that food-web treatment altered nonlinear selection on preference
summary(foodweb_glmer)

# Therefore, we refit a model that only included this effect of food-web treatment on the gamma coefficients
foodweb_glmer_revised <- update(foodweb_glmer, .~. -Foodweb:I(sc.Diam^2) -Foodweb:I(sc.log.Clutch^2) -Foodweb:sc.Diam:sc.log.Clutch -Foodweb:sc.Diam:sc.log1p.Pref -Foodweb:sc.log.Clutch:sc.log1p.Pref)

# Note that we still observe that food-web treatment alters nonlinear selection on female preference
# There is also now marginal evidence for nonlinear selection on diameter as well as correlational selection between diameter and clutch (Diam:Clutch) and between diameter and preference (Diam:Pref).
summary(foodweb_glmer_revised)

summary(betas_glmer)

betas_glmer_revised <- update(betas_glmer, .~. -Foodweb:sc.Diam -Foodweb:sc.log1p.Pref)
summary(betas_glmer_revised)

foodweb_glmer_revised_again <- update(foodweb_glmer_revised, .~. -Foodweb:sc.Diam -Foodweb:sc.log1p.Pref)
summary(foodweb_glmer_revised_again)
```


```{r Get Selection Gradients for GLMER}

## METHOD OF JANZEN AND STERN 1998 ----

# Estimate mean fitness and mean "brackets" for each food-web treatment (see Janzen and Stern 1998 equation 4 for details about "brackets")
complex_predict <- predict(foodweb_glmer, newdata=filter(gall_selection.df, Foodweb=="Complex"), type="response")
complex_mean_brackets <- mean(complex_predict * (1 - complex_predict))
complex_mean_fitness <- mean(complex_predict)

simple_predict <- predict(foodweb_glmer, newdata=filter(gall_selection.df, Foodweb=="Simple"), type="response")
simple_mean_brackets <- mean(simple_predict * (1 - simple_predict))
simple_mean_fitness <- mean(simple_predict)

# Double-check that using the Beta-only model doesn't influence estimes of mean "brackets" and mean fitness. Using Complex food web as an example, but it doesn't matter 
alt_predict <- predict(betas_glmer, newdata=filter(gall_selection.df, Foodweb=="Complex"), type="response")
alt_mean_brackets <- mean(alt_predict * (1 - alt_predict))
alt_mean_fitness <- mean(alt_predict)
test_mean_brackets <- complex_mean_brackets
test_mean_fitness <- complex_mean_fitness
test_mean_brackets - alt_mean_brackets # virtually the same
test_mean_fitness - alt_mean_fitness # virtually the same

# Tidy data for beta terms
foodweb_tidy_betas <- tidy(betas_glmer, conf.int=T) %>%
  filter(term %in% c("(Intercept)","FoodwebSimple","sc.Diam","sc.log.Clutch","sc.log1p.Pref",
                     "FoodwebSimple:sc.Diam","FoodwebSimple:sc.log.Clutch","FoodwebSimple:sc.log1p.Pref")) %>%
  mutate(Foodweb = c("Complex","Simple",rep("Complex",3),rep("Simple",3)),
         Selection_form = c(NA,NA,rep("Directional",6)),
         Multiplier = rep(1,8))

# Tidy data for gamma terms. Note that we multiply quadratic (nonlinear) selection coefficients by 2 so they are on the same scale as other coefficients (detailed explanation in Stinchcombe et al. 2008)
foodweb_tidy_gammas <- tidy(foodweb_glmer, conf.int=T) %>%
  filter(term %in% c("I(sc.Diam^2)","I(sc.log.Clutch^2)","I(sc.log1p.Pref^2)",
                     "sc.Diam:sc.log.Clutch","sc.Diam:sc.log1p.Pref","sc.log.Clutch:sc.log1p.Pref",
                     "FoodwebSimple:I(sc.Diam^2)","FoodwebSimple:I(sc.log.Clutch^2)","FoodwebSimple:I(sc.log1p.Pref^2)",
                     "FoodwebSimple:sc.Diam:sc.log.Clutch","FoodwebSimple:sc.Diam:sc.log1p.Pref","FoodwebSimple:sc.log.Clutch:sc.log1p.Pref")) %>%
  mutate(Foodweb = c(rep("Complex",6),rep("Simple",6)),
         Selection_form = c(rep("Nonlinear",3),rep("Correlational",3),rep("Nonlinear",3),rep("Correlational",3)),
         Multiplier = c(rep(2,3),rep(1,3),rep(2,3),rep(1,3)))

# Combine and tidy the regression (alpha) coefficients
get_alphas <- bind_rows(foodweb_tidy_betas, foodweb_tidy_gammas) %>% 
  mutate(alpha = estimate, alpha_2.5 = conf.low, alpha_97.5 = conf.high, P = p.value) %>%
  select(term, Foodweb, alpha, alpha_2.5, alpha_97.5, P, Selection_form, Multiplier)

complex_alphas <- filter(get_alphas, Foodweb == "Complex"); complex_alphas
simple_alphas <- filter(get_alphas, Foodweb == "Simple"); simple_alphas

coefs_gradients <- data.frame(Variable = complex_alphas$term, 
           a_complex = complex_alphas$alpha,
           a_complex_2.5 = complex_alphas$alpha_2.5,
           a_complex_97.5 = complex_alphas$alpha_97.5,
           a_simple = complex_alphas$alpha + simple_alphas$alpha,        # the baseline is the coefficient in the complex food web, therefore we simply add the corresponding coefficients from the simple food web to get the coefficients on the same scale as the complex web
           a_simple_2.5 = complex_alphas$alpha + simple_alphas$alpha_2.5, # same addition process for confidence intervals
           a_simple_97.5 = complex_alphas$alpha + simple_alphas$alpha_97.5,
           Selection_form = complex_alphas$Selection_form,                # doesn't matter whether simple_ or complex_alphas is chosen for Selection_form or Multiplier
           Multiplier = complex_alphas$Multiplier) %>%                     
  mutate(b_complex = complex_mean_brackets * a_complex / complex_mean_fitness * Multiplier,
         b_complex_2.5 = complex_mean_brackets * a_complex_2.5 / complex_mean_fitness * Multiplier,
         b_complex_97.5 = complex_mean_brackets * a_complex_97.5 / complex_mean_fitness * Multiplier,
         b_simple = simple_mean_brackets * a_simple / simple_mean_fitness * Multiplier,
         b_simple_2.5 = simple_mean_brackets * a_simple_2.5 / simple_mean_fitness * Multiplier,
         b_simple_97.5 = simple_mean_brackets * a_simple_97.5 / simple_mean_fitness * Multiplier) 


bind_rows(mutate(select(coefs_gradients, Variable, a=a_complex, a_2.5=a_complex_2.5, a_97.5=a_complex_97.5, Selection_form), Foodweb = "Complex"),
          mutate(select(coefs_gradients, Variable, a=a_simple, a_2.5=a_simple_2.5, a_97.5=a_simple_97.5, Selection_form), Foodweb = "Simple")) %>%
  filter(Variable != "(Intercept)") %>%
  ggplot(., aes(x = Variable, fill=Foodweb, color=Foodweb)) +
  geom_point(aes(y=a), position = position_dodge(width=0.5)) +
  geom_errorbar(aes(ymax = a_97.5, ymin = a_2.5), position = position_dodge(width=0.5)) +
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  facet_wrap(~Selection_form, nrow=2, scales = "free_y") +
  ylab("Regression coefficient")

## Modify to be directional, nonlinear, then correlational with legend in 4th area.
## Modify so that axes have gamma and beta with the trait as a subscript
bind_rows(mutate(select(coefs_gradients, Variable, b=b_complex, b_2.5=b_complex_2.5, b_97.5=b_complex_97.5, Selection_form), Foodweb = "Complex"),
          mutate(select(coefs_gradients, Variable, b=b_simple, b_2.5=b_simple_2.5, b_97.5=b_simple_97.5, Selection_form), Foodweb = "Simple")) %>%
  filter(Variable != "(Intercept)") %>%
  ggplot(., aes(x = Variable, fill=Foodweb, color=Foodweb)) +
  geom_point(aes(y=b), position = position_dodge(width=0.5)) +
  geom_errorbar(aes(ymax = b_97.5, ymin = b_2.5), position = position_dodge(width=0.5)) +
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  facet_wrap(~Selection_form, nrow=2, scales = "free_y") +
  ylab("Selection gradient")
     

```

```{r Parametric Bootstrapping of Regression Coefficients and Selection Gradients, cache=TRUE, include=FALSE}

## DUPLICATE ABOVE EXCEPT MODIFY FOR BOOTMER

## METHOD OF JANZEN AND STERN 1998 ----

# Estimate mean fitness and mean "brackets" for each food-web treatment (see Janzen and Stern 1998 equation 4 for details about "brackets")
complex_predict <- predict(foodweb_glmer, newdata=filter(gall_selection.df, Foodweb=="Complex"), type="response")
complex_mean_brackets <- mean(complex_predict * (1 - complex_predict))
complex_mean_fitness <- mean(complex_predict)

simple_predict <- predict(foodweb_glmer, newdata=filter(gall_selection.df, Foodweb=="Simple"), type="response")
simple_mean_brackets <- mean(simple_predict * (1 - simple_predict))
simple_mean_fitness <- mean(simple_predict)

# Double-check that using the Beta-only model doesn't influence estimes of mean "brackets" and mean fitness. Using Complex food web as an example, but it doesn't matter 
alt_predict <- predict(betas_glmer, newdata=filter(gall_selection.df, Foodweb=="Complex"), type="response")
alt_mean_brackets <- mean(alt_predict * (1 - alt_predict))
alt_mean_fitness <- mean(alt_predict)
test_mean_brackets <- complex_mean_brackets
test_mean_fitness <- complex_mean_fitness
test_mean_brackets - alt_mean_brackets # virtually the same
test_mean_fitness - alt_mean_fitness # virtually the same

# Tidy data for beta terms
foodweb_tidy_betas <- tidy(bootMer(betas_glmer, FUN = fixef, nsim=n_boots_analysis, parallel="multicore", ncpus=32), conf.int=T) %>%
  filter(term %in% c("(Intercept)","FoodwebSimple","sc.Diam","sc.log.Clutch","sc.log1p.Pref",
                     "FoodwebSimple:sc.Diam","FoodwebSimple:sc.log.Clutch","FoodwebSimple:sc.log1p.Pref")) %>%
  mutate(Foodweb = c("Complex","Simple",rep("Complex",3),rep("Simple",3)),
         Selection_form = c(NA,NA,rep("Directional",6)),
         Multiplier = rep(1,8))

# Tidy data for gamma terms. Note that we multiply quadratic (nonlinear) selection coefficients by 2 so they are on the same scale as other coefficients (detailed explanation in Stinchcombe et al. 2008)
foodweb_tidy_gammas <- tidy(bootMer(foodweb_glmer, FUN = fixef, nsim=n_boots_analysis, parallel="multicore", ncpus=32), conf.int=T) %>%
  filter(term %in% c("I(sc.Diam^2)","I(sc.log.Clutch^2)","I(sc.log1p.Pref^2)",
                     "sc.Diam:sc.log.Clutch","sc.Diam:sc.log1p.Pref","sc.log.Clutch:sc.log1p.Pref",
                     "FoodwebSimple:I(sc.Diam^2)","FoodwebSimple:I(sc.log.Clutch^2)","FoodwebSimple:I(sc.log1p.Pref^2)",
                     "FoodwebSimple:sc.Diam:sc.log.Clutch","FoodwebSimple:sc.Diam:sc.log1p.Pref","FoodwebSimple:sc.log.Clutch:sc.log1p.Pref")) %>%
  mutate(Foodweb = c(rep("Complex",6),rep("Simple",6)),
         Selection_form = c(rep("Nonlinear",3),rep("Correlational",3),rep("Nonlinear",3),rep("Correlational",3)),
         Multiplier = c(rep(2,3),rep(1,3),rep(2,3),rep(1,3)))

# Combine and tidy the regression (alpha) coefficients
get_alphas <- bind_rows(foodweb_tidy_betas, foodweb_tidy_gammas) %>% 
  mutate(alpha = statistic, alpha_2.5 = conf.low, alpha_97.5 = conf.high, P = ifelse(conf.low*conf.high > 0, "<0.05","NS")) %>% # change 'alpha = estimate' to 'alpha = statistic' for bootstrap. Multiply confidence intervals to determine whether the cofficient is signficantly different from zero.
  select(term, Foodweb, alpha, alpha_2.5, alpha_97.5, P, Selection_form, Multiplier)

complex_alphas <- filter(get_alphas, Foodweb == "Complex"); complex_alphas
simple_alphas <- filter(get_alphas, Foodweb == "Simple"); simple_alphas

coefs_gradients <- data.frame(Variable = complex_alphas$term, 
           a_complex = complex_alphas$alpha,
           a_complex_2.5 = complex_alphas$alpha_2.5,
           a_complex_97.5 = complex_alphas$alpha_97.5,
           a_simple = complex_alphas$alpha + simple_alphas$alpha,        # the baseline is the coefficient in the complex food web, therefore we simply add the corresponding coefficients from the simple food web to get the coefficients on the same scale as the complex web
           a_simple_2.5 = complex_alphas$alpha + simple_alphas$alpha_2.5, # same addition process for confidence intervals
           a_simple_97.5 = complex_alphas$alpha + simple_alphas$alpha_97.5,
           Selection_form = complex_alphas$Selection_form,                # doesn't matter whether simple_ or complex_alphas is chosen for Selection_form or Multiplier
           Multiplier = complex_alphas$Multiplier) %>%                     
  mutate(b_complex = complex_mean_brackets * a_complex / complex_mean_fitness * Multiplier,
         b_complex_2.5 = complex_mean_brackets * a_complex_2.5 / complex_mean_fitness * Multiplier,
         b_complex_97.5 = complex_mean_brackets * a_complex_97.5 / complex_mean_fitness * Multiplier,
         b_simple = simple_mean_brackets * a_simple / simple_mean_fitness * Multiplier,
         b_simple_2.5 = simple_mean_brackets * a_simple_2.5 / simple_mean_fitness * Multiplier,
         b_simple_97.5 = simple_mean_brackets * a_simple_97.5 / simple_mean_fitness * Multiplier) 


bind_rows(mutate(select(coefs_gradients, Variable, a=a_complex, a_2.5=a_complex_2.5, a_97.5=a_complex_97.5, Selection_form), Foodweb = "Complex"),
          mutate(select(coefs_gradients, Variable, a=a_simple, a_2.5=a_simple_2.5, a_97.5=a_simple_97.5, Selection_form), Foodweb = "Simple")) %>%
  filter(Variable != "(Intercept)") %>%
  ggplot(., aes(x = Variable, fill=Foodweb, color=Foodweb)) +
  geom_point(aes(y=a), position = position_dodge(width=0.5)) +
  geom_errorbar(aes(ymax = a_97.5, ymin = a_2.5), position = position_dodge(width=0.5)) +
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  facet_wrap(~Selection_form, nrow=2, scales = "free_y") +
  ylab("Regression coefficient")

## Modify to be directional, nonlinear, then correlational with legend in 4th area.
## Modify so that axes have gamma and beta with the trait as a subscript
bind_rows(mutate(select(coefs_gradients, Variable, b=b_complex, b_2.5=b_complex_2.5, b_97.5=b_complex_97.5, Selection_form), Foodweb = "Complex"),
          mutate(select(coefs_gradients, Variable, b=b_simple, b_2.5=b_simple_2.5, b_97.5=b_simple_97.5, Selection_form), Foodweb = "Simple")) %>%
  filter(Variable != "(Intercept)") %>%
  ggplot(., aes(x = Variable, fill=Foodweb, color=Foodweb)) +
  geom_point(aes(y=b), position = position_dodge(width=0.5)) +
  geom_errorbar(aes(ymax = b_97.5, ymin = b_2.5), position = position_dodge(width=0.5)) +
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  facet_wrap(~Selection_form, nrow=2, scales = "free_y") +
  ylab("Selection gradient")
     

```

```{r Code Chunk to demonstrate use of latex2exp package, include=FALSE, eval=FALSE}
## NOT WORKING

library(latex2exp)
data.frame(x=1:10,y=1:10)
p<-ggplot(data=x, aes(x=y, y=x)) +
geom_errorbar(aes(ymin=x-ci, ymax=x+ci)) +
scale_x_discrete(breaks=c("label1","label2"),
               labels = lapply(sprintf('$\\alpha^\\beta$'), TeX)
p
```

What's the rationale for this test? First, we focus on galls where there is evidence of both survival and parasitism within the gall. The idea is that galls from the same clutch should be similar in size, therefore, any selection on diameter would be apparent. If we assume that this is all due to the effect of parasitism on larval development, truncating gall diameter, then we can consider this new selection gradient to be the result of confounding factors. Note that this is likely overestimates the effect of the confounding factor, since we are assuming that any heterogeneity in gall size (for this dataset) is due to a confounding effect of parasitism on gall diameter. Then, we can just subtract this value from the observed covariance between gall diameter and larval survival to adjust for the confounding effects of parasitism. This analysis should be relegated to the supplement.

Would we expect any confounding effects on nonlinear selection?
```{r Confounding effects of parasitism on gall size, include=FALSE, eval=FALSE}
## paired t-test approach. Weakness is that it only calculates the selection differential rather than the gradient, which is more meaningful for multivariate trait evolution
pair_df <- gall_selection.df %>%
  group_by(Foodweb, Gall_Number) %>%
  mutate(mean_survival = mean(gall_survival)) %>%
  filter(mean_survival > 0, mean_survival < 1) %>%
  select(Foodweb, Gall_Number, mean_survival, gall_survival, sc.Diam) %>%
  # calculate mean phenotype at gall level (before selection)
  mutate(all_mean_sc.Diam = mean(sc.Diam)) %>%
  # then filter surviving galls and calculate the mean phenotype (after selection)
  filter(gall_survival == 1) %>%
  mutate(survive_mean_sc.Diam = mean(sc.Diam)) %>%
  # only retain distinct data points and calculate the difference (selection differential)
  distinct(Foodweb, Gall_Number, all_mean_sc.Diam, survive_mean_sc.Diam) %>%
  mutate(diff_sc.Diam = survive_mean_sc.Diam - all_mean_sc.Diam)
t.test(diff_sc.Diam ~ Foodweb, pair_df)
t.test(pair_df$survive_mean_sc.Diam, pair_df$all_mean_sc.Diam, paired = T) 

complex_pair_df <- gall_selection.df %>%
  filter(Foodweb=="Complex") %>%
  group_by(Gall_Number) %>%
  mutate(mean_survival = mean(gall_survival)) %>%
  filter(mean_survival > 0, mean_survival < 1) %>%
  select(Gall_Number, mean_survival, gall_survival, sc.Diam) %>%
  # calculate mean phenotype at gall level (before selection)
  mutate(all_mean_sc.Diam = mean(sc.Diam)) %>%
  # then filter surviving galls and calculate the mean phenotype (after selection)
  filter(gall_survival == 1) %>%
  mutate(survive_mean_sc.Diam = mean(sc.Diam)) %>%
  # only retain distinct data points and calculate the difference (selection differential)
  distinct(Gall_Number, all_mean_sc.Diam, survive_mean_sc.Diam) %>%
  mutate(diff_sc.Diam = survive_mean_sc.Diam - all_mean_sc.Diam)
t.test(complex_pair_df$survive_mean_sc.Diam, complex_pair_df$all_mean_sc.Diam, paired = T)

ectos_pair_df <- gall_selection.df %>%
  filter(Foodweb=="Complex" & platy < 1) %>%
  group_by(Gall_Number) %>%
  mutate(mean_survival = mean(gall_survival)) %>%
  filter(mean_survival > 0, mean_survival < 1) %>%
  select(Gall_Number, mean_survival, gall_survival, sc.Diam) %>%
  # calculate mean phenotype at gall level (before selection)
  mutate(all_mean_sc.Diam = mean(sc.Diam)) %>%
  # then filter surviving galls and calculate the mean phenotype (after selection)
  filter(gall_survival == 1) %>%
  mutate(survive_mean_sc.Diam = mean(sc.Diam)) %>%
  # only retain distinct data points and calculate the difference (selection differential)
  distinct(Gall_Number, all_mean_sc.Diam, survive_mean_sc.Diam) %>%
  mutate(diff_sc.Diam = survive_mean_sc.Diam - all_mean_sc.Diam)
t.test(ectos_pair_df$survive_mean_sc.Diam, ectos_pair_df$all_mean_sc.Diam, paired = T)

simple_pair_df <- gall_selection.df %>%
  filter(Foodweb=="Simple") %>%
  group_by(Gall_Number) %>%
  mutate(mean_survival = mean(gall_survival)) %>%
  filter(mean_survival > 0, mean_survival < 1) %>%
  select(Gall_Number, mean_survival, gall_survival, sc.Diam) %>%
  # calculate mean phenotype at gall level (before selection)
  mutate(all_mean_sc.Diam = mean(sc.Diam)) %>%
  # then filter surviving galls and calculate the mean phenotype (after selection)
  filter(gall_survival == 1) %>%
  mutate(survive_mean_sc.Diam = mean(sc.Diam)) %>%
  # only retain distinct data points and calculate the difference (selection differential)
  distinct(Gall_Number, all_mean_sc.Diam, survive_mean_sc.Diam) %>%
  mutate(diff_sc.Diam = survive_mean_sc.Diam - all_mean_sc.Diam)
t.test(simple_pair_df$survive_mean_sc.Diam, simple_pair_df$all_mean_sc.Diam, paired = T)

## selection gradient approach
confounding_df <- gall_selection.df %>%
  group_by(Gall_Number) %>%
  mutate(mean_survival = mean(gall_survival)) %>%
  filter(mean_survival > 0, mean_survival < 1)


confounding_glmer <- glmer(gall_survival ~ Foodweb*(sc.Diam*sc.log.Clutch*sc.log1p.Pref +
                         I(sc.Diam^2) + I(sc.log.Clutch^2) + I(sc.log1p.Pref^2)) +
                         (1|Genotype/Plant_Position/Gall_Number),
                       data = confounding_df,
                       family = binomial(link = logit), control=glmerControl(optimizer = "bobyqa"))
summary(confounding_glmer)

## Replicate GLMM tests but with this confounding factor dataset ----

# No effects
drop1(confounding_glmer, test="Chisq")
summary(confounding_glmer)

# No effects on nonlinear selection acting on gall diameter, but also there is not much evidence for any effects.
confounding_glmer_2 <- update(confounding_glmer, .~. -Foodweb:I(sc.Diam^2) -Foodweb:I(sc.log.Clutch^2) -Foodweb:I(sc.log1p.Pref^2) -Foodweb:sc.Diam:sc.log.Clutch:sc.log1p.Pref)
drop1(confounding_glmer_2, test="Chisq") 
summary(confounding_glmer_2)

# Evidence of food-web treatment altering directional selection on clutch size; marginal evidence of correlational selection acting on gall size and clutch size.
confounding_glmer_3 <- update(confounding_glmer_2, .~. -I(sc.Diam^2) -I(sc.log.Clutch^2) -I(sc.log1p.Pref^2) -sc.Diam:sc.log.Clutch:sc.log1p.Pref -Foodweb:sc.Diam:sc.log.Clutch -Foodweb:sc.Diam:sc.log1p.Pref -Foodweb:sc.log.Clutch:sc.log1p.Pref)
drop1(confounding_glmer_3, test="Chisq") 
summary(confounding_glmer_3)

# Evidence that food-web treatment alters absolute fitness; evidence of directional selection acting on gall size; evidence of directional selection acting on female preference
confounding_glmer_4 <- update(confounding_glmer_3, .~. -sc.Diam:sc.log.Clutch -sc.Diam:sc.log1p.Pref -sc.log.Clutch:sc.log1p.Pref -Foodweb:sc.Diam -Foodweb:sc.log.Clutch -Foodweb:sc.log1p.Pref)
drop1(confounding_glmer_4, test="Chisq") 
summary(confounding_glmer_4)

fixef(foodweb_glmer_4)["sc.Diam"] - fixef(confounding_glmer_4)["sc.Diam"]

confounding_predict <- predict(foodweb_glmer, type="response") # not subsetting the data to complex or simple food webs, since we didn't find a difference in this subset
confounding_mean_brackets <- mean(confounding_predict * (1 - confounding_predict))
confounding_mean_fitness <- mean(confounding_predict)

# alternatively, this suggest that we are overestimating the selection gradient by this much...
round(confounding_mean_brackets * fixef(confounding_glmer_4)["sc.Diam"] / confounding_mean_fitness, 3)

diam_glmer <- glmer(gall_survival ~ Foodweb + sc.Diam +
                         (1|Genotype/Plant_Position/Gall_Number),
                       data = gall_selection.df,
                       family = binomial(link = logit), control=glmerControl(optimizer = "bobyqa"))
# note that the selection gradient and differential are virtually the same for gall diameter, given the similarity in their alpha coefficients.
fixef(diam_glmer)["sc.Diam"]
fixef(foodweb_glmer_4)["sc.Diam"]

# selection differentials
round(complex_mean_brackets * fixef(diam_glmer)["sc.Diam"] / complex_mean_fitness, 3)
round(simple_mean_brackets * fixef(diam_glmer)["sc.Diam"] / simple_mean_fitness, 3)
```

Appears to be selection for Platygaster to attack larva at high densities in more complex food webs (and a decrease in the variance). This may be a result of the poorer searching ability of parasitoids at very high gall densities, potentially due to saturation. This suggests that the fitness landscape may be dynamic because these selective effects (assuming there is heritable variation in the egg parasitoid) will change the following year. This could be an important discussion point to take into account for future work. This is different from simply altering the strength of selection, which will occur as species move along the fitness landscape, but this result suggests that the nature of the fitness landscape may actually be changing. For example, larval parasitoids could be driving selection on Platygaster to be very efficient at foraging, which will dampen once this pressure is removed, and then could also dampen the selection acting on the galling herbivore.
```{r Selection on Platygaster Traits, include=FALSE, eval=FALSE}
platy_selection_df <- gall_selection.df %>%
  filter(egg_parasitoid > 0) 
platy_selection_df$Foodweb <- relevel(factor(platy_selection_df$Foodweb), ref = "Simple") # this represents the baseline or absence of selection by larval parasitoids

platy_Diam <- lmer(sc.Diam ~ Foodweb + (1|Genotype/Plant_Position/Gall_Number), platy_selection_df)
summary(platy_Diam)
Anova(platy_Diam, test.statistic = "F")

platy_Clutch <- lmer(sc.log.Clutch ~ Foodweb + (1|Genotype/Plant_Position), platy_selection_df)
summary(platy_Clutch)
Anova(platy_Clutch, test.statistic = "F")

platy_Pref <- lmer(sc.log1p.Pref ~ Foodweb + (1|Genotype), platy_selection_df)
summary(platy_Pref)
Anova(platy_Pref, test.statistic = "F")

## Test whether food-web complexity influences nonlinear selection with Levene's test for homogeneity of variance between groups
# Note that this result should be interepreted cautiously since we cannot account for non-independence due to plant genotype, plant ID, or gall ID
leveneTest(sc.Diam ~ Foodweb, platy_selection_df)
leveneTest(sc.log.Clutch ~ Foodweb, platy_selection_df)
leveneTest(sc.log1p.Pref ~ Foodweb, platy_selection_df)

ggplot(platy_selection_df, aes(x=Foodweb, y=sc.Diam)) +
  stat_summary(fun="mean_cl_boot", geom="errorbar", color="red", width=0.1) +
  stat_summary(fun.y="mean", geom="point", color="black", size=3)

ggplot(platy_selection_df, aes(x=Foodweb, y=sc.log.Clutch)) +
  stat_summary(fun="mean_cl_boot", geom="errorbar", color="red", width=0.1) +
  stat_summary(fun.y="mean", geom="point", color="black", size=3)

ggplot(platy_selection_df, aes(x=Foodweb, y=sc.log1p.Pref)) +
  stat_summary(fun="mean_cl_boot", geom="errorbar", color="red", width=0.1) +
  stat_summary(fun.y="mean", geom="point", color="black", size=3)
```



## Table for Alpha regression coefficients
\begin{table}[]
\begin{tabular}{lcc}
                                                                           \\ \hline
                       & \multicolumn{2}{c}{Food web (Estimate [95\% CI])} \\
\textbf{Coefficient}   & \textbf{Complex} & \textbf{Simple}                \\ \hline
$Diam$                 & `r ` [`r `-`r `] & `r ` [`r `-`r `]  \\
$Clutch$               & `r ` [`r `-`r `] & `r ` [`r `-`r `]  \\
$Pref$                 & `r ` [`r `-`r `] & `r ` [`r `-`r `]  \\
$Diam^2$               & `r ` [`r `-`r `] & `r ` [`r `-`r `]  \\
$Clutch^2$             & `r ` [`r `-`r `] & `r ` [`r `-`r `]  \\
$Pref^2$               & `r ` [`r `-`r `] & `r ` [`r `-`r `]  \\
$Diam:Clutch$          & `r ` [`r `-`r `] & `r ` [`r `-`r `]  \\
$Diam:Pref$            & `r ` [`r `-`r `] & `r ` [`r `-`r `]  \\
$Clutch:Pref$          & `r ` [`r `-`r `] & `r ` [`r `-`r `]              \\ \hline
\end{tabular}
\end{table}

## Table for Iteomyia selection gradients
\begin{table}[]
\begin{tabular}{lcc}
                                                                                  \\ \hline
                                  & \multicolumn{2}{c}{Food web (Estimate [95\% CI])} \\
\textbf{Selection gradient}       & \textbf{Complex} & \textbf{Simple}            \\ \hline
$\beta_{Diam}$                    & `r ` [`r `-`r `] & `r ` [`r `-`r `]  \\
$\beta_{Clutch}$                  & `r ` [`r `-`r `] & `r ` [`r `-`r `]  \\
$\beta_{Pref}$                    & `r ` [`r `-`r `] & `r ` [`r `-`r `]  \\
$\gamma_{Diam,Diam}$              & `r ` [`r `-`r `] & `r ` [`r `-`r `]  \\
$\gamma_{Clutch,Clutch}$          & `r ` [`r `-`r `] & `r ` [`r `-`r `]  \\
$\gamma_{Pref,Pref}$              & `r ` [`r `-`r `] & `r ` [`r `-`r `]  \\
$\gamma_{Diam,Clutch}$            & `r ` [`r `-`r `] & `r ` [`r `-`r `]  \\
$\gamma_{Diam,Pref}$              & `r ` [`r `-`r `] & `r ` [`r `-`r `]  \\
$\gamma_{Clutch,Pref}$            & `r ` [`r `-`r `] & `r ` [`r `-`r `]           \\ \hline
\end{tabular}
\end{table}

## Table for bias
\begin{table}[]
\begin{tabular}{lc}
                                                                  \\ \hline
\textbf{Type}                 & \textbf{Bias} \boldmath$s_{Diam}$ \\ \hline
Complex (All)                 & `r ` [`r `-`r `]  \\
Complex (Larval guild)        & `r ` [`r `-`r `]  \\
Simple (\textit{Platygaster}) & `r ` [`r `-`r `]                  \\ \hline
\end{tabular}
\end{table}

## Table for Platygaster selection
\begin{table}[]
\begin{tabular}{lc}
                                                                  \\ \hline
\textbf{Selection differential} & \textbf{Estimate [95\% CI]}     \\ \hline
$s_{Diam}$                      & `r ` [`r `-`r `]  \\
$s_{Clutch}$                    & `r ` [`r `-`r `]  \\
$s_{Pref}$                      & `r ` [`r `-`r `]  \\ 
$s_{Diam,Diam}$                 & `r ` [`r `-`r `]  \\
$s_{Clutch,Clutch}$             & `r ` [`r `-`r `]  \\
$s_{Pref,Pref}$                 & `r ` [`r `-`r `]                \\ \hline
\end{tabular}
\end{table}




Note that equation 3 in Phillips and Arnold 1998 is good justification for why quadratic selection cofficients should be multiplied by two (but not correlational ones?)

The G-matrix is essentially a scalar. For my data, since there is no correlational selection, it doesn't matter if there is genetic covariance between the traits, as this will not effect the change in genetic covariances within a generation (because there is no selection). Also, the G_matrix does not qualitatively alter the conclusions that there will be a decrease in additive genetic variance in gall diameter due to the strong directional selection; however, there will be an increase in the additive genetic variance in female preference. Since this is an experiment, we can assume that the G-matrix is the same between treatments

Remember that the diagonals refer to additive genetic CO-variances. Thus, positive or negative values for delta_G give insight to whether selection will act to integrate traits (positive covariance) or create trade-offs (negative covariance).

Assuming that there is positive additive genetic variance and co-variance in these traits (i.e. all values of G-matrix are positive), then the curvature of the fitness landscape can give insight to qualitative changes in the G matrix. This is because the G-matrix acts as a scalar of changes in the fitness landscape.

```{r Slope and Curvature of Fitness Landscape, include=FALSE, eval=FALSE}
betas <- c(-0.5,-0.5,0.5)
gammas_matrix <- matrix(c(-0.1, 0.0, 0.0,
                          0.0, -0.1, 0.0,
                          0.0, 0.0, -0.1), 
                        nrow=3, byrow=T)

## G-matrix ----
# (1) Asssume equal additive genetic variance for all three traits
# (2) Assume no additive genetic covariance
# The first assumption may not be realistic, but violations of this assumption will not qualitatively alter our inferences about whether additive genetic variance will increase or decrease. Qualitative changes in additive genetic variance is only determined by the curvature of the fitness landscape. Violations of this assumption will only affect the rate of phenotypic evolution and magnitude of change in genetic variance.
# The second assumption may also not be realistic; however, it will not affect our results because we found no evidence of correlational selection (therefore, there can be no change in genetic covariance).
G_matrix <- matrix(c(1.0, 1.0, 1.0,
                     1.0, 1.0, 1.0,
                     1.0, 1.0, 1.0),
                   nrow=3, byrow=T)

# Equation 1 from Phillips and Arnold 1989, Evolution
delta_z <- G_matrix %*% betas
data.frame(trait = c("diam","clutch","pref"),
           delta_z = delta_z)

# Equation 2 from Phillips and Arnold 1989, Evolution
delta_G <- G_matrix * (gammas_matrix - betas %*% t(betas)) * G_matrix
delta_G
```


```{r LATEX NEED TO CHECK, eval=FALSE, include=FALSE}
$$\text{Slope}_{complex} = \beta_{complex} = \begin{pmatrix} \beta_{diam} \\ \beta_{clutch} \\ \beta_{pref} \end{pmatrix} = \begin{pmatrix} 0.4 \\ 0 \\ -0.3 \end{pmatrix}$$
$$\text{Slope}_{simple} = \beta_{simple} = \begin{pmatrix} \beta_{diam} \\ \beta_{clutch} \\ \beta_{pref} \end{pmatrix} = \begin{pmatrix} 0.3 \\ -0.2 \\ -0.3 \end{pmatrix}$$
$$\gamma_{complex} = \begin{pmatrix} \gamma_{diam}&& \\ \gamma_{diam,clutch}&\gamma_{clutch}& \\ \gamma_{diam,pref} & \gamma_{clutch,pref} &\gamma_{pref} \end{pmatrix} = \begin{pmatrix} 0.1&& \\ 0&0& \\ 0&0&-0.3 \end{pmatrix}$$
$$\gamma_{simple} = \begin{pmatrix} \gamma_{diam}&& \\ \gamma_{diam,clutch}&\gamma_{clutch}& \\ \gamma_{diam,pref} & \gamma_{clutch,pref} &\gamma_{pref} \end{pmatrix} = \begin{pmatrix} 0.1&& \\ 0&0& \\ 0&0&0 \end{pmatrix}$$
$$\text{Curvature} = \gamma - \beta \beta^T$$
$$\text{Curvature}_{complex} = \begin{pmatrix} 0.1&& \\ 0&0& \\ 0&0&0 \end{pmatrix}$$
$$\text{Curvature}_{simple} = \begin{pmatrix} 0.1&& \\ 0&0& \\ 0&0&0 \end{pmatrix}$$
```



```{r Effects of platy vs. ecto on absolute fitness, cache=TRUE, include=FALSE, eval=FALSE}

## Fit GLMM

platyecto_glmer <- glmer(gall_survival ~ Foodweb*(sc.Diam*sc.log.Clutch*sc.log1p.Pref +
                         I(sc.Diam^2) + I(sc.log.Clutch^2) + I(sc.log1p.Pref^2)) +
                         (1|Genotype/Plant_Position/Gall_Number),
                       data = filter(gall_selection.df, Foodweb == "Simple" | Foodweb == "Complex" & platy < 1), # exclude cases of egg-parasitism from Complex food web
                       family = binomial(link = logit), control=glmerControl(optimizer = "bobyqa"))

## Test for overdispersion
overdisp_fun(platyecto_glmer) # no evidence 

## Compare statistical summaries of each model
summary(platyecto_glmer)
piecewiseSEM::rsquared(platyecto_glmer)


## Parse out mechanisms of food-web effects ----
# Use drop1 to test highest order effects and visreg to visualize the effects

# Marginal evidence that larval parasitoids are the drivers of nonlinear selection acting on female preference (disruptive selection)
drop1(platyecto_glmer, test="Chisq")
summary(platyecto_glmer)
visreg::visreg(platyecto_glmer, xvar="sc.log1p.Pref", by="Foodweb", scale = "response") 

# Marginal evidence of nonlinear selection acting on gall size. Marginal evidence of correlational selection acting on all traits.
platyecto_glmer_2 <- update(platyecto_glmer, .~. -Foodweb:I(sc.Diam^2) -Foodweb:I(sc.log.Clutch^2) -Foodweb:I(sc.log1p.Pref^2) -Foodweb:sc.Diam:sc.log.Clutch:sc.log1p.Pref)
drop1(platyecto_glmer_2, test="Chisq") 
visreg::visreg(platyecto_glmer_2, xvar="sc.Diam", scale = "response") 
# plot 3-way interaction?

# Evidence of food-web treatment altering directional selection on clutch size
platyecto_glmer_3 <- update(platyecto_glmer_2, .~. -I(sc.Diam^2) -I(sc.log.Clutch^2) -I(sc.log1p.Pref^2) -sc.Diam:sc.log.Clutch:sc.log1p.Pref -Foodweb:sc.Diam:sc.log.Clutch -Foodweb:sc.Diam:sc.log1p.Pref -Foodweb:sc.log.Clutch:sc.log1p.Pref)
drop1(platyecto_glmer_3, test="Chisq") 
summary(platyecto_glmer_3)
visreg::visreg(platyecto_glmer_3, xvar="sc.log.Clutch", by="Foodweb", scale="response") # conflicting selection have net null effects in complex food web

# No evidence of clear fitness effects of platy vs. ectos on absolute fitness; evidence of directional selection acting on gall size; no evidence of directional selection on clutch size (in complex food web); evidence of directional selection acting on female preference
platyecto_glmer_4 <- update(platyecto_glmer_3, .~. -sc.Diam:sc.log.Clutch -sc.Diam:sc.log1p.Pref -sc.log.Clutch:sc.log1p.Pref -Foodweb:sc.Diam -Foodweb:sc.log.Clutch -Foodweb:sc.log1p.Pref)
drop1(platyecto_glmer_4, test="Chisq") 
summary(platyecto_glmer_4)
visreg::visreg(platyecto_glmer_4, xvar="Foodweb", scale="response")
visreg::visreg(platyecto_glmer_4, xvar="sc.Diam", scale="response")
visreg::visreg(platyecto_glmer_4, xvar="sc.log.Clutch", scale="response")
visreg::visreg(platyecto_glmer_4, xvar="sc.log1p.Pref", scale="response")
```

```{r For platy ecto comparison, include=FALSE, eval=FALSE}
## Estimate mean fitness and mean brackets (ref: Janzen and Stern 1998)
complex_predict <- predict(platyecto_glmer, newdata=filter(gall_selection.df, Foodweb == "Complex" & platy < 1), type="response")
complex_mean_brackets <- mean(complex_predict * (1 - complex_predict))
complex_mean_fitness <- mean(complex_predict)

simple_predict <- predict(platyecto_glmer, newdata=filter(gall_selection.df, Foodweb=="Simple"), type="response")
simple_mean_brackets <- mean(simple_predict * (1 - simple_predict))
simple_mean_fitness <- mean(simple_predict)

# test whether using alternative models influences estimes of mean "brackets" and mean fitness 
alt_predict <- predict(platyecto_glmer_2, newdata=filter(gall_selection.df, Foodweb == "Complex" & platy < 1), type="response")
alt_mean_brackets <- mean(alt_predict * (1 - alt_predict))
alt_mean_fitness <- mean(alt_predict)
complex_mean_brackets - alt_mean_brackets
complex_mean_fitness - alt_mean_fitness

platyecto_tidy_4 <- filter(tidy(platyecto_glmer_4, conf.int=T), term %in% c("(Intercept)","FoodwebSimple"))
platyecto_tidy_3 <- filter(tidy(platyecto_glmer_3, conf.int=T), 
                         term %in% c("sc.Diam","sc.log.Clutch","sc.log1p.Pref",
                                     "FoodwebSimple:sc.Diam","FoodwebSimple:sc.log.Clutch","FoodwebSimple:sc.log1p.Pref"))
platyecto_tidy_2 <- filter(tidy(platyecto_glmer_2, conf.int=T), 
                         term %in% c("sc.Diam:sc.log.Clutch","sc.Diam:sc.log1p.Pref","sc.log.Clutch:sc.log1p.Pref",
                                     "FoodwebSimple:sc.Diam:sc.log.Clutch","FoodwebSimple:sc.Diam:sc.log1p.Pref","FoodwebSimple:sc.log.Clutch:sc.log1p.Pref"))
platyecto_tidy <- filter(tidy(platyecto_glmer, conf.int=T), 
                       term %in% c("I(sc.Diam^2)","I(sc.log.Clutch^2)","I(sc.log1p.Pref^2)",
                                   "FoodwebSimple:I(sc.Diam^2)","FoodwebSimple:I(sc.log.Clutch^2)","FoodwebSimple:I(sc.log1p.Pref^2)",
                                   "sc.Diam:sc.log.Clutch:sc.log1p.Pref",
                                   "FoodwebSimple:sc.Diam:sc.log.Clutch:sc.log1p.Pref"))
## These alphas aren't the appropriate comparison, this is because when there is no interaction term, then the average is taken across all of the food webs. This is okay for testing the statistical significance, but not appropriate when I want to actually compare the magnitudes of the alphas and betas
#platyecto_tidy_4 <- filter(tidy(platyecto_glmer_4), term %in% c("(Intercept)","FoodwebSimple","sc.Diam","sc.log.Clutch","sc.log1p.Pref"))
#platyecto_tidy_3 <- filter(tidy(platyecto_glmer_3), term %in% c("sc.Diam:sc.log.Clutch","sc.Diam:sc.log1p.Pref","sc.log.Clutch:sc.log1p.Pref","FoodwebSimple:sc.Diam","FoodwebSimple:sc.log.Clutch","FoodwebSimple:sc.log1p.Pref"))
#platyecto_tidy_2 <- filter(tidy(platyecto_glmer_2), term %in% c("I(sc.Diam^2)","I(sc.log.Clutch^2)","I(sc.log1p.Pref^2)","sc.Diam:sc.log.Clutch:sc.log1p.Pref","FoodwebSimple:sc.Diam:sc.log.Clutch","FoodwebSimple:sc.Diam:sc.log1p.Pref","FoodwebSimple:sc.log.Clutch:sc.log1p.Pref"))
#platyecto_tidy <- filter(tidy(platyecto_glmer), term %in% c("FoodwebSimple:I(sc.Diam^2)","FoodwebSimple:I(sc.log.Clutch^2)","FoodwebSimple:I(sc.log1p.Pref^2)","FoodwebSimple:sc.Diam:sc.log.Clutch:sc.log1p.Pref"))

get_alphas <- bind_rows(platyecto_tidy_4, platyecto_tidy_3, platyecto_tidy_2, platyecto_tidy) %>% 
  mutate(alpha = round(estimate, 3), alpha_2.5 = round(conf.low, 3), alpha_97.5 = round(conf.high, 3), P = round(p.value, 3)) %>%
  select(term, alpha, alpha_2.5, alpha_97.5, P)

complex_alphas <- filter(get_alphas, !grepl("FoodwebSimple", term))
simple_alphas <- filter(get_alphas, grepl("FoodwebSimple", term))

# remember that the selection gradients need to be multiplied by 2 for quadratic gradients.
coefs_gradients <- data.frame(Variable = complex_alphas$term, 
           a_complex = complex_alphas$alpha,
           a_complex_2.5 = complex_alphas$alpha_2.5,
           a_complex_97.5 = complex_alphas$alpha_97.5,
           a_simple = complex_alphas$alpha + simple_alphas$alpha,        # the baseline is the coefficient in the complex food web, therefore we simply add the corresponding coefficients from the simple food web to get the coefficients on the same scale as the complex web
           a_simple_2.5 = complex_alphas$alpha + simple_alphas$alpha_2.5, # same addition process for confidence intervals
           a_simple_97.5 = complex_alphas$alpha + simple_alphas$alpha_97.5) %>% 
  mutate(b_complex = round(complex_mean_brackets * a_complex / complex_mean_fitness, 3),
         b_complex_2.5 = round(complex_mean_brackets * a_complex_2.5 / complex_mean_fitness, 3),
         b_complex_97.5 = round(complex_mean_brackets * a_complex_97.5 / complex_mean_fitness, 3),
         b_simple = round(simple_mean_brackets * a_simple / simple_mean_fitness, 3),
         b_simple_2.5 = round(simple_mean_brackets * a_simple_2.5 / simple_mean_fitness, 3),
         b_simple_97.5 = round(simple_mean_brackets * a_simple_97.5 / simple_mean_fitness, 3)) %>%
  filter(Variable != "(Intercept)")

select(coefs_gradients, Variable, a_complex:a_simple_97.5)
select(coefs_gradients, Variable, b_complex:b_simple_97.5)

bind_rows(mutate(select(coefs_gradients, Variable, a=a_complex, a_2.5=a_complex_2.5, a_97.5=a_complex_97.5), Foodweb = "Complex"),
          mutate(select(coefs_gradients, Variable, a=a_simple, a_2.5=a_simple_2.5, a_97.5=a_simple_97.5), Foodweb = "Simple")) %>%
  ggplot(., aes(x = Variable, fill=Foodweb, color=Foodweb)) +
  geom_point(aes(y=a), position = position_dodge(width=0.5)) +
  geom_errorbar(aes(ymax = a_97.5, ymin = a_2.5), position = position_dodge(width=0.5)) +
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted")

bind_rows(mutate(select(coefs_gradients, Variable, b=b_complex, b_2.5=b_complex_2.5, b_97.5=b_complex_97.5), Foodweb = "Complex"),
          mutate(select(coefs_gradients, Variable, b=b_simple, b_2.5=b_simple_2.5, b_97.5=b_simple_97.5), Foodweb = "Simple")) %>%
  ggplot(., aes(x = Variable, fill=Foodweb, color=Foodweb)) +
  geom_point(aes(y=b), position = position_dodge(width=0.5)) +
  geom_errorbar(aes(ymax = b_97.5, ymin = b_2.5), position = position_dodge(width=0.5)) +
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted")
     
inverse_logit(complex_alphas$alpha[1]) - complex_mean_fitness # small difference in mean fitness estimates compared to intercept in complex food web
inverse_logit(complex_alphas$alpha[1] + simple_alphas$alpha[1]) - simple_mean_fitness # larger difference in mean fitness estimates from intercept in simple food web, unclear why...perhaps because the mean phenotypes don't match up as nicely?
```


```{r include=FALSE, eval=FALSE}
## Calculating same coefficients as for simple vs. complex food web

## Estimate mean fitness and mean brackets (ref: Janzen and Stern 1998)
ecto_predict <- predict(platyecto_glmer, newdata=filter(gall_selection.df, Foodweb=="Complex" & platy < 1), type="response")
ecto_mean_brackets <- mean(ecto_predict * (1 - ecto_predict))
ecto_mean_fitness <- mean(ecto_predict)

platy_predict <- predict(platyecto_glmer, newdata=filter(gall_selection.df, Foodweb=="Simple"), type="response")
platy_mean_brackets <- mean(platy_predict * (1 - platy_predict))
platy_mean_fitness <- mean(platy_predict)

# test whether using alternative models influences estimes of mean "brackets" and mean fitness 
alt_predict <- predict(platyecto_glmer_2, newdata=filter(gall_selection.df, Foodweb=="Complex" & platy < 1), type="response")
alt_mean_brackets <- mean(alt_predict * (1 - alt_predict))
alt_mean_fitness <- mean(alt_predict)
ecto_mean_brackets - alt_mean_brackets
ecto_mean_fitness - alt_mean_fitness

# Altering so that coefficients that differed between food webs are reported, but ones that weren't are simply reported as there baselines.
# Added multiplier column so that quadratic (nonlinear) selection coefficients can be multiplied by 2 for fair comparison
platyecto_tidy_4 <- tidy(platyecto_glmer_4, conf.int=T) %>%
  filter(term %in% c("(Intercept)","FoodwebSimple","sc.Diam","sc.log1p.Pref")) %>%
  mutate(platyecto = c("ecto","platy","Common","Common"),
         Selection_form = c(NA,NA,"Directional","Directional"),
         Multiplier = c(1,1,1,1))

platyecto_tidy_3 <- tidy(platyecto_glmer_3, conf.int=T) %>%
  filter(term %in% c("sc.log.Clutch","sc.Diam:sc.log.Clutch","sc.Diam:sc.log1p.Pref","sc.log.Clutch:sc.log1p.Pref","FoodwebSimple:sc.log.Clutch")) %>%
  mutate(platyecto = c("ecto","Common","Common","Common","platy"),
         Selection_form = c("Directional","Correlational","Correlational","Correlational","Directional"),
         Multiplier = c(1,1,1,1,1))

platyecto_tidy_2 <- tidy(platyecto_glmer_2, conf.int=T) %>%
  filter(term %in% c("I(sc.Diam^2)","I(sc.log.Clutch^2)","sc.Diam:sc.log.Clutch:sc.log1p.Pref")) %>%
  mutate(platyecto = c("Common","Common","Common"),
         Selection_form = c("Nonlinear","Nonlinear","Correlational"),
         Multiplier = c(2,2,1))

platyecto_tidy <- tidy(platyecto_glmer, conf.int=T) %>%
  filter(term %in% c("I(sc.log1p.Pref^2)","FoodwebSimple:I(sc.log1p.Pref^2)")) %>%
  mutate(platyecto = c("ecto","platy"),
         Selection_form = c("Nonlinear","Nonlinear"),
         Multiplier = c(2,2))

get_platyecto_alphas <- bind_rows(platyecto_tidy_4, platyecto_tidy_3, platyecto_tidy_2, platyecto_tidy) %>% 
  mutate(alpha = round(estimate, 3), alpha_2.5 = round(conf.low, 3), alpha_97.5 = round(conf.high, 3), P = round(p.value, 3)) %>%
  select(term, platyecto, alpha, alpha_2.5, alpha_97.5, P, Selection_form, Multiplier)

ecto_alphas <- filter(get_platyecto_alphas, platyecto == "ecto"); ecto_alphas
platy_alphas <- filter(get_platyecto_alphas, platyecto == "platy"); platy_alphas
common_platyecto_alphas <- filter(get_platyecto_alphas, platyecto == "Common"); common_platyecto_alphas


coefs_gradients.ecto_platy <- data.frame(Variable = ecto_alphas$term, 
           a_ecto = ecto_alphas$alpha,
           a_ecto_2.5 = ecto_alphas$alpha_2.5,
           a_ecto_97.5 = ecto_alphas$alpha_97.5,
           a_platy = ecto_alphas$alpha + platy_alphas$alpha,        # the baseline is the coefficient in the ecto food web, therefore we simply add the corresponding coefficients from the platy food web to get the coefficients on the same scale as the ecto web
           a_platy_2.5 = ecto_alphas$alpha + platy_alphas$alpha_2.5, # same addition process for confidence intervals
           a_platy_97.5 = ecto_alphas$alpha + platy_alphas$alpha_97.5,
           Selection_form = ecto_alphas$Selection_form,                # doesn't matter whether platy_ or ecto_alphas is chosen for Selection_form or Multiplier
           Multiplier = ecto_alphas$Multiplier) %>%                     
  mutate(b_ecto = round(ecto_mean_brackets * a_ecto / ecto_mean_fitness, 3) * Multiplier,
         b_ecto_2.5 = round(ecto_mean_brackets * a_ecto_2.5 / ecto_mean_fitness, 3) * Multiplier,
         b_ecto_97.5 = round(ecto_mean_brackets * a_ecto_97.5 / ecto_mean_fitness, 3) * Multiplier,
         b_platy = round(platy_mean_brackets * a_platy / platy_mean_fitness, 3) * Multiplier,
         b_platy_2.5 = round(platy_mean_brackets * a_platy_2.5 / platy_mean_fitness, 3) * Multiplier,
         b_platy_97.5 = round(platy_mean_brackets * a_platy_97.5 / platy_mean_fitness, 3) * Multiplier) 

coefs_gradients.ecto_platy.common <- data.frame(Variable = common_platyecto_alphas$term, 
           a_ecto = common_platyecto_alphas$alpha,
           a_ecto_2.5 = common_platyecto_alphas$alpha_2.5,
           a_ecto_97.5 = common_platyecto_alphas$alpha_97.5,
           a_platy = common_platyecto_alphas$alpha,        
           a_platy_2.5 = common_platyecto_alphas$alpha_2.5, 
           a_platy_97.5 = common_platyecto_alphas$alpha_97.5,
           Selection_form = common_platyecto_alphas$Selection_form,
           Multiplier = common_platyecto_alphas$Multiplier) %>% 
  # for the selection gradients though, calculate them on the scale of relative fitness for each food-web treatment
  mutate(b_ecto = round(ecto_mean_brackets * a_ecto / ecto_mean_fitness, 3) * Multiplier,
         b_ecto_2.5 = round(ecto_mean_brackets * a_ecto_2.5 / ecto_mean_fitness, 3) * Multiplier,
         b_ecto_97.5 = round(ecto_mean_brackets * a_ecto_97.5 / ecto_mean_fitness, 3) * Multiplier,
         b_platy = round(platy_mean_brackets * a_platy / platy_mean_fitness, 3) * Multiplier,
         b_platy_2.5 = round(platy_mean_brackets * a_platy_2.5 / platy_mean_fitness, 3) * Multiplier,
         b_platy_97.5 = round(platy_mean_brackets * a_platy_97.5 / platy_mean_fitness, 3) * Multiplier)

coefs_gradients.ecto_platy <- bind_rows(coefs_gradients.ecto_platy, coefs_gradients.ecto_platy.common)


bind_rows(mutate(select(coefs_gradients.ecto_platy, Variable, a=a_ecto, a_2.5=a_ecto_2.5, a_97.5=a_ecto_97.5), platyecto = "ecto"),
          mutate(select(coefs_gradients.ecto_platy, Variable, a=a_platy, a_2.5=a_platy_2.5, a_97.5=a_platy_97.5), platyecto = "platy")) %>%
  filter(Variable != "(Intercept)") %>%
  ggplot(., aes(x = Variable, fill=platyecto, color=platyecto)) +
  geom_point(aes(y=a), position = position_dodge(width=0.5)) +
  geom_errorbar(aes(ymax = a_97.5, ymin = a_2.5), position = position_dodge(width=0.5)) +
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  ylab("Regression coefficient")

## Modify to be directional, nonlinear, then correlational with legend in 4th area.
## Modify so that axes have gamma and beta with the trait as a subscript
bind_rows(mutate(select(coefs_gradients.ecto_platy, Variable, b=b_ecto, b_2.5=b_ecto_2.5, b_97.5=b_ecto_97.5, Selection_form), platyecto = "ecto"),
          mutate(select(coefs_gradients.ecto_platy, Variable, b=b_platy, b_2.5=b_platy_2.5, b_97.5=b_platy_97.5, Selection_form), platyecto = "platy")) %>%
  filter(Variable != "(Intercept)") %>%
  ggplot(., aes(x = Variable, fill=platyecto, color=platyecto)) +
  geom_point(aes(y=b), position = position_dodge(width=0.5)) +
  geom_errorbar(aes(ymax = b_97.5, ymin = b_2.5), position = position_dodge(width=0.5)) +
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  facet_wrap(~Selection_form, nrow=2, scales = "free_y") +
  ylab("Selection gradient")
```


Compared to the GLM, the GLMM gives the same inferences about the effect of food-web treatment. The main difference was that there was stronger evidence of correlational selection, but no evidence that this correlational selection varied among food-web treatments. Still, this stronger evidence for correlational selection should be interpreted with caution since the GLM does not account for the non-indepedence of these fitness estimates. 
```{r Compare GLMM to GLM, include=FALSE, eval=FALSE}
## Fit GLMs. Dispersion parameter was ~1, so I just used a binomial model. 
null_glm <- glm(gall_survival ~ sc.Diam*sc.log.Clutch*sc.log1p.Pref + 
                      I(sc.Diam^2) + I(sc.log.Clutch^2) + I(sc.log1p.Pref^2),
                    data = gall_selection.df,
                    family = binomial(link = logit))

foodweb_glm <- glm(gall_survival ~ Foodweb*(sc.Diam*sc.log.Clutch*sc.log1p.Pref +
                         I(sc.Diam^2) + I(sc.log.Clutch^2) + I(sc.log1p.Pref^2)),
                       data = gall_selection.df,
                       family = binomial(link = logit))

## Compare statistical summaries of each model
summary(null_glm)
summary(foodweb_glm)
piecewiseSEM::rsquared(null_glm)
piecewiseSEM::rsquared(foodweb_glm)

## Test statistical significance of effects ----

# Overall, there is clear evidence that food-web treatment alters absolute fitness
anova(null_glm, foodweb_glm, test = "Chisq") 

## Parse out mechanisms of food-web effects ----
# Use drop1 to test highest order effects and visreg to visualize the effects

# Evidence that food-web treatment alters nonlinear selection acting on female preference. Appears to be evidence for disruptive selection in complex food web.
# Unique to GLM: marginal evidence for food-web treatment altering nonlinear selection on clutch size
drop1(foodweb_glm, test="Chisq")
visreg::visreg(foodweb_glm, xvar="sc.log1p.Pref", by="Foodweb", scale = "response") 
visreg::visreg(foodweb_glm, xvar="sc.log.Clutch", by="Foodweb", scale = "response")

# Evidence of nonlinear selection acting on gall size. No evidence of disruptive selection.
# No unique effects in the glm
foodweb_glm_2 <- update(foodweb_glm, .~. -Foodweb:I(sc.Diam^2) -Foodweb:I(sc.log.Clutch^2) -Foodweb:I(sc.log1p.Pref^2) -Foodweb:sc.Diam:sc.log.Clutch:sc.log1p.Pref)
drop1(foodweb_glm_2, test="Chisq") 
visreg::visreg(foodweb_glm_2, xvar="sc.Diam", scale = "response") 

# Evidence of food-web treatment altering directional selection on clutch size
# Unique to GLM: there is stronger support for correlational selection acting on gall size and clutch size; also, there is evidence for correlational selection acting on clutch size and female preference.
foodweb_glm_3 <- update(foodweb_glm_2, .~. -I(sc.Diam^2) -I(sc.log.Clutch^2) -I(sc.log1p.Pref^2) -sc.Diam:sc.log.Clutch:sc.log1p.Pref -Foodweb:sc.Diam:sc.log.Clutch -Foodweb:sc.Diam:sc.log1p.Pref -Foodweb:sc.log.Clutch:sc.log1p.Pref)
drop1(foodweb_glm_3, test="Chisq") 
visreg::visreg(foodweb_glm_3, xvar="sc.log.Clutch", by="Foodweb", scale="response")
visreg::visreg(foodweb_glm_3, xvar="sc.Diam", by="sc.log.Clutch", scale="response")
visreg::visreg(foodweb_glm_3, xvar="sc.log.Clutch", by="sc.Diam", scale="response") # a different perspective
visreg::visreg(foodweb_glm_3, xvar="sc.log1p.Pref", by="sc.log.Clutch", scale="response")
visreg::visreg(foodweb_glm_3, xvar="sc.log.Clutch", by="sc.log1p.Pref", scale="response")

# Evidence that food-web treatment alters absolute fitness; evidence of directional selection acting on gall size; no evidence of directional selection on clutch size (in complex food web); evidence of directional selection acting on female preference
# No unique effects in the glm
foodweb_glm_4 <- update(foodweb_glm_3, .~. -sc.Diam:sc.log.Clutch -sc.Diam:sc.log1p.Pref -sc.log.Clutch:sc.log1p.Pref -Foodweb:sc.Diam -Foodweb:sc.log.Clutch -Foodweb:sc.log1p.Pref)
drop1(foodweb_glm_4, test="Chisq") 
visreg::visreg(foodweb_glm_4, xvar="Foodweb", scale="response")
visreg::visreg(foodweb_glm_4, xvar="sc.Diam", scale="response")
visreg::visreg(foodweb_glm_4, xvar="sc.log.Clutch", scale="response")
visreg::visreg(foodweb_glm_4, xvar="sc.log1p.Pref", scale="response")
```

```{r Get Selection Gradients for GLM, include=FALSE, eval=FALSE}
complex_predict <- predict(foodweb_glm, newdata=filter(gall_selection.df, Foodweb=="Complex"), type="response")
complex_mean_brackets <- mean(complex_predict * (1 - complex_predict))
complex_mean_fitness <- mean(complex_predict)

simple_predict <- predict(foodweb_glm, newdata=filter(gall_selection.df, Foodweb=="Simple"), type="response")
simple_mean_brackets <- mean(simple_predict * (1 - simple_predict))
simple_mean_fitness <- mean(simple_predict)

foodweb_tidy_4 <- filter(tidy(foodweb_glm_4), term %in% c("(Intercept)","FoodwebSimple","sc.Diam","sc.log.Clutch","sc.log1p.Pref"))
foodweb_tidy_3 <- filter(tidy(foodweb_glm_3), term %in% c("sc.Diam:sc.log.Clutch","sc.Diam:sc.log1p.Pref","sc.log.Clutch:sc.log1p.Pref","FoodwebSimple:sc.Diam","FoodwebSimple:sc.log.Clutch","FoodwebSimple:sc.log1p.Pref"))
foodweb_tidy_2 <- filter(tidy(foodweb_glm_2), term %in% c("I(sc.Diam^2)","I(sc.log.Clutch^2)","I(sc.log1p.Pref^2)","sc.Diam:sc.log.Clutch:sc.log1p.Pref","FoodwebSimple:sc.Diam:sc.log.Clutch","FoodwebSimple:sc.Diam:sc.log1p.Pref","FoodwebSimple:sc.log.Clutch:sc.log1p.Pref"))
foodweb_tidy <- filter(tidy(foodweb_glm), term %in% c("FoodwebSimple:I(sc.Diam^2)","FoodwebSimple:I(sc.log.Clutch^2)","FoodwebSimple:I(sc.log1p.Pref^2)","FoodwebSimple:sc.Diam:sc.log.Clutch:sc.log1p.Pref"))

get_alphas <- bind_rows(foodweb_tidy_4, foodweb_tidy_3, foodweb_tidy_2, foodweb_tidy) %>% 
  mutate(alpha = round(estimate, 3), alpha_SE = round(std.error, 3), P = round(p.value, 3)) %>%
  select(term, alpha, alpha_SE, P)

complex_alphas <- filter(get_alphas, !grepl("FoodwebSimple", term))
simple_alphas <- filter(get_alphas, grepl("FoodwebSimple", term))

# remember that the selection gradients need to be multiplied by 2 for quadratic gradients.
data.frame(Variable = complex_alphas$term, 
           alpha_complex = complex_alphas$alpha, 
           alpha_simple = complex_alphas$alpha + simple_alphas$alpha) %>% # add the corresponding coefficients to get the coefficients on the same scale as the complex web)
  mutate(beta_complex = round(complex_mean_brackets * alpha_complex / complex_mean_fitness, 3),
         beta_simple = round(simple_mean_brackets * alpha_simple / simple_mean_fitness, 3)) %>%
  filter(Variable != "(Intercept)")

inverse_logit(complex_alphas$alpha[1]) - complex_mean_fitness # small difference in mean fitness estimates compared to intercept in complex food web
inverse_logit(complex_alphas$alpha[1] + simple_alphas$alpha[1]) - simple_mean_fitness # larger difference in mean fitness estimates from intercept in simple food web, unclear why...perhaps because the mean phenotypes don't match up as nicely?
```



```{r Mortality, include=FALSE, eval=FALSE}
# 8-10% mortality induced by intraguild predators
mean(control_df$platy)
mean(treatment_df$platy)
mean(eggptoid_control_df$platy)

# Gall mortality to Platy
1 - mean(treatment_df$pupa)

# Gall mortality to Ectos

# Platy mortality to intraguild predation
mean(treatment_df$platy) - mean(control_df$platy) 

mean(control_df$ectos)
mean(treatment_df$ectos)
mean(ectoptoid_control_df$ectos)

mean(control_df$pupa)
mean(treatment_df$pupa)
mean(eggptoid_control_df$pupa)
mean(ectoptoid_control_df$pupa)
```



<!--$$logit(E(W))=\mu+\beta_{diameter}+\beta_{clutch}+\beta_{preference}+$$
$$logit(E(W))=\mu+treatment+s(diam):treat+s(clutch)+s(pref)+diam:cluch+diam:pref+clutch:pref+(1|Genotype/Plant/Gall)$$-->

<!-- We used generalized linear mixed models (GLMMs, @Bolker2009) to test the effects of food-web complexity on the shape of the fitness landscape. 
Larva survival (0 or 1) was our response variable and measure of fitness. 
<!-- Need to clean up the language part of this section without it being too complicated and confusing. I should also include tests of non-linear selection gradients. -->
<!-- We specified our food-web treatment, each gall trait, two-way interactions between gall traits, as well interactions between gall trait and food-web treatment, as fixed effects to fully explore the effects of food-web complexity on the fitness landscape. 
This analysis implicitly assumes that selection is linear, which we felt was a necessary trade-off for exploring the shape of the fitness landscape. 
To account for the correlated structure of clutch size (gall level) and female preference (plant level) as well as any other independent effects of willow genotype on parasitism rates, we specified gall ID nested within plant ID nested within plant genotype as random intercepts in our statistical models. 
<!-- To identify the appropriate level of model complexity for testing the effects of food-web complexity on the fitness landscapes, we compared models using Aikaike Information Criteria. 
The maximal complexity we explored was a generalized additive mixed model that fit cubic splines to each trait as well as linear interactions between a maximum of two traits as well as an interaction with food-web treatment. -->

<!-- We used a spline-based semiparametric regression (Schluter 1988, Morrissey and Sakedra 2014). These analyses are desirable because they lead to inferences of the form of selection that make few \textit{a priori} assumptions (Schluter 1988), and can now be used to quantify standardized selection gradients (Morrissey and Sakrera 2014).

We then calculated selection gradients as the partial derivatives in absolute fitness (larva survival) with response to multivariate phenotype using the \textit{gsg} package in R (cite Morrissey and R project). We standardized phenotypes (mean=0, SD=1), so that first-order derivatives correspond to the intensity of directional selection ($\beta$\textsubscript{trait}), while second-order derivatives correspond to intensity of nonlinear ($\gamma$\textsubscript{trait}) and correlational selection ($\gamma$\textsubscript{trait$_i$,}\textsubscript{trait$_j$}) and are thus comparable within this study as well as to others. -->

<!-- Our GLMMs are useful for testing the effects of food-web complexity on the fitness landscape within the context of our experimental design; however, coefficients from GLMMs cannot be easily converted into quantitative estimates of selection gradients (cite Morrissey's work). Therefore, for each treatment, we fit separate generalized additive models (GAMs) for gall traits that we identified as being under selection from our GLMMs. Estimating selection gradients from GAMs can give insight to both linear and non-linear selection gradients, which we assumed were all linear for our GLMMs, given the complexity of already fitting up to 4-way interactions in these models. For the number of larva per gall and gall density, we aggregated larva survival at the gall or plant level, respectively, to avoid pseudoreplication in our GAMs. -->

```{r Figure 1, include=FALSE, eval=FALSE, echo=FALSE, fig.cap="Illustrations of complex (A) and simple (B) food webs associated with the insect herbivore, *Iteomyia salicisverruca*. Black arrows denote 'who-eats-whom' in this network of trophic interactions."}
knitr::include_graphics("complex_simple_foodwebs_compressed.pdf")
```


Results
=======

We found that changes in food-web complexity altered the shape of *Iteomyia*'s fitness landscape (). 

For example, there was directional selection for larger gall diameter in both complex and simple food webs, but the magnitude of the selection gradient was X-fold higher in the complex food web. The steeper selection gradient in the complex food web was not a result of stronger covariance between gall diameter and larval survival, but a result of average larval survival being X-fold lower in the complex food web.

We observed directional selection for smaller clutch sizes in the simple food web, but no evidence of selection on this trait in the complex food web. The absence of selection in the complex food web appeared to be a result of conflicting selection pressures imposed by the egg parasitoid *Platygaster* and the guild of larval parasitoids (statistical test focus on egg vs. larval parasitoids). Specifically, larval parasitoids actually impose directional selection for larger clutch sizes (selection gradient), but the net effect is no selection when both parasitoid guilds are present.  

We found evidence of disruptive selection acting on female preference in the complex food web, but no evidence of nonlinear selection on this trait in the simple food web. Similar to clutch size, these differences in nonlinear selection appeared to be due to different selection pressures imposed by egg and larval parasitoids. 

**Characterizing the slope and curvature of the fitness landscape**


**Old**

```{r OLD TEXT, include=FALSE, eval=FALSE}
$\chi^2_{`r foodweb_test$[2,"Chi.Df"]`}=`r foodweb_test$[2,"statistic"]`, P=`r foodweb_test$[2,"p.value"]`$). 

Two key patterns emerged from our analyses. First, fewer phenotypic traits were under selection in the complex vs. simple food web. 
In both complex and simple food webs, gall diameter was under strong directional selection, with larger galls resulting in higher larval survival (complex $\beta_{diam}=$`r paste0(filter(summary_beta_control, Phenotype=="Gall diameter")$Estimate," [",filter(summary_beta_control, Phenotype=="Gall diameter")$lower_2.5,",",filter(summary_beta_control, Phenotype=="Gall diameter")$upper_97.5,"]")`; simple $\beta_{diam}=$ `r paste0(filter(summary_beta_treatment, Phenotype=="Gall diameter")$Estimate," [",filter(summary_beta_treatment, Phenotype=="Gall diameter")$lower_2.5,",",filter(summary_beta_treatment, Phenotype=="Gall diameter")$upper_97.5,"]")`)(Fig. \ref{fig:Univariate_Landscapes}A). 

In the complex food web, we found that there was no selection acting on clutch size

In simple food webs, both clutch size and female preference experience directional selection, with smaller clutch sizes ($\beta_{clutch}=$
`r paste0(filter(summary_beta_treatment, Phenotype=="Clutch size")$Estimate," [",filter(summary_beta_treatment, Phenotype=="Clutch size")$lower_2.5,",",filter(summary_beta_treatment, Phenotype=="Clutch size")$upper_97.5,"]")`
and weaker preferences ($\beta_{pref}=$
`r paste0(filter(summary_beta_treatment, Phenotype=="Female preference")$Estimate," [",filter(summary_beta_treatment, Phenotype=="Female preference")$lower_2.5,",",filter(summary_beta_treatment, Phenotype=="Female preference")$upper_97.5,"]")`
) resulting in higher larval survival (blue lines in Fig. \ref{fig:Univariate_Landscapes}B,C).
In contrast, there was no evidence of selection on clutch size ($\beta_{clutch}=$
`r paste0(filter(summary_beta_control, Phenotype=="Clutch size")$Estimate," [",filter(summary_beta_control, Phenotype=="Clutch size")$lower_2.5,",",filter(summary_beta_control, Phenotype=="Clutch size")$upper_97.5,"]")`
) or female preference ($\beta_{pref}=$
`r paste0(filter(summary_beta_control, Phenotype=="Female preference")$Estimate," [",filter(summary_beta_control, Phenotype=="Female preference")$lower_2.5,",",filter(summary_beta_control, Phenotype=="Female preference")$upper_97.5,"]")`
) in complex food webs (orange lines in Fig. \ref{fig:Univariate_Landscapes}B,C). The absence of selection on clutch size and female preference was likely a result of conflicting selection pressures imposed by each guild of parasitoids due to their different functional relationships with gall traits. Together, these different patterns of selection resulted in an ideal combination of traits having higher fitness in the simple food web (large diameter, smaller clutches, weaker preference), whereas there was a larger combination of trait values that had equal fitness in the complex food web (Fig. \ref{fig:Multivariate_Landscapes}).
We did not find any strong evidence for nonlinear or correlational selection gradients acting on gall traits in either food-web treatment.
The second major pattern was that the overall intensity of selection was stronger in the complex vs. simple food web. This result appeared to be driven by selection on gall diameter in the complex food web, which was more than 
`r round(filter(summary_beta_control, Phenotype=="Gall diameter")$Estimate/filter(summary_beta_treatment, Phenotype=="Gall diameter")$Estimate,1)`
$\times$ larger than any other selection gradient in our analyses. 

-->
```



```{r Get Gall Diameter Relative Fitness Landscape, cache=TRUE, include=FALSE, eval=FALSE}

# Control ----
RF_control_gall_size <- bootstrap_fitness(
  logistic_model = quad_control, 
  fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2)",
  newdata = expand.grid(
     sc.gall_size = seq(-1,1,length.out=1000), 
     sc.log.clutch_size = 0,
     sc.log1p.female_preference = 0),
  bootstraps=n_boots_plots)


# Treatment ----
RF_treatment_gall_size <- bootstrap_fitness(
  logistic_model = quad_treatment, 
  fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2)",
  newdata = expand.grid(
     sc.gall_size = seq(-1,1,length.out=1000),
     sc.log.clutch_size = 0,
     sc.log1p.female_preference = 0),
  bootstraps=n_boots_plots)
```

```{r Get Clutch Size Fitness Landscape, cache=TRUE, include=FALSE, eval=FALSE}

# Control ----
RF_control_clutch_size <- bootstrap_fitness(
  logistic_model = quad_control, 
  fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2)",
  newdata = expand.grid(
     sc.gall_size = 0,
     sc.log.clutch_size = seq(-1,1,length.out=1000),
     sc.log1p.female_preference = 0),
  bootstraps=n_boots_plots)

# Treatment ----
RF_treatment_clutch_size <- bootstrap_fitness(
  logistic_model = quad_treatment, 
  fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2)",
  newdata = expand.grid(
     sc.gall_size = 0,
     sc.log.clutch_size = seq(-1,1,length.out=1000),
     sc.log1p.female_preference = 0),
  bootstraps=n_boots_plots)
```

```{r Get Female Preference Fitness Landscape, include=FALSE, eval=FALSE}

# Control ----
RF_control_female_preference <- bootstrap_fitness(
  logistic_model = quad_control, 
  fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2)",
  newdata = expand.grid(
     sc.gall_size = 0,
     sc.log.clutch_size = 0, 
     sc.log1p.female_preference = seq(-1,1,length.out=1000)), 
  bootstraps=n_boots_plots)

# Treatment ----
RF_treatment_female_preference <- bootstrap_fitness(
  logistic_model = quad_treatment, 
  fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2)",
  newdata = expand.grid(
     sc.gall_size = 0,
     sc.log.clutch_size = 0,
     sc.log1p.female_preference = seq(-1,1,length.out=1000)), 
  bootstraps=n_boots_plots)

```


```{r Get Clutch Size x Female Preference Landscape, include=FALSE, eval=FALSE}

# Control ----
RF_control_clutch.x.preference <- bootstrap_fitness(
  logistic_model = corr_control, 
  fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2) + sc.gall_size:sc.log.clutch_size + sc.gall_size:sc.log1p.female_preference + sc.log.clutch_size:sc.log1p.female_preference",
  newdata = expand.grid(
     sc.gall_size = 0,
     sc.log.clutch_size = seq(-1,1,length.out=1000), 
     sc.log1p.female_preference = seq(-1,1,length.out=1000)), 
  bootstraps=NULL)

# Treatment ----
RF_treatment_clutch.x.preference <- bootstrap_fitness(
  logistic_model = corr_treatment, 
  fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2) + sc.gall_size:sc.log.clutch_size + sc.gall_size:sc.log1p.female_preference + sc.log.clutch_size:sc.log1p.female_preference",
  newdata = expand.grid(
     sc.gall_size = 0,
     sc.log.clutch_size = seq(-1,1,length.out=1000),
     sc.log1p.female_preference = seq(-1,1,length.out=1000)), 
  bootstraps=NULL)
```


```{r Get Gall Diameter x Clutch Size Landscape, include=FALSE, eval=FALSE}

# Control ----
RF_control_size.x.clutch <- bootstrap_fitness(
  logistic_model = corr_control, 
  fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2) + sc.gall_size:sc.log.clutch_size + sc.gall_size:sc.log1p.female_preference + sc.log.clutch_size:sc.log1p.female_preference",
  newdata = expand.grid(
     sc.gall_size = seq(-1,1,length.out=1000),
     sc.log.clutch_size = seq(-1,1,length.out=1000), 
     sc.log1p.female_preference = 0), 
  bootstraps=NULL)

# Treatment ----
RF_treatment_size.x.clutch <- bootstrap_fitness(
  logistic_model = corr_treatment, 
  fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2) + sc.gall_size:sc.log.clutch_size + sc.gall_size:sc.log1p.female_preference + sc.log.clutch_size:sc.log1p.female_preference",
  newdata = expand.grid(
     sc.gall_size = seq(-1,1,length.out=1000),
     sc.log.clutch_size = seq(-1,1,length.out=1000),
     sc.log1p.female_preference = 0), 
  bootstraps=NULL)
```

```{r Get Gall Diameter x Female Preference Landscape, include=FALSE, eval=FALSE}

# Control ----
RF_control_size.x.preference <- bootstrap_fitness(
  logistic_model = corr_control, 
  fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2) + sc.gall_size:sc.log.clutch_size + sc.gall_size:sc.log1p.female_preference + sc.log.clutch_size:sc.log1p.female_preference",
  newdata = expand.grid(
     sc.gall_size = seq(-1,1,length.out=1000),
     sc.log.clutch_size = 0, 
     sc.log1p.female_preference = seq(-1,1,length.out=1000)), 
  bootstraps=NULL)

# Treatment ----
RF_treatment_size.x.preference <- bootstrap_fitness(
  logistic_model = corr_treatment, 
  fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2) + sc.gall_size:sc.log.clutch_size + sc.gall_size:sc.log1p.female_preference + sc.log.clutch_size:sc.log1p.female_preference",
  newdata = expand.grid(
     sc.gall_size = seq(-1,1,length.out=1000),
     sc.log.clutch_size = 0,
     sc.log1p.female_preference = seq(-1,1,length.out=1000)), 
  bootstraps=NULL)
```


```{r Fitness Landscape Plot Helpers, include=FALSE, eval=FALSE}

## Color palette ----

# order -> orange, light blue, green, yellow, dark blue, red, pink
cbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7", "#000000", "#999999")
complex_color <- cbPalette[6] # 1
simple_color <- cbPalette[5] # 2
treatment_colors <- c(complex_color, simple_color)

## Scale relative fitness across plots ----

# 1D
RF_gradient_range <- bind_rows(RF_treatment_gall_size$relative_fitness, RF_control_gall_size$relative_fitness,
          RF_treatment_clutch_size$relative_fitness, RF_control_clutch_size$relative_fitness,
          RF_treatment_female_preference$relative_fitness, RF_control_female_preference$relative_fitness) %>%
  select(-sc.log.clutch_size, -sc.log1p.female_preference) %>%
  gather(ID, relative_fitness, -sc.gall_size) %>%
  mutate(ID_group = ifelse(ID == "average", "average", "replicate")) %>% 
  summarise(min = min(relative_fitness), max = max(relative_fitness))
RF_gradient_scale <- c(0,0.5,1,1.5,2) #,2.5) # adjusted based on range

# 2D
RF_range <- bind_rows(RF_treatment_clutch.x.preference$relative_fitness, RF_control_clutch.x.preference$relative_fitness,
          RF_treatment_size.x.clutch$relative_fitness, RF_control_size.x.clutch$relative_fitness,
          RF_treatment_size.x.preference$relative_fitness, RF_control_size.x.preference$relative_fitness) %>%
  summarise(min = min(average), max = max(average))

## Scale absolute fitness across plots ----

# 1D
AF_gradient_scale <- c(0,0.25,0.5,0.75,1) # adjusted based on range

# 2D
AF_range <- bind_rows(RF_treatment_clutch.x.preference$absolute_fitness, RF_control_clutch.x.preference$absolute_fitness,
          RF_treatment_size.x.clutch$absolute_fitness, RF_control_size.x.clutch$absolute_fitness,
          RF_treatment_size.x.preference$absolute_fitness, RF_control_size.x.preference$absolute_fitness) %>%
  summarise(min = min(average), max = max(average))
```

```{r Plot Univariate Landscapes, include=FALSE, eval=FALSE}
uni_breaks <- c(0.1,0.5,1)

# Gall size 
AF_uni_size <- bind_rows(mutate(RF_treatment_gall_size$absolute_fitness, Food_Web = "Simple"), 
          mutate(RF_control_gall_size$absolute_fitness, Food_Web = "Complex")) %>%
  select(-sc.log.clutch_size, -sc.log1p.female_preference) %>%
  gather(ID, absolute_fitness, -sc.gall_size, -Food_Web) %>%
  mutate(ID_group = ifelse(ID == "average", "average", "replicate")) %>% 
  ggplot(., aes(x=sc.gall_size, y=absolute_fitness, group=interaction(ID,Food_Web), color=Food_Web, alpha=ID_group, size=ID_group)) +
  geom_line() +
  scale_alpha_manual(values=c(1,0.2), guide=FALSE) +
  scale_size_manual(values=c(1.5,0.25), guide=FALSE) +
  xlab("Gall diameter (SDs)") +
  ylab("Population mean fitness") +
  scale_color_manual(values = treatment_colors, name = "Food web") +
  scale_x_continuous(breaks=c(-1,-0.5,0,0.5,1), labels = c(-1,-0.5,0,0.5,1)) +
  scale_y_log10(breaks=uni_breaks, labels=uni_breaks) + annotation_logticks(sides = "l") +
  coord_cartesian(ylim=c(0.07,1))
#AF_uni_size
  #scale_y_continuous(breaks = AF_gradient_scale, limits = c(min(AF_gradient_scale), max(AF_gradient_scale)), trans = "log")

# Clutch size
AF_uni_clutch <- bind_rows(mutate(RF_treatment_clutch_size$absolute_fitness, Food_Web = "Simple"), 
          mutate(RF_control_clutch_size$absolute_fitness, Food_Web = "Complex")) %>%
  select(-sc.gall_size, -sc.log1p.female_preference) %>%
  gather(ID, absolute_fitness, -sc.log.clutch_size, -Food_Web) %>%
  mutate(ID_group = ifelse(ID == "average", "average", "replicate")) %>% 
  ggplot(., aes(x=sc.log.clutch_size, y=absolute_fitness, group=interaction(ID,Food_Web), color=Food_Web, alpha=ID_group, size=ID_group)) +
  geom_line() +
  scale_alpha_manual(values=c(1,0.2), guide=FALSE) +
  scale_size_manual(values=c(1.5,0.25), guide=FALSE) +
  xlab("Clutch size (SDs)") +
  ylab("Population mean fitness") +
  scale_color_manual(values = treatment_colors, name = "Food web") +
  scale_x_continuous(breaks=c(-1,-0.5,0,0.5,1), labels = c(-1,-0.5,0,0.5,1)) +
  scale_y_log10(breaks=uni_breaks, labels=uni_breaks) + annotation_logticks(sides = "l") +
  coord_cartesian(ylim=c(0.07,1))
  #scale_y_continuous(breaks = AF_gradient_scale, limits = c(min(AF_gradient_scale), max(AF_gradient_scale)), trans = "log")

# Female preference
AF_uni_pref <- bind_rows(mutate(RF_treatment_female_preference$absolute_fitness, Food_Web = "Simple"), 
          mutate(RF_control_female_preference$absolute_fitness, Food_Web = "Complex")) %>%
  select(-sc.gall_size, -sc.log.clutch_size) %>%
  gather(ID, absolute_fitness, -sc.log1p.female_preference, -Food_Web) %>%
  mutate(ID_group = ifelse(ID == "average", "average", "replicate")) %>% 
  ggplot(., aes(x=sc.log1p.female_preference, y=absolute_fitness, group=interaction(ID,Food_Web), color=Food_Web, alpha=ID_group, size=ID_group)) +
  geom_line() +
  scale_alpha_manual(values=c(1,0.2), guide=FALSE) +
  scale_size_manual(values=c(1.5,0.25), guide=FALSE) +
  xlab("Female preference (SDs)") +
  ylab("Population mean fitness") +
  scale_color_manual(values = treatment_colors, name = "Food web") +
  scale_x_continuous(breaks=c(-1,-0.5,0,0.5,1), labels = c(-1,-0.5,0,0.5,1)) +
  scale_y_log10(breaks=uni_breaks, labels=uni_breaks) + annotation_logticks(sides = "l") +
  coord_cartesian(ylim=c(0.07,1))
  #scale_y_continuous(breaks = AF_gradient_scale, limits = c(min(AF_gradient_scale), max(AF_gradient_scale)), trans = "log")
```

```{r Univariate_Landscapes, include=FALSE, eval=FALSE, echo=FALSE, fig.cap="\\label{fig:Univariate_Landscapes}Selection gradients acting on gall traits in complex vs. simple food webs. Each panel corresponds to a different gall trait: gall diameter (A); clutch size (B); and female preference (C). Solid lines represent the estimated gradients in complex (orange) and simple (blue) food webs. Transparent lines represent bootstrapped replicates (n=100) to show the uncertainty in estimated gradients. Note that only 100 bootstraps are displayed here, but that inferences are based on 1,000 bootstrapped samples."}

# Get legend
AF_uni_legend <- get_legend(AF_uni_size)

# Make plots
AF_uni_plots <- plot_grid(AF_uni_size + theme(legend.position = "none", 
                                              axis.text.x = element_text(size=10),
                                              axis.title.x = element_text(size=11)), 
                       AF_uni_clutch + theme(legend.position = "none",
                                             axis.title.y = element_blank(), 
                                             axis.text.y = element_blank(),
                                             axis.text.x = element_text(size=10),
                                             axis.title.x = element_text(size=11)),
                       AF_uni_pref + theme(legend.position = "none", 
                                           axis.title.y = element_blank(), 
                                           axis.text.y = element_blank(), 
                                           axis.text.x = element_text(size=10),
                                           axis.title.x = element_text(size=11)),
                       labels = "AUTO", ncol = 3, align='hv')

AF_gradients <- ggdraw(AF_uni_plots) + draw_grob(AF_uni_legend, x = 0.7, y=-0.2) # draw_grob(AF_uni_legend, x = 0.8, y=0)
AF_gradients
#AF_uni_plots
# save_plot("FL_1D.pdf", AF_uni_plots, base_height = 6.5, base_width = 8)
```

```{r Plot Multivariate Fitness Landscape, include=FALSE, eval=FALSE}

my_breaks <- c(0.2,0.4,0.6,0.8)

# Size x Preference
AF_plot_size.x.preference <- bind_rows(mutate(RF_treatment_size.x.preference$absolute_fitness, Food_Web = "Simple"), 
          mutate(RF_control_size.x.preference$absolute_fitness, Food_Web = "Complex")) %>%
  ggplot(., aes(x=sc.gall_size, y=sc.log1p.female_preference, fill=average)) +
  geom_raster() +
  facet_wrap(~Food_Web) +
  xlab("Gall diameter (SDs)") +
  ylab("Female preference (SDs)") +
  scale_x_continuous(labels = c(-1,-0.5,0,0.5,1)) +
  scale_y_continuous(labels = c(-1,-0.5,0,0.5,1)) +
  scale_fill_viridis(name = "Population\nmean fitness", trans="log", breaks = my_breaks, labels = my_breaks, limits = c(0.1,1)) # limits = c(AF_range$min, AF_range$max), 

# Size x Clutch
AF_plot_size.x.clutch <- bind_rows(mutate(RF_treatment_size.x.clutch$absolute_fitness, Food_Web = "Simple"), 
          mutate(RF_control_size.x.clutch$absolute_fitness, Food_Web = "Complex")) %>%
  ggplot(., aes(x=sc.gall_size, y=sc.log.clutch_size, fill=average)) +
  geom_raster() +
  facet_wrap(~Food_Web) +
  xlab("Gall diameter (SDs)") +
  ylab("Clutch size (SDs)") +
  scale_x_continuous(labels = c(-1,-0.5,0,0.5,1)) +
  scale_y_continuous(labels = c(-1,-0.5,0,0.5,1)) +
  scale_fill_viridis(name = "Population\nmean fitness", trans="log", breaks = my_breaks, labels = my_breaks, limits = c(0.1,1)) # limits = c(AF_range$min, AF_range$max), 

# Clutch x Preference
AF_plot_clutch.x.preference <- bind_rows(mutate(RF_treatment_clutch.x.preference$absolute_fitness, Food_Web = "Simple"), 
          mutate(RF_control_clutch.x.preference$absolute_fitness, Food_Web = "Complex")) %>%
  ggplot(., aes(x=sc.log1p.female_preference, y=sc.log.clutch_size, fill=average)) +
  geom_raster() +
  facet_wrap(~Food_Web) +
  xlab("Female preference (SDs)") +
  ylab("Clutch size (SDs)") +
  scale_x_continuous(labels = c(-1,-0.5,0,0.5,1)) +
  scale_y_continuous(labels = c(-1,-0.5,0,0.5,1)) +
  scale_fill_viridis(name = "Population\nmean fitness", trans="log", breaks = my_breaks, labels = my_breaks, limits = c(0.1,1)) # limits = c(AF_range$min, AF_range$max), 
```

```{r Multivariate_Landscapes, include=FALSE, eval=FALSE, echo=FALSE, fig.cap="\\label{fig:Multivariate_Landscapes}Fitness landscapes of gall traits in complex vs. simple food webs. Each panel corresponds to a different combination of traits: clutch size and gall diameter (A); clutch size and female preference (B); female preference and gall diameter (C). Note that traits for all plots range 1 SD below and above the mean (=0)."}
# Get legend
AF_landscape_legend <- get_legend(AF_plot_size.x.preference)

# Format plots
AF_landscape_plots <- plot_grid(
  AF_plot_size.x.clutch + theme(legend.position = "none", axis.title.x = element_blank()),
  AF_plot_clutch.x.preference + theme(legend.position = "none", axis.title.y = element_blank()),
  AF_plot_size.x.preference + theme(legend.position = "none"), 
  nrow=2, align="hv", labels = "AUTO")
AF_landscape_2d <- ggdraw(AF_landscape_plots) + draw_grob(AF_landscape_legend, x = 0.7, y=-0.2)
AF_landscape_2d
#save_plot("AF_landscapes_2d.png", AF_landscape_2d, base_height=6, base_width = 8)
#save_plot("FL_2D.pdf", AF_landscape_2d, base_height=6, base_width = 8)
```


Discussion
==========

<!-- Summary -->

Our key finding was that the adaptive landscape was less constrained in the complex vs. simple food web. These fewer constraints arise from conflicting selection pressures imposed by different parasitoid guilds, resulting in fewer traits under selection in the complex food web. At the same time, we observed an overall greater intensity of selection in the complex food web, suggesting that trait evolution can be faster in complex vs. simple food webs. Our observation that natural selection was more constrained and less intense in simple vs. complex food webs suggests that the loss of biodiversity could constrain the adaptive potential of interacting species by reducing genetic and phenotypic variation in multiple traits.

<!-- Selective constraints result -->

Current theory suggests that when the number of selective constrains is less than the number of genetic constraints (i.e. some genetically variable traits are selective neutral), there are multiple positions on the landscape that confer equal fitness (Lande 1981; Lande and Arnold 1985). In this scenario, trait differences between populations may simply be due to neutral processes (e.g. genetic drift and mutation) moving trait values of the population. For our system, we currently lack quantitative estimates of genetic variation in our traits, although work with other species of galling insects has shown that gall diameter (Abramhson, Heath's work), clutch size (look to Weiss' work), and oviposition preference (Abrahmson's work?) are genetically variable. We encourage others to examine how changes in community context will alter selection on multiple traits.

<!-- Intensity of selection result -->

One interesting result of our work was that the overall intensity of selection appeared to be larger in complex food webs. This result was driven by the large selection gradient acting on gall diameter in complex vs. simple food webs. This difference in selection intensity is likely not driven by a difference in the ecological relationship between gall diameter and parasitoid attack (i.e. slope), but actually a result of the lower mean fitness of *Iteomyia* in the complex food web. This lower mean fitness is not surprising ---we excluded an entire guild of parasitoids from attacking the insect. But this more intense selection pressure may simply represent a transient dynamic. This is because we would expect the egg-parasitoid *Platygaster* to increase in abundance over time once its intraguild predator has been removed. While our results suggest that this wouldn't affect the slope of the relationship, the higher abundance of the egg parasitoid would likely reduce the mean fitness of *Iteomyia*, thus increasing the selection gradient acting on gall diameter closer to what we observed in the complex food web. We don't expect it to fully compensate, given that the larval parasitoids exhibit a different functional relationship with gall traits, and thus we expect a more diverse community of primary parasitoids to generally impose greater parasitism pressure, a factor that appears to be a general trend in parasitoid community (Hawkins citation) and likely for other consumers (Ives and Cardinale Ecology Letters).

<!-- Quantifying indirect effects of food-web complexity -->

Our study focused on quantifying the direct effects of changes in network complexity on the fitness landscape; however, changes in network complexity may have pervasive indirect effects via coevolution or by initiating evolutionary cascades. In our system, we observed that excluding the guild of larval parasitoids altered selection on both the basal resource (*Iteomyia*) and the intraguild prey (*Platygaster*). GIVE DETAILS AND SUGGEST A POTENTIAL EVOLUTIONARY CASCADE.

<!-- Generality of effects of food-web complexity -->

Our study manipulated food-web complexity and examined changes in the fitness landscape of species embedded within this network. However, other studies have also examined, at least theoretically, how changes in the diversity of competitive communities affects evolution. These studies have generally suggested that the diversity of competitors may actually constrain the adaptive landscape, a finding that stands in contrast to our results. NEED TO REVIEW THESE PAPERS TO SEE HOW ITS DIFFERENT.

<!-- Conclusion -->

We suggest that by explicitly focusing on network structure, we can predict how changes in biodiversity will affect the adaptive potential of constituent species. A network allows a powerful representation of the 'community context', lending predictive power to how changes in network structure (either due to loss of species or links), will alter natural selection and consequently evolutionary change. Our results also suggest that losing biodiversity may not just have consequences at the community level, but also population-level consequences that may actually constrain adaptation to changing environments. This argues that changes in network complexity may not only affect the robustness of communities, but also that of constituent populations to future environmental change.

<!-- 
From Arnold Am Nat 1992 Constrains on phenotypic evolution
 Evolutionary models with constant adaptive landscapes and G-matrices pro-
 vide some generalizations about the effects of selective constraints. First, the
 phenotypic mean of the population tends to evolve in an uphill direction on the
 adaptive landscape (Lande 1979). When selection is frequency-independent and
 the landscape is Gaussian, the population mean equilibrates on an adaptive peak.
 Burger (1986), however, modeled evolution on a landscape that was an ascending
 ridge with increasingly steep flanks. He found that the population would equili-
 brate on the ridge crest when stabilizing selection reached a critical level. Second,
 frequency-dependent selection generally causes the population to equilibrate
 some distance downslope from an adaptive peak (Lande 1976b, 1980b). Finally,
 when the number of selective constraints is less than the number of genetic con-
 straints so that some genetically variable traits are selectively neutral, there is a
 collection of possible equilibrium points (a line, plane, or hyperplane) rather than
 a single equilibrium point (Lande 1981; Lande and Arnold 1985). In the case of
 mating preferences and sexually selected traits, for example, the evolutionary
 outcome is changed dramatically depending on whether selection acts on mating
 preferences (Arnold 1987; Pomiankowski et al. 1991).

I. Feedbacks between biological diversity and evolutionary change 

More recently, researchers have begun to explore how the community context drives evolutionary change (@McPeek2017; @TerHorst2018). 

NEED to recognize that evolutionary biologists have begun to explore how community context affects evolutionary change (work by Sharon Strauss, Casey terHorst, Lutz Becks, etc.). These results have begun to show interesting patterns whereby the composition of species in a community can alter the direction and strength of natural selection imposed on species embedded within these communities (cite). 

In other words, these results have begun to illustrate show how biological diversity, in terms of differences between species, can shape evolution. Nevertheless, predicting the how the composition of species in a community requires moving beyond a description of community composition. simply knowing the composition of species in a community will 



There are various bibliography styles available. You can select the
style of your choice in the preamble of this document. These styles are
Elsevier styles based on standard styles like Harvard and Vancouver.
Please use BibTeX to generate your bibliography and include DOIs
whenever available.

Here are two sample references: @Feynman1963118 [@Dirac1953888].
-->

References {#references .unnumbered}
==========

```{r Univariate Absolute Fitness Landscapes, include=FALSE, eval=FALSE}
## Absolute fitness plots ----

# Gall size 
AF_uni_size <- bind_rows(mutate(RF_treatment_gall_size$absolute_fitness, Food_Web = "Simple"), 
          mutate(RF_control_gall_size$absolute_fitness, Food_Web = "Complex")) %>%
  select(-sc.log.clutch_size, -sc.log1p.female_preference) %>%
  gather(ID, absolute_fitness, -sc.gall_size, -Food_Web) %>%
  mutate(ID_group = ifelse(ID == "average", "average", "replicate")) %>% 
  ggplot(., aes(x=sc.gall_size, y=absolute_fitness, group=interaction(ID,Food_Web), color=Food_Web, alpha=ID_group, size=ID_group)) +
  geom_line() +
  scale_alpha_manual(values=c(1,0.1), guide=FALSE) +
  scale_size_manual(values=c(1.5,0.25), guide=FALSE) +
  xlab("Gall diameter (SDs)") +
  ylab("Absolute fitness") +
  scale_color_manual(values = treatment_colors, name = "Food web") +
  scale_y_continuous(breaks = AF_gradient_scale, limits = c(min(AF_gradient_scale), max(AF_gradient_scale)))

# Clutch size
AF_uni_clutch <- bind_rows(mutate(RF_treatment_clutch_size$absolute_fitness, Food_Web = "Simple"), 
          mutate(RF_control_clutch_size$absolute_fitness, Food_Web = "Complex")) %>%
  select(-sc.gall_size, -sc.log1p.female_preference) %>%
  gather(ID, absolute_fitness, -sc.log.clutch_size, -Food_Web) %>%
  mutate(ID_group = ifelse(ID == "average", "average", "replicate")) %>% 
  ggplot(., aes(x=sc.log.clutch_size, y=absolute_fitness, group=interaction(ID,Food_Web), color=Food_Web, alpha=ID_group, size=ID_group)) +
  geom_line() +
  scale_alpha_manual(values=c(1,0.1), guide=FALSE) +
  scale_size_manual(values=c(1.5,0.25), guide=FALSE) +
  xlab("Clutch size (SDs)") +
  ylab("Absolute fitness") +
  scale_color_manual(values = treatment_colors, name = "Food web") +
  scale_y_continuous(breaks = AF_gradient_scale, limits = c(min(AF_gradient_scale), max(AF_gradient_scale)))

# Female preference
AF_uni_pref <- bind_rows(mutate(RF_treatment_female_preference$absolute_fitness, Food_Web = "Simple"), 
          mutate(RF_control_female_preference$absolute_fitness, Food_Web = "Complex")) %>%
  select(-sc.gall_size, -sc.log.clutch_size) %>%
  gather(ID, absolute_fitness, -sc.log1p.female_preference, -Food_Web) %>%
  mutate(ID_group = ifelse(ID == "average", "average", "replicate")) %>% 
  ggplot(., aes(x=sc.log1p.female_preference, y=absolute_fitness, group=interaction(ID,Food_Web), color=Food_Web, alpha=ID_group, size=ID_group)) +
  geom_line() +
  scale_alpha_manual(values=c(1,0.1), guide=FALSE) +
  scale_size_manual(values=c(1.5,0.25), guide=FALSE) +
  xlab("Female preference (SDs)") +
  ylab("Absolute fitness") +
  scale_color_manual(values = treatment_colors, name = "Food web") +
  scale_y_continuous(breaks = AF_gradient_scale, limits = c(min(AF_gradient_scale), max(AF_gradient_scale)))
```

```{r Figure S1 Univariate Absolute Fitness Landscapes, include=FALSE, eval=FALSE}

# Get legend
AF_uni_legend <- get_legend(AF_uni_size)

# Make plots
AF_uni_plots <- plot_grid(AF_uni_size + theme(legend.position = "none"), 
                       AF_uni_clutch + theme(legend.position = "none", 
                                          axis.title.y = element_blank(), axis.text.y = element_blank()),
                       AF_uni_pref + theme(legend.position = "none", 
                                        axis.title.y = element_blank(), axis.text.y = element_blank()),
                       labels = "AUTO", ncol = 4, align='hv')

AF_gradients <- ggdraw(AF_uni_plots) + draw_grob(AF_uni_legend, x = 0.8, y=0)
AF_gradients
#save_plot("AF_gradients.png", AF_gradients, base_height=6, base_width = 8)
#save_plot("AF_gradients.pdf", AF_gradients, base_height=6, base_width = 8)
```


```{r Multivariate Absolute Fitness Landscapes, include=FALSE, eval=FALSE}

# Size x Preference
AF_plot_size.x.preference <- bind_rows(mutate(RF_treatment_size.x.preference$absolute_fitness, Food_Web = "Simple"), 
          mutate(RF_control_size.x.preference$absolute_fitness, Food_Web = "Complex")) %>%
  ggplot(., aes(x=sc.gall_size, y=sc.log1p.female_preference, fill=average)) +
  geom_raster() +
  facet_wrap(~Food_Web) +
  xlab("Gall diameter (SDs)") +
  ylab("Female preference (SDs)") +
  scale_fill_viridis(limits = c(AF_range$min, AF_range$max), name = "Absolute fitness")

# Size x Clutch
AF_plot_size.x.clutch <- bind_rows(mutate(RF_treatment_size.x.clutch$absolute_fitness, Food_Web = "Simple"), 
          mutate(RF_control_size.x.clutch$absolute_fitness, Food_Web = "Complex")) %>%
  ggplot(., aes(x=sc.gall_size, y=sc.log.clutch_size, fill=average)) +
  geom_raster() +
  facet_wrap(~Food_Web) +
  xlab("Gall diameter (SDs)") +
  ylab("Clutch size (SDs)") +
  scale_fill_viridis(limits = c(AF_range$min, AF_range$max), name = "Absolute fitness")

# Clutch x Preference
AF_plot_clutch.x.preference <- bind_rows(mutate(RF_treatment_clutch.x.preference$absolute_fitness, Food_Web = "Simple"), 
          mutate(RF_control_clutch.x.preference$absolute_fitness, Food_Web = "Complex")) %>%
  ggplot(., aes(x=sc.log1p.female_preference, y=sc.log.clutch_size, fill=average)) +
  geom_raster() +
  facet_wrap(~Food_Web) +
  xlab("Female preference (SDs)") +
  ylab("Clutch size (SDs)") +
  scale_fill_viridis(limits = c(AF_range$min, AF_range$max), name = "Absolute fitness")
```


```{r Figure S2 Multivariate Absolute Fitness Landscapes, include=FALSE, eval=FALSE}
# Get legend
AF_landscape_legend <- get_legend(AF_plot_size.x.preference)

# Format plots
AF_landscape_plots <- plot_grid(
  AF_plot_size.x.clutch + theme(legend.position = "none", axis.title.x = element_blank()),
  AF_plot_clutch.x.preference + theme(legend.position = "none", axis.title.y = element_blank()),
  AF_plot_size.x.preference + theme(legend.position = "none"), 
  nrow=2, align="hv", labels = "AUTO")
AF_landscape_2d <- ggdraw(AF_landscape_plots) + draw_grob(AF_landscape_legend, x = 0.7, y=-0.2)
AF_landscape_2d
#save_plot("AF_landscapes_2d.png", AF_landscape_2d, base_height=6, base_width = 8)
#save_plot("AF_landscapes_2d.pdf", AF_landscape_2d, base_height=6, base_width = 8)
```

