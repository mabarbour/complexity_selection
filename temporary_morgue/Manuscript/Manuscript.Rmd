---
title: Phenotypic evolution is less constrained in complex food webs
author:
  - name: Matthew A. Barbour
    email: matthew.barbour@ieu.uzh.ch
    affiliation: a,b
    footnote: Corresponding Author
  - name: Christopher J. Greyson-Gaito
    affiliation: a,c
  - name: Arezoo Sootodeh
    affiliation: a
  - name: Brendan Locke
    affiliation: d
  - name: Jordi Bascompte
    affiliation: b
address:
  - code: a
    address: University of British Columbia, Department of Zoology, 6270 University Blvd., Vancouver, BC, V6T 1Z4, Canada
  - code: b
    address: University of Zurich, Department of Evolutionary Biology and Environmental Studies, Winterthurerstrasse 190, Zurich, 8057, Switzerland
  - code: c
    address: University of Guelph, Department of Integrative Biology, 50 Stone Rd. East, Guelph, ONT, N1G 2W1, Canada
  - code: d
    address: Humboldt State University, Department of Biological Sciences, 1 Harpst St., Arcata, CA, 95521, USA
abstract: |
  This is the abstract.

  It consists of two paragraphs.

journal: "An awesome journal"
date: "`r Sys.Date()`"
bibliography: mybibfile.bib
output: rticles::elsevier_article
---

```{r setup, include=FALSE}

## Load required libraries ----
library(car)        # for homogeneity of variance test
library(tidyverse)  # for managing data
library(cowplot)    # pretty default ggplots
library(broom)      # for tidying multiple linear models
library(visreg)     # for quick visualizations of model effects
library(viridis)    # for color palette
library(lme4)       # for generalized linear mixed models
library(piecewiseSEM) # for calculating model R-square
library(latex2exp)  # using Latex notation for axes labels

## Load and manage data ----

gall_selection.df <- read_csv("gall_selection_data.csv") %>%
  # convert appropriate variables to characters instead of integers
  mutate(Plant_Position = as.character(Plant_Position),
         Gall_Number = as.character(Gall_Number)) %>%
  unite(Gall_ID, Gall_Number, Gall_Letter, remove = FALSE) %>%
  
  # subset data for analysis
  filter(phenology == "early", Location == "tree",
         platy > 0 | ectos > 0 | pupa > 0) %>%                  # eliminate unknown sources of mortality
  filter(Treatment.focus == "Ectoparasitoid exclusion" & ectos < 1 | Treatment.focus == "Control") %>% # excluding any larva that were parasitized by an ectoparasitoid in the exclusion experiment.
  mutate(Foodweb = ifelse(Treatment.focus=="Control","Complex","Simple"),
         gall_survival = as.numeric(ifelse(pupa > 0, 1, 0)),
         egg_parasitoid = as.numeric(ifelse(platy > 0, 1, 0)),
         sc.Diam = as.numeric(scale(Gall_Height_mm)), 
         sc.log.Clutch = as.numeric(scale(log(gall_individuals))), 
         sc.log1p.Pref = as.numeric(scale(log1p(Density_per_100_shoots)))) 
dim(gall_selection.df)

table(gall_selection.df$Treatment.focus, gall_selection.df$ectos)

## Create separate datasets for quantifying selection gradients ----
#control_df <- gall_selection.df %>%
#  filter(Treatment.focus == "Control") #%>%
  #mutate(sc.gall_size = as.numeric(scale(Gall_Height_mm)), 
  #       sc.clutch_size = as.numeric(scale(gall_individuals)), 
  #       sc.log.clutch_size = as.numeric(scale(log(gall_individuals))), 
  #       sc.female_preference = as.numeric(scale(Density_per_100_shoots)),
  #       sc.log1p.female_preference = as.numeric(scale(log1p(Density_per_100_shoots))))
#dim(control_df)

#treatment_df <- gall_selection.df %>%
#  filter(Treatment.focus == "Ectoparasitoid exclusion", ectos < 1) #%>%  # excluding any larva that were parasitized by an ectoparasitoid in the exclusion experiment.
#dim(treatment_df)
  #mutate(sc.gall_size = as.numeric(scale(Gall_Height_mm)), 
  #       sc.clutch_size = as.numeric(scale(gall_individuals)), 
  #       sc.log.clutch_size = as.numeric(scale(log(gall_individuals))), 
  #       sc.female_preference = as.numeric(scale(Density_per_100_shoots)),
  #       sc.log1p.female_preference = as.numeric(scale(log1p(Density_per_100_shoots))))

#mean(filter(gall_selection.df, Treatment.focus == "Ectoparasitoid exclusion")$ectos) # less than 3% of larva were parasitized by an ectoparasitoid in the exclusion experiment.

## Custom functions to avoid repetitive code ----

## Test for overdispersion
overdisp_fun <- function(model) {
  ## number of variance parameters in 
  ##   an n-by-n variance-covariance matrix
  vpars <- function(m) {
    nrow(m)*(nrow(m)+1)/2
  }
  model.df <- sum(sapply(VarCorr(model),vpars))+length(fixef(model))
  rdf <- nrow(model.frame(model))-model.df
  rp <- residuals(model,type="pearson")
  Pearson.chisq <- sum(rp^2)
  prat <- Pearson.chisq/rdf
  pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE)
  c(chisq=Pearson.chisq,ratio=prat,rdf=rdf,p=pval)
}

## Test for multicollinearity (from: https://jonlefcheck.net/2012/12/28/dealing-with-multicollinearity-using-variance-inflation-factors/)
vif.mer <- function (fit) {
    ## adapted from rms::vif

    v <- vcov(fit)
    nam <- names(fixef(fit))

    ## exclude intercepts
    ns <- sum(1 * (nam == "Intercept" | nam == "(Intercept)"))
    if (ns > 0) {
        v <- v[-(1:ns), -(1:ns), drop = FALSE]
        nam <- nam[-(1:ns)]
    }

    d <- diag(v)^0.5
    v <- diag(solve(v/(d %o% d)))
    names(v) <- nam
    v
}

## Transform logit to probability
inverse_logit <- function(x) exp(x)/(1+exp(x))

## Calculate selection gradients following method of Janzen and Stern 1998, Evolution
Beta_avg_grad <- function(.) {
  mean_fitness <- mean(predict(., type = "response")) 
  brackets <- predict(., type = "response") * (1 - predict(., type="response"))
  mean(brackets) * fixef(.)[-1] / mean_fitness ## need to divide by mean fitness to put on relative fitness scale.
}

## Calculate intensity/opportunity for selection
intensity_of_selection <- function(.) {
  mean_fitness <- mean(predict(., type = "response")) # inverse_logit(fixef(update(., .~. -sc.gall_size -sc.clutch_size -sc.female_preference)))
  relative_fitness <- predict(., type = "response") / mean_fitness 
  var(relative_fitness)
}

## Compute the matrix describing the curvature of the fitness landscape
curvature_fitness.landscape <- function(gammas, # matrix of nonlinear and correlational selection gradients 
                                        betas){ # vector of directional selection gradients
  gammas - betas %*% t(betas)
}

## Bootstrap fitness estimates
bootstrap_fitness <- function(logistic_model, fixed_effects, newdata, bootstraps, intervals=c(0.025,0.975)){
  model_matrix <- model.matrix(formula(fixed_effects), newdata)
  
  # Absolute fitness
  get_absolute_fitness <- function(.) inverse_logit(model_matrix %*% fixef(.))
  
  if(is.null(bootstraps) == FALSE){
    get_bootstraps_absolute_fitness <-bootMer(logistic_model, FUN = get_absolute_fitness, nsim=bootstraps, parallel="multicore", ncpus=32)
  
   get_intervals_absolute_fitness <- apply(get_bootstraps_absolute_fitness$t, 2, function(x) x[order(x)][c(round(bootstraps*intervals[1],0),round(bootstraps*intervals[2],0))])
   
  absolute_fitness_df <- data.frame(newdata, 
                    average = get_absolute_fitness(logistic_model), 
                    lower = get_intervals_absolute_fitness[1, ],
                    upper = get_intervals_absolute_fitness[2, ],
                    t(get_bootstraps_absolute_fitness$t))
  } else {
    absolute_fitness_df <- data.frame(newdata, 
                    average = get_absolute_fitness(logistic_model))
  }
  
  
  # Relative fitness
  get_relative_fitness <- function(.) get_absolute_fitness(.)/mean(get_absolute_fitness(.))
  
  if(is.null(bootstraps) == FALSE){
    get_bootstraps_relative_fitness <-bootMer(logistic_model, FUN = get_relative_fitness, nsim=bootstraps, parallel="multicore", ncpus=32)
  
  get_intervals_relative_fitness <- apply(get_bootstraps_relative_fitness$t, 2, function(x) x[order(x)][c(round(bootstraps*intervals[1],0),round(bootstraps*intervals[2],0))])
    
  relative_fitness_df <- data.frame(newdata, 
                    average = get_relative_fitness(logistic_model), 
                    lower = get_intervals_relative_fitness[1, ],
                    upper = get_intervals_relative_fitness[2, ],
                    t(get_bootstraps_relative_fitness$t))
  } else {
      relative_fitness_df <- data.frame(newdata, 
                    average = get_relative_fitness(logistic_model))
  }
  
  # Organize data
  return(list(absolute_fitness = absolute_fitness_df, relative_fitness = relative_fitness_df))
}

## Number of bootstrap replicates
n_boots_analysis <- 30
n_boots_plots <- 100

```

Introduction
============

The fitness landscape provides a unifying framework for linking the ecology and evolution of populations (Lande 2007; McPeek 2017). The average fitness of a population is a common currency in ecology and evolution, but usually goes by different names in each field. Ecologists refer to it as per-capita population growth rate ($dN/Ndt$), whereas evolutionary biologists call it the natural log of population mean fitness ($ln(\bar W_N)$. In addition to having different names, ecologists and evolutionary biologists have typically focused on different processes that shape the fitness landscape. For example, population ecologists have long studied the effect of a population's density on its per-capita growth rate (i.e. density-dependence, CITE Foundational and current work). In contrast, evolutionary biologists have focused on how the mean trait value of a population influences its average fitness, as this describes the direction and magnitude of natural selection (CITE foundational and current work). Therefore, the fitness landscape describes the joint ecological and evolutionary dynamics of a population in a given environment.

Community ecologists have extended the ecological side of the fitness landscape by incorporating network theory. Species-interaction networks, such as a food web describing who eats whom, provide an explicit representation of the biotic environment as they describe the interdependency of populations within an ecological community. This has provided an effective framework for predicting how changes in the biotic environment (e.g. density of directly and indirectly connected species) will impact population dynamics within species-rich communities. At the same time, evolutionary biologists have long recognized that changes in the biotic environment can alter the dynamics of natural selection. However, the biotic environment in which populations are evolving often remains a bit of a "black box" that's labelled by a general ecological process such as competition, predation, or mutualism. Because of this, it remains difficult to predict how changes in the biotic environment will affect the direction and magnitude of natural selection. Such predictions are urgently needed given the rapid changes in the biotic environment that most populations are currently experiencing throughout the world. 

Here, we integrate species-interaction networks and the fitness landscape to empirically test how changes in the biotic environment -- network of species interactions -- affect the dynamics of natural selection. Specifically, we conducted a field experiment that manipulated the diversity of insect parasitoids that were able to impose selection on an abundant insect herbivore (*Iteomyia salicisverruca*)(Fig. 1). The larva of this herbivore species induce tooth-shaped galls when they feed on the developing leaves of willow trees (*Salix* sp., @Russo2006). These galls provide protection from generalist predators (e.g. ants, spiders), thus the network of interacting parasitoids provides a realistic representation of the biotic environment this insect herbivore is experiencing. Therefore, our manipulation of parasitoid diversity alters the diversity of interactions, or food-web complexity, that this insect herbivore experiences.

Changes in food-web complexity could influence a resource population's fitness landscape in at least two ways. First, if a more diverse community of consumers is more effective at suppressing resource densities (@Ives2005), then this will result in lower mean fitness of the resource population. A reduction in mean fitness, all else equal, will intensify natural selection (@Hunter2018). On the other hand, if consumers impose different selection pressures on resource traits, then more diverse communities could dampen the strength of selection acting on a given trait. This is because a greater diversity in selection pressures is equivalent to greater uncertainty in the selective environment. Thus, a more diverse consumer community may relax the net selection pressures acting on resource traits. Here, we evaluate these hypothesized relationships through an experimental test of how changes in food-web complexity alters the fitness landscape of a resource population.


Materials & Methods
===================

## Study Site

We conducted our study within a four-year old common garden of coastal willow (*Salix hookeriana*) located at Humboldt Bay National Wildlife Refuge (HBNWR) (40&deg;40'53"N, 124&deg;12'4"W) near Loleta, California, USA. This common garden consists of 26 different willow genotypes that were collected from a single population of willows growing around Humboldt Bay. Stem cuttings of each genotype (25 replicates per genotypes) were planted in a completely randomized design in two hectares of a former cattle pasture at HBNWR. Willows in our garden begin flowering in February and reach their peak growth in early August. During this study, willows had reached 5 - 9m in height. Further details on the genotyping and planting of the common garden are available in @Barbour2015. 

## Food-Web Manipulation

We setup our food-web manipulation across 128 plants soon after galls began developing on *S. hookeriana* in early June of 2013. 
These 128 plants came from eight different plant genotypes, spanning the range of trait variation observed in this willow population (@Barbour2015). 
On treatment plants (8 replicates per genotype), we enclosed 14 galled leaves with 10x15cm organza bags (ULINE, Pleasant Prairie, WI, USA) to exclude three parasitoid species that attack during larva development (hereafter larval parasitoids). 
This treatment did not exclude the egg parasitoid *Platygaster* sp. which attacks prior to gall initiation (note that in Cecidomyiid midges, larva initiate gall development CITE). 
On control plants (8 replicates per genotype), we used flagging tape to mark 14 galled leaves per plant (~30 larva), allowing the full suite of parasitoids to attack *Iteomyia*. 
Marking galls with flagging tape ensured that we compared control and treatment galls with similar phenology when we collected galls later in the season. 
Our food-web manipulation altered the average number of trophic interactions that *Iteomyia* was exposed to from BLANK on control plants to BLANK on treatment plants. 
Thus, we refer to galls on control plants as being exposed to a 'complex' food web, whereas galls on treatment plants were exposed to a 'simple' food web.
In late August, we collected marked and bagged galls from each plant, placed them into 30 mL vials and <!-- allowed them to complete development--> kept them in the lab for 4 months at room temperature. 
We then opened galls under a dissecting scope and determined whether larva survived to pupation (our measure of fitness) or were parasitized. Since we were interested in selection imposed by interactions with parasitoids, we restricted our data to larva that either survived to pupation, was parasitized by an egg parasitoid (*Platygaster* sp.), or was parasitized by a larval parasitoid. For the food-web treatment that excluded parasitoids, we further restricted our data by removing any instances of parasitism by a larval parasitoid. This represented less than 3\% of the observations in this food-web treatment and allowed us to focus our inferences of selection on those imposed by the egg parasitoid.  
Together, we had survival estimates for 1,306 larva from 607 galls, 111 plants, and 8 plant genotypes.

## Measuring Gall Traits

We collected data on three different traits that we anticipated would experience selection based on our previous work (@Barbour2016) and others work with Cecidomyiid midges (@Weis1983, @Heath2018). 
First, we measured gall diameter as the size of each gall chamber to the nearest 0.01 mm at its maximum diameter (perpendicular to the direction of plant tissue growth). 
Our previous work has shown that a larger gall diameter provides a refuge for larva from parasitoid attack (@Barbour2016). <!-- Consider whether it is important to make the distinction that diameter was measured at the multi-chambered gall level in previous work -->
Second, we measured the clutch size of adult female midges by counting the number of chambers in each gall (@Weis1983). 
All larva collected from the same multi-chambered gall were scored with the same clutch size. 
Third, we measured female preference for oviposition (egg-laying) sites as the density of larva observed on a plant in an independent survey. Specifically, we randomly sampled five branches per tree and summed the number of individual gall chambers observed. We then converted these counts to a measure of gall density per 100 shoots by counting the number of shoots on the last branch we sampled. All larva collected from the same plant were scored with the same female preference.
The measurement of larval densities on plants in the field is a commonly used index for measuring oviposition preference (@Gripenberg2010); however, caution must be taken in inferring 'preference' as larval densities can be influenced by processes other than preference (@Singer1986). Fortunately, a couple of features of our study system suggest that larval density on a plant may be a good proxy for female preference. For example, since our data comes from a randomized placement of willow genotypes in a common garden, there is no consistent bias in which willow genotypes that females are exposed to while searching for oviposition sites. Also, egg predation is a minor source of mortality for galling insects in general (@Hawkins1997), thus we do not expect any prior egg predation to bias our estimates of observed larval densities. 

### Quantifying the Fitness Landscape

To characterize the shape of the fitness landscape in simple and complex food webs, we first used a generalized linear mixed model to quantify selection surfaces on individual traits. We used a binomial error distribution (logit link function) since larval survival (0 or 1) was our response variable and measure of fitness. We specified linear and quadratic terms for each gall trait as well as linear interaction terms between each gall trait as fixed effects in the statistical models. To account for the correlated structure of clutch size (gall level) and female preference (plant level) as well as any independent effects of willow genotype on larval survival, we specified gall ID nested within plant ID nested within plant genotype as random effects. Since we were interested in characterizing the fitness landscape -- the relationship between mean trait values and population mean fitness -- we assumed the mean value of our random effects (i.e. setting them to zero) to estimate selection gradients. Also, the fitness landscape assumes that traits distributions are multivariate normal. To better meet this assumption, we log-transformed clutch size and added a small constant (1) to female preference before log transforming, since our surveys occassionaly estimated zero larval densities. We then scaled all phenotypic traits to mean=0 and SD=1 in order to calculate standardized selection gradients that were comparable across traits and with other studies of natural selection. We used the method of @Janzen1998 to calculate directional ($\beta_{z_i}$), quadratic ($\gamma_{z_i,z_i}$), and correlational ($\gamma_{z_i,z_j}$) selection gradients and used parametric bootstrapping (1000 replicates) to calculate their 95% confidence intervals (@Bolker2009). We estimated directional selection gradients by excluding quadratic terms and statistical interactions in the model. Note that for visualizing the fitness landscape we restrict trait axes to $\pm 1$ SD of the mean trait value as this contains the majority of the trait distribution that selection is acting on.

Rather than imposing selection, parasitoids may themselves influence the expression of herbivore traits. Any influence on trait expression would bias selection gradients acting on those traits. In our system, it was plausible that parasitoids may influence chamber growth by promoting larval feeding (cite), speeding up larva development (cite), or killing larva before they complete their development (cite). Therefore, our estimates of selection on chamber diameter may be positively or negatively biased. To estimate this bias, we subset our data to only include galls where there was variation in larval survival (1 > survival > 0) within the same gall. We then calculated "apparent" selection differentials for each gall by comparing the average chamber diameter of all larva (before "selection") to the average chamber diameter of surviving larva and analyzed separate one-sample t-tests for each food-web treatment. This analysis is based on the assumption that larva within each gall come from the same clutch and therefore should have similar chamber diameters regardless of whether they are parasitized. In general, we found that our estimates of directional selection on chamber diameter were positively biased (Appendix). In other words, our analyses were overestimating the magnitude of selection acting on gall diameter. Therefore, we adjusted our estimates of directional selection on chamber diameter ($\beta_{diam}$) by subtracting the biased selection differentials. Note that selection gradients and selection differentials for chamber diameter were virtually the same (Appendix). 

### Quantifying Selective Constraints

The strength and pattern of selective constraints can be measured as the slope and curvature of the fitness landscape (Arnold 1992).

We can translate selection surfaces of individuals to the fitness landscape of a population

To characterize the net effects of food-web complexity on the slope and curvature of *Iteomyia*'s fitness landscape, we took advantage of existing theory that links selection surfaces of individuals to the fitness landscape of the population (Phillips & Arnold 1998, Arnold 2003). Specifically, the slope of the fitness landscape corresponds to the column vector of directional selection gradients:

```{r LATEX NEED TO CHECK two, eval=FALSE, include=FALSE}
$$\text{Slope} = \beta = \begin{pmatrix} \beta_{diam} \\ \beta_{clutch} \\ \beta_{pref} \end{pmatrix} $$
whereas the curvature of the fitness landscape is a function of the directional, nonlinear, and correlational selection gradients: 
$$\text{Curvature} = \gamma - \beta \beta^T$$
where \gamma represents the matrix of nonlinear and correlational selection gradients:
$$\gamma = \begin{pmatrix} \gamma_{diam,diam}&& \\ \gamma_{diam,clutch}&\gamma_{clutch,clutch}& \\ \gamma_{diam,pref} & \gamma_{clutch,pref} &\gamma_{pref,pref} \end{pmatrix}$$
```


Note that we ommitted the upper triangle of the matrix for clarity since it is simply the reflection of the lower triangle. Assuming that there is additive genetic variance and covariance between these traits under selection, then the slope and curvature of the fitness landscape give insight to how the population's mean trait value will change in the next generation as well as how additive genetic variance and covariance changes within a generation.

While making quantitative predictions about trait evolution requires knowledge of the additive genetic variance and covariance of these traits, the slope and curvature of the fitness landscape still give qualitative insight to the evolutionary trajectory of a population. 

If we assume that there is additive genetic variance and covariance between these traits, then the matrix describing the curvature of the fitness landscape gives qualitative insight to the selective constraints acting on the population. For example, the diagonal of the curvature matrix dictates (qualitatively) whether the additive genetic variance in each trait will increase ($+$), decrease ($-$), or stay the same ($0$). Similarly, the off-diagonal of the curvature matrix dictates whether selection favors trait integration (positive covariance), a tradeoff (negative covariance), or no change in genetic covariance. In other words, we can get qualitative insight to how food-web complexity influences constraints on the fitness landscape by counting the number of negative sign values along the diagnoal (which imply a decrease in additive genetic variance) and the number of positive or negative signs along the off diagonal (which imply changes in additive genetic covariance that lead to either trait integration or tradeoffs).  

All analyses and visualizations were conducted in R (@R2018). 

I need to go back to estimate a common alpha coefficient if the treatments do not differ from each other.

```{r Effects of food-web complexity on absolute fitness, cache=TRUE, include=FALSE}

## FIT GLMMs ---

# Null Model
null_glmer <- glmer(gall_survival ~ 1 +
                      (1|Genotype/Plant_Position/Gall_Number),
                    data = gall_selection.df,
                    family = binomial(link = logit), control=glmerControl(optimizer = "bobyqa"))

# Model assuming no effect of food-web treatment
trait_glmer <- glmer(gall_survival ~ (sc.Diam + sc.log.Clutch + sc.log1p.Pref)^2 + 
                      I(sc.Diam^2) + I(sc.log.Clutch^2) + I(sc.log1p.Pref^2) +
                      (1|Genotype/Plant_Position/Gall_Number),
                    data = gall_selection.df,
                    family = binomial(link = logit), control=glmerControl(optimizer = "bobyqa"))

# Model allowing for an effect of food-web treatment
foodweb_glmer <- glmer(gall_survival ~ Foodweb*(sc.Diam + sc.log.Clutch + sc.log1p.Pref)^2 +
                         Foodweb*(I(sc.Diam^2) + I(sc.log.Clutch^2) + I(sc.log1p.Pref^2)) +
                         (1|Genotype/Plant_Position/Gall_Number),
                       data = gall_selection.df,
                       family = binomial(link = logit), control=glmerControl(optimizer = "bobyqa"))

# Model excluding quadratic and trait:trait interactions. This is necessary for accurately estimating directional selection gradients (Betas, Lande and Arnold 1983)
betas_glmer <- glmer(gall_survival ~ Foodweb*(sc.Diam + sc.log.Clutch + sc.log1p.Pref) +
                         (1|Genotype/Plant_Position/Gall_Number),
                       data = gall_selection.df,
                       family = binomial(link = logit), control=glmerControl(optimizer = "bobyqa"))

## STATISTICAL TESTS ----

# There is clear evidence that the traits we have measured influence larva survival
anova(null_glmer, trait_glmer, test="Chisq")

# There is also clear evidence that our food-web treatment altered natural selection
foodweb_test <- tidy(anova(trait_glmer, foodweb_glmer, test="Chisq"))
rsquared(list(trait_glmer, foodweb_glmer), method="delta") # 3-4% increase in amount of variance explained when including effect of food-web treatment

## EVALUATING MODEL ASSUMPTIONS ---

# There is no evidence of overdispersion
overdisp_fun(foodweb_glmer)

# There are no clear patterns in the distribution of the residuals (= good)
visreg(foodweb_glmer)
```

```{r Get Selection Gradients for GLMER, include=FALSE}

## METHOD OF JANZEN AND STERN 1998 ----

# Estimate mean fitness and mean "brackets" for each food-web treatment (see Janzen and Stern 1998 equation 4 for details about "brackets")
complex_predict <- predict(foodweb_glmer, newdata=filter(gall_selection.df, Foodweb=="Complex"), type="response")
complex_mean_brackets <- mean(complex_predict * (1 - complex_predict))
complex_mean_fitness <- mean(complex_predict)

simple_predict <- predict(foodweb_glmer, newdata=filter(gall_selection.df, Foodweb=="Simple"), type="response")
simple_mean_brackets <- mean(simple_predict * (1 - simple_predict))
simple_mean_fitness <- mean(simple_predict)

# Double-check that using the Beta-only model doesn't influence estimes of mean "brackets" and mean fitness. Using Complex food web as an example, but it doesn't matter 
alt_predict <- predict(betas_glmer, newdata=filter(gall_selection.df, Foodweb=="Complex"), type="response")
alt_mean_brackets <- mean(alt_predict * (1 - alt_predict))
alt_mean_fitness <- mean(alt_predict)
test_mean_brackets <- complex_mean_brackets
test_mean_fitness <- complex_mean_fitness
test_mean_brackets - alt_mean_brackets # virtually the same
test_mean_fitness - alt_mean_fitness # virtually the same

# Tidy data for beta terms
foodweb_tidy_betas <- tidy(betas_glmer, conf.int=T) %>%
  filter(term %in% c("(Intercept)","FoodwebSimple","sc.Diam","sc.log.Clutch","sc.log1p.Pref",
                     "FoodwebSimple:sc.Diam","FoodwebSimple:sc.log.Clutch","FoodwebSimple:sc.log1p.Pref")) %>%
  mutate(Foodweb = c("Complex","Simple",rep("Complex",3),rep("Simple",3)),
         Selection_form = c(NA,NA,rep("Directional",6)),
         Multiplier = rep(1,8))

# Tidy data for gamma terms. Note that we multiply quadratic (nonlinear) selection coefficients by 2 so they are on the same scale as other coefficients (detailed explanation in Stinchcombe et al. 2008)
foodweb_tidy_gammas <- tidy(foodweb_glmer, conf.int=T) %>%
  filter(term %in% c("I(sc.Diam^2)","I(sc.log.Clutch^2)","I(sc.log1p.Pref^2)",
                     "sc.Diam:sc.log.Clutch","sc.Diam:sc.log1p.Pref","sc.log.Clutch:sc.log1p.Pref",
                     "FoodwebSimple:I(sc.Diam^2)","FoodwebSimple:I(sc.log.Clutch^2)","FoodwebSimple:I(sc.log1p.Pref^2)",
                     "FoodwebSimple:sc.Diam:sc.log.Clutch","FoodwebSimple:sc.Diam:sc.log1p.Pref","FoodwebSimple:sc.log.Clutch:sc.log1p.Pref")) %>%
  mutate(Foodweb = c(rep("Complex",6),rep("Simple",6)),
         Selection_form = c(rep("Nonlinear",3),rep("Correlational",3),rep("Nonlinear",3),rep("Correlational",3)),
         Multiplier = c(rep(2,3),rep(1,3),rep(2,3),rep(1,3)))

# Combine and tidy the regression (alpha) coefficients
get_alphas <- bind_rows(foodweb_tidy_betas, foodweb_tidy_gammas) %>% 
  mutate(alpha = estimate, alpha_2.5 = conf.low, alpha_97.5 = conf.high, P = p.value) %>%
  select(term, Foodweb, alpha, alpha_2.5, alpha_97.5, P, Selection_form, Multiplier)

complex_alphas <- filter(get_alphas, Foodweb == "Complex"); complex_alphas
simple_alphas <- filter(get_alphas, Foodweb == "Simple"); simple_alphas

coefs_gradients <- data.frame(Variable = complex_alphas$term, 
           a_complex = complex_alphas$alpha,
           a_complex_2.5 = complex_alphas$alpha_2.5,
           a_complex_97.5 = complex_alphas$alpha_97.5,
           a_simple = complex_alphas$alpha + simple_alphas$alpha,        # the baseline is the coefficient in the complex food web, therefore we simply add the corresponding coefficients from the simple food web to get the coefficients on the same scale as the complex web
           a_simple_2.5 = complex_alphas$alpha + simple_alphas$alpha_2.5, # same addition process for confidence intervals
           a_simple_97.5 = complex_alphas$alpha + simple_alphas$alpha_97.5,
           Selection_form = complex_alphas$Selection_form,                # doesn't matter whether simple_ or complex_alphas is chosen for Selection_form or Multiplier
           Multiplier = complex_alphas$Multiplier) %>%                     
  mutate(b_complex = complex_mean_brackets * a_complex / complex_mean_fitness * Multiplier,
         b_complex_2.5 = complex_mean_brackets * a_complex_2.5 / complex_mean_fitness * Multiplier,
         b_complex_97.5 = complex_mean_brackets * a_complex_97.5 / complex_mean_fitness * Multiplier,
         b_simple = simple_mean_brackets * a_simple / simple_mean_fitness * Multiplier,
         b_simple_2.5 = simple_mean_brackets * a_simple_2.5 / simple_mean_fitness * Multiplier,
         b_simple_97.5 = simple_mean_brackets * a_simple_97.5 / simple_mean_fitness * Multiplier) 


bind_rows(mutate(select(coefs_gradients, Variable, a=a_complex, a_2.5=a_complex_2.5, a_97.5=a_complex_97.5, Selection_form), Foodweb = "Complex"),
          mutate(select(coefs_gradients, Variable, a=a_simple, a_2.5=a_simple_2.5, a_97.5=a_simple_97.5, Selection_form), Foodweb = "Simple")) %>%
  filter(Variable != "(Intercept)") %>%
  ggplot(., aes(x = Variable, fill=Foodweb, color=Foodweb)) +
  geom_point(aes(y=a), position = position_dodge(width=0.5)) +
  geom_errorbar(aes(ymax = a_97.5, ymin = a_2.5), position = position_dodge(width=0.5)) +
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  facet_wrap(~Selection_form, nrow=2, scales = "free_y") +
  ylab("Regression coefficient")

## Modify to be directional, nonlinear, then correlational with legend in 4th area.
## Modify so that axes have gamma and beta with the trait as a subscript
bind_rows(mutate(select(coefs_gradients, Variable, b=b_complex, b_2.5=b_complex_2.5, b_97.5=b_complex_97.5, Selection_form), Foodweb = "Complex"),
          mutate(select(coefs_gradients, Variable, b=b_simple, b_2.5=b_simple_2.5, b_97.5=b_simple_97.5, Selection_form), Foodweb = "Simple")) %>%
  filter(Variable != "(Intercept)") %>%
  ggplot(., aes(x = Variable, fill=Foodweb, color=Foodweb)) +
  geom_point(aes(y=b), position = position_dodge(width=0.5)) +
  geom_errorbar(aes(ymax = b_97.5, ymin = b_2.5), position = position_dodge(width=0.5)) +
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  facet_wrap(~Selection_form, nrow=2, scales = "free_y") +
  ylab("Selection gradient")
     

```

```{r Parametric Bootstrapping of Regression Coefficients and Selection Gradients, cache=TRUE, include=FALSE}

## DUPLICATE ABOVE EXCEPT MODIFY FOR BOOTMER

## METHOD OF JANZEN AND STERN 1998 ----

# Estimate mean fitness and mean "brackets" for each food-web treatment (see Janzen and Stern 1998 equation 4 for details about "brackets")
complex_predict <- predict(foodweb_glmer, newdata=filter(gall_selection.df, Foodweb=="Complex"), type="response")
complex_mean_brackets <- mean(complex_predict * (1 - complex_predict))
complex_mean_fitness <- mean(complex_predict)

simple_predict <- predict(foodweb_glmer, newdata=filter(gall_selection.df, Foodweb=="Simple"), type="response")
simple_mean_brackets <- mean(simple_predict * (1 - simple_predict))
simple_mean_fitness <- mean(simple_predict)

# Double-check that using the Beta-only model doesn't influence estimes of mean "brackets" and mean fitness. Using Complex food web as an example, but it doesn't matter 
alt_predict <- predict(betas_glmer, newdata=filter(gall_selection.df, Foodweb=="Complex"), type="response")
alt_mean_brackets <- mean(alt_predict * (1 - alt_predict))
alt_mean_fitness <- mean(alt_predict)
test_mean_brackets <- complex_mean_brackets
test_mean_fitness <- complex_mean_fitness
test_mean_brackets - alt_mean_brackets # virtually the same
test_mean_fitness - alt_mean_fitness # virtually the same

# Tidy data for beta terms
foodweb_tidy_betas <- tidy(bootMer(betas_glmer, FUN = fixef, nsim=n_boots_analysis, parallel="multicore", ncpus=32), conf.int=T) %>%
  filter(term %in% c("(Intercept)","FoodwebSimple","sc.Diam","sc.log.Clutch","sc.log1p.Pref",
                     "FoodwebSimple:sc.Diam","FoodwebSimple:sc.log.Clutch","FoodwebSimple:sc.log1p.Pref")) %>%
  mutate(Foodweb = c("Complex","Simple",rep("Complex",3),rep("Simple",3)),
         Selection_form = c(NA,NA,rep("Directional",6)),
         Multiplier = rep(1,8))

# Tidy data for gamma terms. Note that we multiply quadratic (nonlinear) selection coefficients by 2 so they are on the same scale as other coefficients (detailed explanation in Stinchcombe et al. 2008)
foodweb_tidy_gammas <- tidy(bootMer(foodweb_glmer, FUN = fixef, nsim=n_boots_analysis, parallel="multicore", ncpus=32), conf.int=T) %>%
  filter(term %in% c("I(sc.Diam^2)","I(sc.log.Clutch^2)","I(sc.log1p.Pref^2)",
                     "sc.Diam:sc.log.Clutch","sc.Diam:sc.log1p.Pref","sc.log.Clutch:sc.log1p.Pref",
                     "FoodwebSimple:I(sc.Diam^2)","FoodwebSimple:I(sc.log.Clutch^2)","FoodwebSimple:I(sc.log1p.Pref^2)",
                     "FoodwebSimple:sc.Diam:sc.log.Clutch","FoodwebSimple:sc.Diam:sc.log1p.Pref","FoodwebSimple:sc.log.Clutch:sc.log1p.Pref")) %>%
  mutate(Foodweb = c(rep("Complex",6),rep("Simple",6)),
         Selection_form = c(rep("Nonlinear",3),rep("Correlational",3),rep("Nonlinear",3),rep("Correlational",3)),
         Multiplier = c(rep(2,3),rep(1,3),rep(2,3),rep(1,3)))

# Combine and tidy the regression (alpha) coefficients
get_alphas <- bind_rows(foodweb_tidy_betas, foodweb_tidy_gammas) %>% 
  mutate(alpha = statistic, alpha_2.5 = conf.low, alpha_97.5 = conf.high, P = ifelse(conf.low*conf.high > 0, "<0.05","NS")) %>% # change 'alpha = estimate' to 'alpha = statistic' for bootstrap. Multiply confidence intervals to determine whether the cofficient is signficantly different from zero.
  select(term, Foodweb, alpha, alpha_2.5, alpha_97.5, P, Selection_form, Multiplier)

complex_alphas <- filter(get_alphas, Foodweb == "Complex"); complex_alphas
simple_alphas <- filter(get_alphas, Foodweb == "Simple"); simple_alphas

coefs_gradients <- data.frame(Variable = complex_alphas$term, 
           a_complex = complex_alphas$alpha,
           a_complex_2.5 = complex_alphas$alpha_2.5,
           a_complex_97.5 = complex_alphas$alpha_97.5,
           a_simple = complex_alphas$alpha + simple_alphas$alpha,        # the baseline is the coefficient in the complex food web, therefore we simply add the corresponding coefficients from the simple food web to get the coefficients on the same scale as the complex web
           a_simple_2.5 = complex_alphas$alpha + simple_alphas$alpha_2.5, # same addition process for confidence intervals
           a_simple_97.5 = complex_alphas$alpha + simple_alphas$alpha_97.5,
           Selection_form = complex_alphas$Selection_form,                # doesn't matter whether simple_ or complex_alphas is chosen for Selection_form or Multiplier
           Multiplier = complex_alphas$Multiplier) %>%                     
  mutate(b_complex = complex_mean_brackets * a_complex / complex_mean_fitness * Multiplier,
         b_complex_2.5 = complex_mean_brackets * a_complex_2.5 / complex_mean_fitness * Multiplier,
         b_complex_97.5 = complex_mean_brackets * a_complex_97.5 / complex_mean_fitness * Multiplier,
         b_simple = simple_mean_brackets * a_simple / simple_mean_fitness * Multiplier,
         b_simple_2.5 = simple_mean_brackets * a_simple_2.5 / simple_mean_fitness * Multiplier,
         b_simple_97.5 = simple_mean_brackets * a_simple_97.5 / simple_mean_fitness * Multiplier) 


bind_rows(mutate(select(coefs_gradients, Variable, a=a_complex, a_2.5=a_complex_2.5, a_97.5=a_complex_97.5, Selection_form), Foodweb = "Complex"),
          mutate(select(coefs_gradients, Variable, a=a_simple, a_2.5=a_simple_2.5, a_97.5=a_simple_97.5, Selection_form), Foodweb = "Simple")) %>%
  filter(Variable != "(Intercept)") %>%
  ggplot(., aes(x = Variable, fill=Foodweb, color=Foodweb)) +
  geom_point(aes(y=a), position = position_dodge(width=0.5)) +
  geom_errorbar(aes(ymax = a_97.5, ymin = a_2.5), position = position_dodge(width=0.5)) +
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  facet_wrap(~Selection_form, nrow=2, scales = "free_y") +
  ylab("Regression coefficient")

## Modify to be directional, nonlinear, then correlational with legend in 4th area.
## Modify so that axes have gamma and beta with the trait as a subscript
bind_rows(mutate(select(coefs_gradients, Variable, b=b_complex, b_2.5=b_complex_2.5, b_97.5=b_complex_97.5, Selection_form), Foodweb = "Complex"),
          mutate(select(coefs_gradients, Variable, b=b_simple, b_2.5=b_simple_2.5, b_97.5=b_simple_97.5, Selection_form), Foodweb = "Simple")) %>%
  filter(Variable != "(Intercept)") %>%
  ggplot(., aes(x = Variable, fill=Foodweb, color=Foodweb)) +
  geom_point(aes(y=b), position = position_dodge(width=0.5)) +
  geom_errorbar(aes(ymax = b_97.5, ymin = b_2.5), position = position_dodge(width=0.5)) +
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  facet_wrap(~Selection_form, nrow=2, scales = "free_y") +
  ylab("Selection gradient")
     

```


References {#references .unnumbered}
==========
