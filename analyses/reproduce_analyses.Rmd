---
title: "Reproducing Analyses for Phenotypic evolution is less constrained in complex
  food webs"
author: "Matthew A. Barbour"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: architect
    highlight: github
---

```{r setup, include=FALSE}

## Load required libraries ----
library(evolqg) # need to load before dplyr
library(car)        # for homogeneity of variance test
library(tidyverse)  # for managing data
library(cowplot)    # pretty default ggplots
library(broom)      # for tidying multiple linear models
library(visreg)     # for quick visualizations of model effects
library(viridis)    # for color palette
library(lme4)       # for generalized linear mixed models
library(piecewiseSEM) # for calculating model R-square
library(latex2exp)  # using Latex notation for axes labels
library(kableExtra)
library(stringr)
library(MVN)        # assessing multivariate normality assumption

## Load and manage data ----

gall_selection.df <- read_csv("../data/gall_selection_data.csv") %>%
  # convert appropriate variables to characters instead of integers
  mutate(Plant_Position = as.character(Plant_Position),
         Gall_Number = as.character(Gall_Number)) %>%
  unite(Gall_ID, Gall_Number, Gall_Letter, remove = FALSE) %>%
  
  # subset data for analysis
  filter(phenology == "early", Location == "tree",
         platy > 0 | ectos > 0 | pupa > 0) %>%                  # eliminate unknown sources of mortality
  filter(Treatment.focus == "Ectoparasitoid exclusion" & ectos < 1 | Treatment.focus == "Control") %>% # excluding any larva that were parasitized by an ectoparasitoid in the exclusion experiment.
  mutate(Foodweb = ifelse(Treatment.focus=="Control","Complex","Simple"),
         gall_survival = as.numeric(ifelse(pupa > 0, 1, 0)),
         egg_parasitoid = as.numeric(ifelse(platy > 0, 1, 0)),
         sc.Diam = as.numeric(scale(Gall_Height_mm)), 
         sc.log.Clutch = as.numeric(scale(log(gall_individuals))), 
         sc.sqrt.Pref = as.numeric(scale(sqrt(Density_per_100_shoots)))) 

## Custom functions to avoid repetitive code ----

## Transform logit to probability
inverse_logit <- function(x) exp(x)/(1+exp(x))

## Bootstrap fitness estimates
bootstrap_fitness <- function(logistic_model, #fixed_effects, 
                              newdata, bootstraps, intervals=c(0.025,0.975)){
  #model_matrix <- model.matrix(formula(fixed_effects), newdata)
  
  # Absolute fitness
  get_absolute_fitness <- function(.) predict(., newdata=newdata, type="response", re.form=~0) #inverse_logit(model_matrix %*% fixef(.))
  
  if(is.null(bootstraps) == FALSE){
    get_bootstraps_absolute_fitness <-bootMer(logistic_model, FUN = get_absolute_fitness, nsim=bootstraps, parallel="multicore", ncpus=32)
  
   get_intervals_absolute_fitness <- apply(get_bootstraps_absolute_fitness$t, 2, function(x) x[order(x)][c(round(bootstraps*intervals[1],0),round(bootstraps*intervals[2],0))])
   
  absolute_fitness_df <- data.frame(newdata, 
                    average = get_absolute_fitness(logistic_model), 
                    lower = get_intervals_absolute_fitness[1, ],
                    upper = get_intervals_absolute_fitness[2, ],
                    t(get_bootstraps_absolute_fitness$t))
  } else {
    absolute_fitness_df <- data.frame(newdata, 
                    average = get_absolute_fitness(logistic_model))
  }
  
  
  # Relative fitness
  get_relative_fitness <- function(.) get_absolute_fitness(.)/mean(get_absolute_fitness(.))
  
  if(is.null(bootstraps) == FALSE){
    get_bootstraps_relative_fitness <-bootMer(logistic_model, FUN = get_relative_fitness, nsim=bootstraps, parallel="multicore", ncpus=32)
  
  get_intervals_relative_fitness <- apply(get_bootstraps_relative_fitness$t, 2, function(x) x[order(x)][c(round(bootstraps*intervals[1],0),round(bootstraps*intervals[2],0))])
    
  relative_fitness_df <- data.frame(newdata, 
                    average = get_relative_fitness(logistic_model), 
                    lower = get_intervals_relative_fitness[1, ],
                    upper = get_intervals_relative_fitness[2, ],
                    t(get_bootstraps_relative_fitness$t))
  } else {
      relative_fitness_df <- data.frame(newdata, 
                    average = get_relative_fitness(logistic_model))
  }
  
  # Organize data
  return(list(absolute_fitness = absolute_fitness_df, relative_fitness = relative_fitness_df))
}


## Number of bootstrap replicates
n_boots_analysis <- 1000
n_boots_plots <- 100


## Predicting evolutionary dynamics 
evolutionary_dynamics <- function (betas,    # one-column matrix of directional selection gradients
                                   gammas,   # matrix of nonlinear selection gradients
                                   G_0,      # initial G-matrix
                                   z_0,      # one-column matrix of initial trait values
                                   t) {       # evolutionary time steps 
    # Equation 2 from Phillips and Arnold 1989, Evolution
    G <- rep(list(G_0), t) 
    for (i in 1:t) G[[i + 1]] <- {
      G[[i]] + G[[i]] %*% (gammas - betas %*% t(betas)) %*% G[[i]] # may need to add mutation/recombination matrix (see Phillips and Arnold 1989)
    }
    
    # Equation 1 from Phillips and Arnold 1989, Evolution
    z <- rep(list(z_0), t) 
    for (i in 1:t) z[[i + 1]] <- {
        z[[i]] + G[[i]] %*% betas
    }
    return(list(z=z,G=G))
}

## Number of evolutionary time steps for simulation
n_evo_sims <- 200 # 1000

## Tidy up evolutionary simulations
tidy_evo_sims <- function(evo_sims) {
  tidy_sim <- data.frame(matrix(unlist(evo_sims$z), ncol=3, byrow=T)) %>% 
    transmute(Time=1:length(evo_sims$z), Diam=round(X1,2), Clutch=round(X2,2), Pref=round(X3,2)) %>%
    filter(Diam < 1, Diam > -1, Clutch < 1, Clutch > -1, Pref < 1, Pref > -1) 
  
  return(tidy_sim)
}

## Color palette

# order -> orange, light blue, green, yellow, dark blue, red, pink
cbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7", "#000000", "#999999")
complex_color <- cbPalette[6] # 1
simple_color <- cbPalette[5] # 2
treatment_colors <- c(complex_color, simple_color)

```

# Evaluating assumption of multivariate normality

We used graphical checks to evaluate whether our transformations of traits resulted in a multivariate normal distribution. As you can see from the multivariate qq-plot, it seems reasonable that our data approximates a multivariate normal distribution. Of course, statistical tests suggest otherwise. But as an example of how silly these tests can be, look at the distribution of gall diameter. It is the closest ecological variable I've ever seen that is normally distributed, yet a Shapiro-Wilks test says otherwise. 

```{r MVN Assumption, echo=FALSE}

mvn_assumption <- mvn(select(gall_selection.df, sc.Diam, sc.log.Clutch, sc.sqrt.Pref), multivariatePlot = "qq", univariatePlot = "histogram")

# mvn(select(gall_selection.df, sc.Diam, sc.log.Clutch, sc.sqrt.Pref), multivariatePlot = "qq")

mvn_assumption$univariateNormality[1, ]
```


# Effect of Food-Web Treatment on Larval Survival

First we fit the full generalized linear mixed model to our data. This will enable us to evaluate whether there is any evidence that food-web treatment alters nonlinear selection on gall phenotypic variation. Note that we are not interested in directional selection yet, because we need to remove the nonlinear terms to evaluate its effects ([Lande and Arnold 1983](https://doi.org/10.1111/j.1558-5646.1983.tb00236.x)).

```{r Model 1, cache=TRUE}
model_1 <- glmer(
  gall_survival ~ Foodweb + sc.Diam + sc.log.Clutch + sc.sqrt.Pref +
    Foodweb:(sc.Diam + sc.log.Clutch + sc.sqrt.Pref) +
    I(sc.Diam^2) + I(sc.log.Clutch^2) + I(sc.sqrt.Pref^2) +
    Foodweb:(I(sc.Diam^2) + I(sc.log.Clutch^2) + I(sc.sqrt.Pref^2)) +
    sc.Diam:sc.log.Clutch + sc.Diam:sc.sqrt.Pref + sc.log.Clutch:sc.sqrt.Pref +
    Foodweb:(sc.Diam:sc.log.Clutch + sc.Diam:sc.sqrt.Pref + sc.log.Clutch:sc.sqrt.Pref) +
    (1|Genotype/Plant_Position/Gall_Number),
  data = gall_selection.df,
  family = binomial(link = logit), control=glmerControl(optimizer = "bobyqa"))
```

We use parametric bootstrapping (n=`r n_boots_analysis`) to evaluate the statistical significance of the effect of food-web treatment on nonlinear terms (i.e. Foodweb:trait~i~^2^ or Foodweb:trait~i~:trait~j~). Food-web treatment does influence the quadratic effect of of female preference on larva survival. None of the other terms statistically differ from zero.

```{r Bootstrap Model 1, cache=TRUE, include=FALSE}
boot_model_1 <- bootMer(model_1, FUN = fixef, nsim=n_boots_analysis, parallel="multicore", ncpus=32)

tidy_model_1 <- tidy(model_1, conf.int=T) %>% #tidy(boot_model_1, conf.int=T) %>% 
  # filter terms that only matter for this analysis
  filter(term %in% c("I(sc.Diam^2)","I(sc.log.Clutch^2)","I(sc.sqrt.Pref^2)",
                     "sc.Diam:sc.log.Clutch","sc.Diam:sc.sqrt.Pref","sc.log.Clutch:sc.sqrt.Pref",
                     "FoodwebSimple:I(sc.Diam^2)","FoodwebSimple:I(sc.log.Clutch^2)","FoodwebSimple:I(sc.sqrt.Pref^2)",
                     "FoodwebSimple:sc.Diam:sc.log.Clutch","FoodwebSimple:sc.Diam:sc.sqrt.Pref","FoodwebSimple:sc.log.Clutch:sc.sqrt.Pref")) 
```

```{r Plot Effect of Food-web on Nonlinear Terms in Model 1, echo=FALSE}
plot_model_1 <- tidy_model_1 %>%
  mutate(Food_web = ifelse(grepl("FoodwebSimple", .$term)==TRUE,"Simple","Complex")) %>%
  filter(Food_web == "Simple")

plot_model_1$term_plot <- factor(plot_model_1$term,
                                levels=c("FoodwebSimple:I(sc.Diam^2)","FoodwebSimple:I(sc.log.Clutch^2)","FoodwebSimple:I(sc.sqrt.Pref^2)","FoodwebSimple:sc.Diam:sc.log.Clutch","FoodwebSimple:sc.Diam:sc.sqrt.Pref","FoodwebSimple:sc.log.Clutch:sc.sqrt.Pref"),
                                ordered=TRUE)

plot_model_1 %>%
  ggplot(., aes(x=term_plot)) +
  geom_linerange(aes(ymin=conf.low, ymax=conf.high)) +
  geom_point(aes(y=estimate), shape=21, size=3, fill="grey") + # y=statistic for bootstrap
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  scale_x_discrete(name="", limits = rev(levels(plot_model_1$term_plot))) +
  ylab("Coefficient (logit scale)")
```

Therefore, we are going to drop them from the model. Note that we are still fitting the full curvature of the fitness landscape, but that we aren't allowing some aspects of it to vary between food-web treatments (since there was no evidence for it)

```{r Model 2, cache=TRUE}

# Remove non-signficiant effect of food-web treatment on quadratic and trait_i:trait_j interactions

model_2 <- update(model_1, 
                  .~. -Foodweb:I(sc.Diam^2) -Foodweb:I(sc.log.Clutch^2) -Foodweb:I(sc.sqrt.Pref^2)
                  -Foodweb:sc.Diam:sc.log.Clutch -Foodweb:sc.Diam:sc.sqrt.Pref -Foodweb:sc.log.Clutch:sc.sqrt.Pref)
```

```{r Bootstrap Model 2, cache=TRUE, include=FALSE}

boot_model_2 <- bootMer(model_2, FUN = fixef, nsim=n_boots_analysis, parallel="multicore", ncpus=32)

tidy_model_2 <- tidy(model_2, conf.int=T) %>% # tidy(boot_model_2, conf.int=T) %>% 
  filter(term %in% c("I(sc.Diam^2)","I(sc.log.Clutch^2)","I(sc.sqrt.Pref^2)",
                     "sc.Diam:sc.log.Clutch","sc.Diam:sc.sqrt.Pref","sc.log.Clutch:sc.sqrt.Pref",
                     "FoodwebSimple:I(sc.sqrt.Pref^2)")) 
```

This represents our nonlinear regression coefficients.

```{r Plot Nonlinear Terms, echo=FALSE}
tidy_model_2$term_plot <- factor(tidy_model_2$term,
                            levels=c("I(sc.Diam^2)","I(sc.log.Clutch^2)","I(sc.sqrt.Pref^2)","sc.Diam:sc.log.Clutch","sc.Diam:sc.sqrt.Pref","sc.log.Clutch:sc.sqrt.Pref"),
                            ordered = TRUE)

tidy_model_2 %>%
  ggplot(., aes(x=term_plot)) +
  geom_linerange(aes(ymin=conf.low, ymax=conf.high)) +
  geom_point(aes(y=estimate), fill="grey", shape=21, size=3) + # y=statistic
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  scale_x_discrete(name="", limits = rev(levels(tidy_model_2$term_plot))) +
  ylab("Coefficient (logit scale)")
```

Note that the non-overlapping 95% CI for *FoodwebSimple:I(sc.sqrt.Pref^2)* indicates that food-web treatment alters quadractic selection on female preference; however, this coefficient is not useful for actually calculating the selection gradient. To do this, we refit a model so rather than estimating the change in slope (currently), it will actually estimate the slope. See [Schielzeth 2010](https://doi.org/10.1111/j.2041-210X.2010.00012.x) for a detailed explanation of this approach.
```{r Adjust Model 2 for Slopes, eval=FALSE}
model_2_adj <- update(model_2, .~. -I(sc.sqrt.Pref^2))
```


```{r Boot Adjusted Model 2 for accurate slope estimates, cache=TRUE, eval=FALSE}
boot_model_2_adj <- bootMer(model_2_adj, FUN = fixef, nsim=n_boots_analysis, parallel="multicore", ncpus=32)

tidy_model_2_adj <- tidy(model_2_adj, conf.int=T) %>% 
  filter(term %in% c("I(sc.Diam^2)","I(sc.log.Clutch^2)","FoodwebComplex:I(sc.sqrt.Pref^2)","FoodwebSimple:I(sc.sqrt.Pref^2)",
                     "sc.Diam:sc.log.Clutch","sc.Diam:sc.sqrt.Pref","sc.log.Clutch:sc.sqrt.Pref"))
```

Importantly we see now that although quadratic selection varies between treatments, it is not different from zero in the simple food web.

```{r Plot Nonlinear Terms on appropriate scale, echo=FALSE, eval=FALSE}
tidy_model_2_adj$term_plot <- factor(tidy_model_2_adj$term,
                            levels=c("I(sc.Diam^2)","I(sc.log.Clutch^2)","FoodwebComplex:I(sc.sqrt.Pref^2)","FoodwebSimple:I(sc.sqrt.Pref^2)","sc.Diam:sc.log.Clutch","sc.Diam:sc.sqrt.Pref","sc.log.Clutch:sc.sqrt.Pref"),
                            ordered = TRUE)

tidy_model_2_adj %>%
  ggplot(., aes(x=term_plot)) +
  geom_linerange(aes(ymin=conf.low, ymax=conf.high)) +
  geom_point(aes(y=estimate), fill="grey", shape=21, size=3) +
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  scale_x_discrete(name="", limits = rev(levels(tidy_model_2_adj$term_plot))) +
  ylab("Coefficient (logit scale)")
```

Now we fit a reduced model to assess the effects of whether food-web treatments alters components of directional selection

```{r Fit Model 3, cache=TRUE}
model_3 <- update(model_2, 
                  .~. -I(sc.Diam^2) -I(sc.log.Clutch^2) -I(sc.sqrt.Pref^2) #-Foodweb:I(sc.sqrt.Pref^2) 
                  -sc.Diam:sc.log.Clutch -sc.Diam:sc.sqrt.Pref -sc.log.Clutch:sc.sqrt.Pref)
```

We then use parametric bootstrapping to test whether food-web treatment alters the linear relationship between each trait and larva survival.

```{r Bootstrap Model 3, cache=TRUE, include=FALSE}
boot_model_3 <- bootMer(model_3, FUN = fixef, nsim=n_boots_analysis, parallel="multicore", ncpus=32)

tidy_model_3 <- tidy(model_3, conf.int=T) # boot_model_3
```

Note that there was no effect of food-web structure on on chamber diameter (coef=`r round(filter(tidy_model_3, term=="FoodwebSimple:sc.Diam")$statistic,2)`, 95%CI=`r round(filter(tidy_model_3, term=="FoodwebSimple:sc.Diam")$conf.low,2)`,`r round(filter(tidy_model_3, term=="FoodwebSimple:sc.Diam")$conf.high,2)`) or female preference (coef=`r round(filter(tidy_model_3, term=="FoodwebSimple:sc.sqrt.Pref")$statistic,2)`, 95%CI=`r round(filter(tidy_model_3, term=="FoodwebSimple:sc.sqrt.Pref")$conf.low,2)`,`r round(filter(tidy_model_3, term=="FoodwebSimple:sc.sqrt.Pref")$conf.high,2)`).

```{r Plot Model 3, echo=FALSE}
plot_model_3 <- tidy_model_3 %>%
  mutate(Food_web = ifelse(grepl("FoodwebSimple:", .$term)==TRUE,"Simple","Complex")) %>%
  filter(Food_web == "Simple") 

plot_model_3$term_ord <- factor(plot_model_3$term, 
                                levels=c("FoodwebSimple:sc.Diam","FoodwebSimple:sc.log.Clutch","FoodwebSimple:sc.sqrt.Pref"),
                                ordered = TRUE)
plot_model_3 %>%
  ggplot(., aes(x=term_ord)) +
  geom_linerange(aes(ymin=conf.low, ymax=conf.high)) +
  geom_point(aes(y=estimate), size=3, shape=21, fill="grey") + # y=statistic
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  scale_x_discrete(limits=rev(levels(plot_model_3$term_ord))) +
  ylab("Coefficient (logit scale)")
```


There is clear evidence that food-web treatment alters the linear effect of clutch size on larva survival, but it has no effect on chamber diameter or female preference. Therefore, we fit a reduced model that removes these non-significant effects: 

```{r Fit Model 4, cache=TRUE}
model_4 <- update(model_3, .~. -Foodweb:sc.Diam -Foodweb:sc.sqrt.Pref)
```

This reduced model returns the same qualitative result as before. Specifically, that the linear effect of clutch size depends on food-web treatment. Note also that larval survival is significantly higher in the simple food web compared to the complex food web (dotted line). These are the regression coefficients we will use when calculating directional selection gradients ($\beta$).

```{r Bootstrap Model 4, cache=TRUE, include=FALSE}
boot_model_4 <- bootMer(model_4, FUN = fixef, nsim=n_boots_analysis, parallel="multicore", ncpus=32)

tidy_model_4 <- tidy(model_4, conf.int=T) # boot_model_4
```

```{r Plot Model 4, echo=FALSE}
tidy_model_4$term_plot <- factor(tidy_model_4$term, 
                                levels = c("(Intercept)","FoodwebSimple","sc.Diam","sc.log.Clutch","FoodwebSimple:sc.log.Clutch","sc.sqrt.Pref"),
                                ordered = TRUE)

plot_model_4 <- tidy_model_4 %>%
  filter(term != "(Intercept)") %>%
  droplevels() 

plot_model_4 %>%
  ggplot(., aes(x=term_plot)) +
  geom_linerange(aes(ymin=conf.low, ymax=conf.high)) +
  geom_point(aes(y=estimate), size=3, shape=21, fill="grey") + # y=statistic
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  scale_x_discrete(name="", limits = rev(levels(plot_model_4$term_plot))) +
  ylab("Coefficient (logit scale)")
```

As we did with model 2, we refit the model by removing the slope term so that we can fit different slopes for each interaction term. 
```{r Fit Model 4 adjusted for estimating clutch slopes, cache=TRUE}
model_4_adj <- update(model_4, .~. -sc.log.Clutch)
```

```{r Bootstrap adjusted model 4, cache=TRUE, include=FALSE}
boot_model_4_adj <- bootMer(model_4_adj, FUN = fixef, nsim=n_boots_analysis, parallel="multicore", ncpus=32)

tidy_model_4_adj <- tidy(model_4_adj, conf.int=T) # boot_model_4_adj
```

```{r Plot adjusted model 4, echo=FALSE}
tidy_model_4_adj$term_plot <- factor(tidy_model_4_adj$term, 
                                levels = c("(Intercept)","FoodwebSimple","sc.Diam","FoodwebComplex:sc.log.Clutch","FoodwebSimple:sc.log.Clutch","sc.sqrt.Pref"),
                                ordered = TRUE)

plot_model_4_adj <- tidy_model_4_adj %>%
  filter(term != "(Intercept)") %>%
  droplevels() 

plot_model_4_adj %>%
  ggplot(., aes(x=term_plot)) +
  geom_linerange(aes(ymin=conf.low, ymax=conf.high)) +
  geom_point(aes(y=estimate), size=3, shape=21, fill="grey") + # y=statistic
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  scale_x_discrete(name="", limits = rev(levels(plot_model_4_adj$term_plot))) +
  ylab("Coefficient (logit scale)")
```

```{r Average larval survival, cache=TRUE}
model_4_survival_ests <- update(model_4_adj, .~. -1)

boot_model_4_survival_ests <- bootMer(model_4_survival_ests, FUN = fixef, nsim=n_boots_analysis, parallel="multicore", ncpus=32)

tidy_model_4_survival_ests <- tidy(model_4_survival_ests, conf.int=T) # boot_model_4_survival_ests

round(inverse_logit(filter(tidy_model_4_survival_ests, term=="FoodwebComplex")$estimate),2) # statistic
round(inverse_logit(filter(tidy_model_4_survival_ests, term=="FoodwebSimple")$estimate),2) # statistic
```

Mean larval survival in complex food web = `r round(inverse_logit(filter(tidy_model_4_survival_ests, term=="FoodwebComplex")$statistic),2)` [`r round(inverse_logit(filter(tidy_model_4_survival_ests, term=="FoodwebComplex")$conf.low),2)`,`r round(inverse_logit(filter(tidy_model_4_survival_ests, term=="FoodwebComplex")$conf.high),2)`].

Mean larval survival in simple food web = `r round(inverse_logit(filter(tidy_model_4_survival_ests, term=="FoodwebSimple")$statistic),2)` [`r round(inverse_logit(filter(tidy_model_4_survival_ests, term=="FoodwebSimple")$conf.low),2)`, `r round(inverse_logit(filter(tidy_model_4_survival_ests, term=="FoodwebSimple")$conf.high),2)`].

So, for plotting the results, we are going to use the focused nonlinear model. This provides the best representation of the fitness landscape (although we can't use it to assess to quantify the effects of directional selection.

Note that while there is no evidence to let the slopes vary among treatments, there is a clear effect of food web treatment on fitness. This could influence estimates of selection by magnifying them in the complex vs. simple food web.

So to calculate the selection gradients, we used Janzen and Stern's method to transform the regression coefficients.

Basically, I need to just multiply all of the coefficients by the simple and complex fitness. Except, however, for I(sc.sqrt.Pref) and sc.log.Clutch. Here, we need the different coefficients.

# Selection Gradients

We used the method of [Janzen and Stern (1998)](https://doi.org/10.1111/j.1558-5646.1998.tb02237.x) to calculate selection gradients. Specifically, we first multiply each regression coefficient (and confidence interval) by the average of $W(z)[1-W(z)]$, where $W(z)$ corresponds to the predicted absolute fitness of an individual (in this case 1 if the larva survived, 0 if not) given its multivariate phenotype ($z$). We then divided this value by the mean absolute fitness ($\bar W$) so our results are in terms of relative fitness ($w$). Note that we doubled all quadratic selection gradients ($\gamma_{z_i,z_i}) to put them on the same scale as the directional and correlational selection gradients (detailed explanation in [Stinchcombe et al. 2008](https://doi.org/10.1111/j.1558-5646.2008.00449.x)).

```{r Organize and Transform Coefficients, include=FALSE}
tidy_coefs <- bind_rows(
  select(tidy_model_2, term, estimate, conf.low, conf.high), # estimate=statistic; tidy_model_2_adj no longer needed, since quadratic and correlational selection didn't differ among treatments
  select(tidy_model_4_adj, term, estimate, conf.low, conf.high)) %>% # estimate=statistic
  filter(term != "(Intercept)", term != "FoodwebSimple") # remove main effects

# Tidy common coefficients
tidy_common_coefs <- tidy_coefs %>%
  filter(#term!="FoodwebComplex:I(sc.sqrt.Pref^2)", term!="FoodwebSimple:I(sc.sqrt.Pref^2)",
         term!="FoodwebComplex:sc.log.Clutch",term!="FoodwebSimple:sc.log.Clutch")

# Tidy unique coefficients to each food-web
#complex_quad_pref <- filter(tidy_coefs, term %in% "FoodwebComplex:I(sc.sqrt.Pref^2)")
#complex_quad_pref$term <- "I(sc.sqrt.Pref^2)"
#simple_quad_pref <- filter(tidy_coefs, term %in% "FoodwebSimple:I(sc.sqrt.Pref^2)")
#simple_quad_pref$term <- "I(sc.sqrt.Pref^2)"


complex_clutch <- filter(tidy_coefs, term %in% "FoodwebComplex:sc.log.Clutch")
complex_clutch$term <- "sc.log.Clutch"
simple_clutch <- filter(tidy_coefs, term %in% "FoodwebSimple:sc.log.Clutch")
simple_clutch$term <- "sc.log.Clutch"
```


```{r Calculate Selection Gradients, include=FALSE}

# Estimate mean fitness and mean "brackets" for each food-web treatment (see Janzen and Stern 1998 equation 4 for details about "brackets")
complex_predict <- predict(model_2, newdata=filter(gall_selection.df, Foodweb=="Complex"), type="response")
complex_mean_brackets <- mean(complex_predict * (1 - complex_predict))
complex_mean_fitness <- mean(complex_predict)

simple_predict <- predict(model_2, newdata=filter(gall_selection.df, Foodweb=="Simple"), type="response")
simple_mean_brackets <- mean(simple_predict * (1 - simple_predict))
simple_mean_fitness <- mean(simple_predict)

# Double-check that using a different model (e.g. model_4) doesn't influence estimes of mean "brackets" and mean fitness. Below, I test this using the "Complex" food-web treatment as an example, but it doesn't matter 
alt_predict <- predict(model_4, newdata=filter(gall_selection.df, Foodweb=="Complex"), type="response")
alt_mean_brackets <- mean(alt_predict * (1 - alt_predict))
alt_mean_fitness <- mean(alt_predict)
test_mean_brackets <- complex_mean_brackets
test_mean_fitness <- complex_mean_fitness
test_mean_brackets - alt_mean_brackets # virtually the same
test_mean_fitness - alt_mean_fitness # virtually the same

tidy_simple_grads <- bind_rows(tidy_common_coefs, simple_clutch) %>% # simple_quad_pref, 
  mutate(Multiplier = ifelse(grepl("\\^2", .$term)==TRUE, 2, 1)) %>% # double all quadratic gradients so they are on the same scale as other directional and correlational selection gradients (detailed explanation in Stinchcombe et al. 2008)
  transmute(term=term,
            gradient = simple_mean_brackets * estimate / simple_mean_fitness * Multiplier,
            `2.5%` = simple_mean_brackets * conf.low / simple_mean_fitness * Multiplier,
            `97.5%` = simple_mean_brackets * conf.high / simple_mean_fitness * Multiplier)

tidy_complex_grads <- bind_rows(tidy_common_coefs, complex_clutch) %>% # complex_quad_pref, 
    mutate(Multiplier = ifelse(grepl("\\^2", .$term)==TRUE, 2, 1)) %>% # double all quadratic gradients so they are on the same scale as other directional and correlational selection gradients (detailed explanation in Stinchcombe et al. 2008)
  transmute(term=term,
            gradient = complex_mean_brackets * estimate / complex_mean_fitness * Multiplier,
            `2.5%` = complex_mean_brackets * conf.low / complex_mean_fitness * Multiplier,
            `97.5%` = complex_mean_brackets * conf.high / complex_mean_fitness * Multiplier)

selection_gradients <- bind_rows(
  mutate(tidy_simple_grads, `Food web`="Simple"),
  mutate(tidy_complex_grads, `Food web`="Complex")) #%>%
  #mutate(Type = ifelse(grepl("\\^2", .$term)==TRUE, "Quadratic", ifelse(grepl(":", .$term)==TRUE, "Correlational", "Directional")))
```


```{r Table of Selection Gradients, echo=FALSE}
selection_gradients$term_ord <- factor(selection_gradients$term, 
                                   levels=c("sc.Diam","sc.log.Clutch","sc.sqrt.Pref","I(sc.Diam^2)","I(sc.log.Clutch^2)","I(sc.sqrt.Pref^2)","sc.Diam:sc.log.Clutch","sc.Diam:sc.sqrt.Pref","sc.log.Clutch:sc.sqrt.Pref"),
                                   labels=c("Diam","Clutch","Pref","Diam^2","Clutch^2","Pref^2","Diam:Clutch","Diam:Pref","Clutch:Pref"),
                                   ordered = TRUE)

selection_gradients_table <- selection_gradients %>%
  transmute(Term=term_ord, `Food web`, Gradient=round(gradient,2), `2.5%`=round(`2.5%`,2), `97.5%`=round(`97.5%`,2)) %>% 
  arrange(Term)

knitr::kable(selection_gradients_table, caption = "Table of Selection Gradients")
```

```{r Plot of Selection Gradients, echo=FALSE}
selection_gradients %>%
  ggplot(., aes(x=term_ord)) +
  geom_linerange(aes(ymin=`2.5%`, ymax=`97.5%`, color=`Food web`), position=position_dodge(width=0.3)) +
  geom_point(aes(y=gradient, fill=`Food web`), color="black", shape=21, size=3, position=position_dodge(width=0.3)) +
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  scale_x_discrete(name="", limits = rev(levels(selection_gradients$term_ord))) +
  ylab("Selection Gradient") +
  scale_fill_manual(values=treatment_colors) +
  scale_color_manual(values=treatment_colors)
```

## Contributions of larval parasitoids to selection gradients

To identify the mechanisms by which food-web treatment altered selection gradients, we refit our models so that the complex food-web treatment only contained cases of parasitisms from larval parasitoids. Therefore, these analyses identify the unique contribution of each parasitoid guild to the selection gradients (egg parasitoid from simple food web; larval parasitoid from complex food web). Note that cases of larval parasitism may have been initially parasitized by an egg parasitoid.

We restrict our model analyses to those where we observed different effects of food-web treatment on larval survival from the prior analyses (i.e. model 2 and model 4).

```{r Egg vs. Larval Parasitoids Model, cache=TRUE}

# excludes cases of egg-parasitism from Complex food web
egg.vs.larval_df <- filter(gall_selection.df, Foodweb == "Simple" | Foodweb == "Complex" & platy < 1) %>% 
  mutate(Foodweb = ifelse(Foodweb == "Simple", "Egg", "Larval"))

egg.larval_model_2 <- update(model_2, data=egg.vs.larval_df)
```

```{r Bootstrap Egg vs. Larval Parasitoid Model 2, cache=TRUE, include=FALSE}

boot_egg.larval_model_2 <- bootMer(egg.larval_model_2, FUN = fixef, nsim=n_boots_analysis, parallel="multicore", ncpus=32)

tidy_egg.larval_model_2 <- tidy(egg.larval_model_2, conf.int=T) %>% # boot_egg.larval_model_2
  filter(term %in% c("I(sc.Diam^2)","I(sc.log.Clutch^2)","I(sc.sqrt.Pref^2)",
                     "sc.Diam:sc.log.Clutch","sc.Diam:sc.sqrt.Pref","sc.log.Clutch:sc.sqrt.Pref"))#,
                     #"FoodwebLarval:I(sc.sqrt.Pref^2)")) 
```

This represents our nonlinear regression coefficients.

```{r Plot effect of Egg vs. Larval Parasitoid Model 2, echo=FALSE}
tidy_egg.larval_model_2$term_plot <- factor(tidy_egg.larval_model_2$term,
                            levels=c("I(sc.Diam^2)","I(sc.log.Clutch^2)","I(sc.sqrt.Pref^2)","sc.Diam:sc.log.Clutch","sc.Diam:sc.sqrt.Pref","sc.log.Clutch:sc.sqrt.Pref"),
                            ordered = TRUE)

tidy_egg.larval_model_2 %>%
  ggplot(., aes(x=term_plot)) +
  geom_linerange(aes(ymin=conf.low, ymax=conf.high)) +
   geom_point(aes(y=estimate), size=3, shape=21, fill="grey") +
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  scale_x_discrete(name="", limits = rev(levels(tidy_egg.larval_model_2$term_plot))) +
  ylab("Coefficient (logit scale)")
```
 To put all of the coefficients on the same scale, we refit it as we did in the food-web treatment
```{r Egg vs. Larval Parasitoids adjusted model 2, cache=TRUE, eval=FALSE}
egg.larval_model_2_adj <- update(model_2_adj, data=egg.vs.larval_df)
```

```{r Bootstrap Egg vs. Larval Parasitoid adjusted Model 2, cache=TRUE, include=FALSE, eval=FALSE}

boot_egg.larval_model_2_adj <- bootMer(egg.larval_model_2_adj, FUN = fixef, nsim=n_boots_analysis, parallel="multicore", ncpus=32)

tidy_egg.larval_model_2_adj <- tidy(egg.larval_model_2_adj, conf.int=T) %>% 
  filter(term %in% c("I(sc.Diam^2)","I(sc.log.Clutch^2)","FoodwebEgg:I(sc.sqrt.Pref^2)","FoodwebLarval:I(sc.sqrt.Pref^2)",
                     "sc.Diam:sc.log.Clutch","sc.Diam:sc.sqrt.Pref","sc.log.Clutch:sc.sqrt.Pref")) 
```

This represents our nonlinear regression coefficients.

```{r Plot effect of Egg vs. Larval Parasitoid adjusted Model 2, echo=FALSE, eval=FALSE}
tidy_egg.larval_model_2_adj$term_plot <- factor(tidy_egg.larval_model_2_adj$term,
                            levels=c("I(sc.Diam^2)","I(sc.log.Clutch^2)","FoodwebEgg:I(sc.sqrt.Pref^2)","FoodwebLarval:I(sc.sqrt.Pref^2)","sc.Diam:sc.log.Clutch","sc.Diam:sc.sqrt.Pref","sc.log.Clutch:sc.sqrt.Pref"),
                            ordered = TRUE)

tidy_egg.larval_model_2_adj %>%
  ggplot(., aes(x=term_plot)) +
  geom_linerange(aes(ymin=conf.low, ymax=conf.high)) +
   geom_point(aes(y=estimate), size=3, shape=21, fill="grey") +
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  scale_x_discrete(name="", limits = rev(levels(tidy_egg.larval_model_2_adj$term_plot))) +
  ylab("Coefficient (logit scale)")
```

Now we assess their contribution to the effect of food-web treatment on the linear terms.

```{r Fit Egg vs. Larval Parasitoid Model 4, cache=TRUE}
egg.larval_model_4 <- update(model_4, data=egg.vs.larval_df)
```

This reduced model returns the same qualitative result as before. Specifically, that the linear effect of clutch size depends on food-web treatment. Note also that larval survival is significantly higher in the simple food web compared to the complex food web (dotted line). These are the regression coefficients we will use when calculating directional selection gradients ($\beta$).

```{r Bootstrap Egg vs. Larval Parasitoid Model 4, cache=TRUE, include=FALSE}
boot_egg.larval_model_4 <- bootMer(egg.larval_model_4, FUN = fixef, nsim=n_boots_analysis, parallel="multicore", ncpus=32)

tidy_egg.larval_model_4 <- tidy(egg.larval_model_4, conf.int=T) # boot_egg.larval_model_4
```

Here, we observe clear evidence of conflicting selection pressures on clutch size. This results in net zero selection gradient acting on clutch size in the complex food web.
```{r Plot Egg vs. Larval Parasitoid Model 4, echo=FALSE}
tidy_egg.larval_model_4$term_ord <- factor(tidy_egg.larval_model_4$term, 
                                levels = c("(Intercept)","FoodwebLarval","sc.Diam","sc.log.Clutch","FoodwebLarval:sc.log.Clutch","sc.sqrt.Pref"),
                                ordered = TRUE)

plot_egg.larval_model_4 <- tidy_egg.larval_model_4 %>%
  filter(term != "(Intercept)") %>%
  droplevels() 

plot_egg.larval_model_4 %>%
  ggplot(., aes(x=term_ord)) +
  geom_linerange(aes(ymin=conf.low, ymax=conf.high)) +
  geom_point(aes(y=estimate), size=3, shape=21, fill="grey") + # y=statistic
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  scale_x_discrete(name="", limits = rev(levels(plot_egg.larval_model_4$term_ord))) +
  ylab("Coefficient (logit scale)")
```

```{r Fit Egg vs. Larval Parasitoid adjusted Model 4, cache=TRUE}
egg.larval_model_4_adj <- update(model_4_adj, data=egg.vs.larval_df)
```

This reduced model returns the same qualitative result as before. Specifically, that the linear effect of clutch size depends on food-web treatment. Note also that larval survival is significantly higher in the simple food web compared to the complex food web (dotted line). These are the regression coefficients we will use when calculating directional selection gradients ($\beta$).

```{r Bootstrap Egg vs. Larval Parasitoid adjuted Model 4, cache=TRUE, include=FALSE}
boot_egg.larval_model_4_adj <- bootMer(egg.larval_model_4_adj, FUN = fixef, nsim=n_boots_analysis, parallel="multicore", ncpus=32)

tidy_egg.larval_model_4_adj <- tidy(egg.larval_model_4_adj, conf.int=T) # boot_egg.larval_model_4_adj
```

Here, we observe clear evidence of conflicting selection pressures on clutch size. This results in net zero selection gradient acting on clutch size in the complex food web.
```{r Plot Egg vs. Larval Parasitoid adjusted Model 4, echo=FALSE}
tidy_egg.larval_model_4_adj$term_ord <- factor(tidy_egg.larval_model_4_adj$term, 
                                levels = c("(Intercept)","FoodwebLarval","sc.Diam","FoodwebEgg:sc.log.Clutch","FoodwebLarval:sc.log.Clutch","sc.sqrt.Pref"),
                                ordered = TRUE)

plot_egg.larval_model_4_adj <- tidy_egg.larval_model_4_adj %>%
  filter(term != "(Intercept)") %>%
  droplevels() 

plot_egg.larval_model_4_adj %>%
  ggplot(., aes(x=term_ord)) +
  geom_linerange(aes(ymin=conf.low, ymax=conf.high)) +
  geom_point(aes(y=estimate), size=3, shape=21, fill="grey") + # y=statistic
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  scale_x_discrete(name="", limits = rev(levels(plot_egg.larval_model_4_adj$term_ord))) +
  ylab("Coefficient (logit scale)")
```

## CALCULATE SELECTION GRADIENTS FOR EGG VS. LARVAL PARASITOIDS

```{r Organize and Transform egg vs. larval parasitoid Coefficients, include=FALSE}
tidy_egg.larval_coefs <- bind_rows(
  select(tidy_egg.larval_model_2, term, estimate, conf.low, conf.high),  # estimate=statistic; tidy_egg.larval_model_2_adj no longer needed because no nonlinear difference on preference.
  select(tidy_egg.larval_model_4_adj, term, estimate, conf.low, conf.high)) %>% # estimate=statistic
  filter(term != "(Intercept)", term != "FoodwebLarval") # remove main effects

# Tidy common coefficients
tidy_egg.larval_common_coefs <- tidy_egg.larval_coefs %>%
  filter(#term!="FoodwebEgg:I(sc.sqrt.Pref^2)", term!="FoodwebLarval:I(sc.sqrt.Pref^2)",
         term!="FoodwebEgg:sc.log.Clutch",term!="FoodwebLarval:sc.log.Clutch")

# Tidy unique coefficients to each food-web
#egg_quad_pref <- filter(tidy_egg.larval_coefs, term %in% "FoodwebEgg:I(sc.sqrt.Pref^2)")
#egg_quad_pref$term <- "I(sc.sqrt.Pref^2)"
#larval_quad_pref <- filter(tidy_egg.larval_coefs, term %in% "FoodwebLarval:I(sc.sqrt.Pref^2)")
#larval_quad_pref$term <- "I(sc.sqrt.Pref^2)"

egg_clutch <- filter(tidy_egg.larval_coefs, term %in% "FoodwebEgg:sc.log.Clutch")
egg_clutch$term <- "sc.log.Clutch"
larval_clutch <- filter(tidy_egg.larval_coefs, term %in% "FoodwebLarval:sc.log.Clutch")
larval_clutch$term <- "sc.log.Clutch"
```


```{r Calculate Egg vs. larval parasitoid Selection Gradients, include=FALSE}

# Estimate mean fitness and mean "brackets" for each food-web treatment (see Janzen and Stern 1998 equation 4 for details about "brackets")
larval_predict <- predict(egg.larval_model_2, newdata=filter(egg.vs.larval_df, Foodweb=="Larval"), type="response")
larval_mean_brackets <- mean(larval_predict * (1 - larval_predict))
larval_mean_fitness <- mean(larval_predict)

egg_predict <- predict(egg.larval_model_2, newdata=filter(egg.vs.larval_df, Foodweb=="Egg"), type="response")
egg_mean_brackets <- mean(egg_predict * (1 - egg_predict))
egg_mean_fitness <- mean(egg_predict)

# Double-check that using a different model (e.g. egg.larval_model_4) doesn't influence estimes of mean "brackets" and mean fitness. Using "Complex" food-web treatment as an example, but it doesn't matter 
alt_egg.larval_predict <- predict(egg.larval_model_4, newdata=filter(egg.vs.larval_df, Foodweb=="Larval"), type="response")
alt_egg.larval_mean_brackets <- mean(alt_egg.larval_predict * (1 - alt_egg.larval_predict))
alt_egg.larval_mean_fitness <- mean(alt_egg.larval_predict)
test_egg.larval_mean_brackets <- larval_mean_brackets
test_egg.larval_mean_fitness <- larval_mean_fitness
test_egg.larval_mean_brackets - alt_egg.larval_mean_brackets # virtually the same
test_egg.larval_mean_fitness - alt_egg.larval_mean_fitness # virtually the same

tidy_egg_grads <- bind_rows(tidy_egg.larval_common_coefs, egg_clutch) %>% # egg_quad_pref, 
  mutate(Multiplier = ifelse(grepl("\\^2", .$term)==TRUE, 2, 1)) %>% # double all quadratic gradients so they are on the same scale as other directional and correlational selection gradients (detailed explanation in Stinchcombe et al. 2008)
  transmute(term=term,
            gradient = egg_mean_brackets * estimate / egg_mean_fitness * Multiplier,
            `2.5%` = egg_mean_brackets * conf.low / egg_mean_fitness * Multiplier,
            `97.5%` = egg_mean_brackets * conf.high / egg_mean_fitness * Multiplier)

tidy_larval_grads <- bind_rows(tidy_egg.larval_common_coefs, larval_clutch) %>% # larval_quad_pref, 
    mutate(Multiplier = ifelse(grepl("\\^2", .$term)==TRUE, 2, 1)) %>% # double all quadratic gradients so they are on the same scale as other directional and correlational selection gradients (detailed explanation in Stinchcombe et al. 2008)
  transmute(term=term,
            gradient = larval_mean_brackets * estimate / larval_mean_fitness * Multiplier,
            `2.5%` = larval_mean_brackets * conf.low / larval_mean_fitness * Multiplier,
            `97.5%` = larval_mean_brackets * conf.high / larval_mean_fitness * Multiplier)

egg.larval_selection_gradients <- bind_rows(
  mutate(tidy_egg_grads, `Food web`="Egg"),
  mutate(tidy_larval_grads, `Food web`="Larval")) #%>%
  #mutate(Type = ifelse(grepl("\\^2", .$term)==TRUE, "Quadratic", ifelse(grepl(":", .$term)==TRUE, "Correlational", "Directional")))
```


```{r Table of Egg vs. Larval Parasitoid Selection Gradients, echo=FALSE}
egg.larval_selection_gradients$term_ord <- factor(egg.larval_selection_gradients$term, 
                                   levels=c("sc.Diam","sc.log.Clutch","sc.sqrt.Pref","I(sc.Diam^2)","I(sc.log.Clutch^2)","I(sc.sqrt.Pref^2)","sc.Diam:sc.log.Clutch","sc.Diam:sc.sqrt.Pref","sc.log.Clutch:sc.sqrt.Pref"),
                                   labels=c("Diam","Clutch","Pref","Diam^2","Clutch^2","Pref^2","Diam:Clutch","Diam:Pref","Clutch:Pref"),
                                   ordered = TRUE)

egg.larval_selection_gradients_table <- egg.larval_selection_gradients %>%
  transmute(Term=term_ord, Parasitoid=`Food web`, Gradient=round(gradient,2), `2.5%`=round(`2.5%`,2), `97.5%`=round(`97.5%`,2)) %>% 
  arrange(Term)

knitr::kable(egg.larval_selection_gradients_table, caption = "Table of Egg vs. Larval Parasitoid Selection Gradients")
```

```{r Plot of Egg vs. Larval Parasitoid Selection Gradients, echo=FALSE}
egg.larval_selection_gradients %>%
  ggplot(., aes(x=term_ord)) +
  geom_linerange(aes(ymin=`2.5%`, ymax=`97.5%`, color=`Food web`), position=position_dodge(width=0.3)) +
  geom_point(aes(y=gradient, fill=`Food web`), color="black", shape=21, size=3, position=position_dodge(width=0.3)) +
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  scale_x_discrete(name="", limits = rev(levels(egg.larval_selection_gradients$term_ord))) +
  ylab("Selection Gradient") +
  scale_fill_manual(name="Parasitoid", values=treatment_colors[c(2,1)]) +
  scale_color_manual(name="Parasitoid", values=treatment_colors[c(2,1)]) 
```

# Quantifying biased selection on chamber diameter

We quantified biased selection on chamber diameter in the following way. First, we focus on multi-chambered galls where there is evidence of both survival and parasitism. The idea is that galls from the same clutch should be similar in size; therefore, any selection on diameter would be apparent. If we assume that this is all due to the effect of parasitism on larval development, truncating gall diameter, then we can consider this new selection differential to be the result of confounding factors. Note that this method likely overestimates the confounding effect of parasitism, since we are assuming that any heterogeneity in chamber diameter (for this subset) is due to parasitism. 

We calculated the bias in selection differential on chamber diameter by calculating the difference in mean chamber diameter before (i.e. all larva within the same gall) and after selection (only surviving larva). We then used a one-sample t-test to determine whether the selection differential was significantly different from zero. We conducted separate t-tests for each food-web treatment.

We can then subtract this "biased selection differential" from the observed directional selection gradient on chamber diameter to adjust for the confounding effects of parasitism. 

```{r New approach for biased selection, include=FALSE}
biased_df <- gall_selection.df %>%
  group_by(Foodweb, Gall_Number) %>%
  mutate(mean_survival = mean(gall_survival)) %>%
  filter(mean_survival > 0, mean_survival < 1)

summary(update(model_1, data=biased_df)) # no clear effects here...
summary(update(model_2, data=biased_df)) # seeing the bias here, but its still not what we actually assess the differences on
summary(update(model_3, data=biased_df)) # we're going to focus on diameter since that's our focus now. It doesn't appear that the slope differes between food-web treatments
biased.diam_model_4 <- update(model_4, data=biased_df)
summary(biased.diam_model_4) # looks like the bias in our sc.Diam coefficient is 0.34

bias.adj_complex_predict <- predict(biased.diam_model_4, newdata=filter(biased_df, Foodweb=="Complex"), type="response")
bias.adj_complex_mean_brackets <- mean(bias.adj_complex_predict * (1 - bias.adj_complex_predict))
bias.adj_complex_mean_fitness <- mean(bias.adj_complex_predict)

bias.adj_simple_predict <- predict(biased.diam_model_4, newdata=filter(biased_df, Foodweb=="Simple"), type="response")
bias.adj_simple_mean_brackets <- mean(bias.adj_simple_predict * (1 - bias.adj_simple_predict))
bias.adj_simple_mean_fitness <- mean(bias.adj_simple_predict)

# convert to selection gradient
bias.adj_sc.Diam_complex <- bias.adj_complex_mean_brackets * fixef(biased.diam_model_4)["sc.Diam"] / bias.adj_complex_mean_fitness * 1 # 0.16
bias.adj_sc.Diam_simple <- bias.adj_simple_mean_brackets * fixef(biased.diam_model_4)["sc.Diam"] / bias.adj_simple_mean_fitness * 1 # 0.18

# This analysis suggests that there is a little bias, but not too much. 
```

```{r Redo selection gradients, include=FALSE}
bias.adj_selection_gradients <- mutate(selection_gradients, adjusted = "No") %>%
  # add bias adjusted directional selection gradient for Diameter in complex food-web
  add_row(term="sc.Diam", 
          gradient = complex_mean_brackets * (filter(tidy_common_coefs, term=="sc.Diam")$estimate - fixef(biased.diam_model_4)["sc.Diam"]) / complex_mean_fitness, 
          `2.5%` = complex_mean_brackets * (filter(tidy_common_coefs, term=="sc.Diam")$conf.low - fixef(biased.diam_model_4)["sc.Diam"]) / complex_mean_fitness, 
          `97.5%` = complex_mean_brackets * (filter(tidy_common_coefs, term=="sc.Diam")$conf.high - fixef(biased.diam_model_4)["sc.Diam"]) / complex_mean_fitness, 
          `Food web` = "Complex", 
          term_ord = "Diam", 
          adjusted="Yes") %>%
  # add bias adjusted directional selection gradient for Diameter in simple food-web
  add_row(term="sc.Diam", 
          gradient = simple_mean_brackets * (filter(tidy_common_coefs, term=="sc.Diam")$estimate - fixef(biased.diam_model_4)["sc.Diam"]) / simple_mean_fitness, 
          `2.5%` = simple_mean_brackets * (filter(tidy_common_coefs, term=="sc.Diam")$conf.low - fixef(biased.diam_model_4)["sc.Diam"]) / simple_mean_fitness, 
          `97.5%` = simple_mean_brackets * (filter(tidy_common_coefs, term=="sc.Diam")$conf.high - fixef(biased.diam_model_4)["sc.Diam"]) / simple_mean_fitness, 
          `Food web` = "Simple", 
          term_ord = "Diam", 
          adjusted="Yes")
```

```{r Bias in gradients on chamber diameter}
fixef(biased.diam_model_4)["sc.Diam"]
```

```{r Variance explained in chamber diameter}
chamber_diam <- lmer(sc.Diam ~ Foodweb + (1|Genotype/Plant_Position/Gall_Number), data=gall_selection.df)
summary(chamber_diam)
car::Anova(chamber_diam, test="F")

# variance explained by gall ID
0.5374/(0.5374+0.0956+0.1671+0.2031)
```

```{r Variance explained in other traits}
clutch_size <- lmer(sc.log.Clutch ~ Foodweb + (1|Genotype/Plant_Position), data=distinct(gall_selection.df, Foodweb, Genotype, Plant_Position, Gall_Number, sc.log.Clutch))
summary(clutch_size)
car::Anova(clutch_size, test="F")

female_pref <- lmer(sc.sqrt.Pref ~ Foodweb + (1|Genotype), data=distinct(gall_selection.df, Foodweb, Genotype, Plant_Position, sc.sqrt.Pref))
summary(female_pref)
car::Anova(female_pref, test="F")
```


```{r female pref plot, echo=F}
visreg::visreg(female_pref, xvar="Foodweb")
```


```{r Plot of bias adjusted Selection Gradients, echo=FALSE}
bias.adj_selection_gradients %>%
  ggplot(., aes(x=term_ord, shape=adjusted)) +
  geom_linerange(aes(ymin=`2.5%`, ymax=`97.5%`, color=`Food web`), position=position_dodge(width=1)) +
  geom_point(aes(y=gradient, fill=`Food web`), color="black", size=3, position=position_dodge(width=1)) +
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  scale_x_discrete(name="", limits = rev(levels(bias.adj_selection_gradients$term_ord))) +
  ylab("Selection Gradient") +
  scale_fill_manual(values=treatment_colors) +
  scale_color_manual(values=treatment_colors) +
  scale_shape_manual(name="Bias\nadjusted", values=c(21,23))
```

## Figure for manuscript

Only use selection gradients for larval parasitoids, use both complex and simple food webs, and only bias adjusted for chamber diameter.

```{r Prep selection gradients figure, echo=FALSE}

focus_gradients <- bind_rows(filter(bias.adj_selection_gradients, term_ord == "Diam" & adjusted == "Yes" | term_ord != "Diam"),
                             filter(egg.larval_selection_gradients, `Food web` == "Larval" & term_ord %in% c("Clutch"))) %>%   # ,"Pref^2"
  mutate(Type = ifelse(grepl("\\^2", .$term_ord)==TRUE, "Quadratic", ifelse(grepl(":", .$term_ord)==TRUE, "Correlational", "Directional"))) 

focus_gradients$Type_ord <- factor(focus_gradients$Type, 
                                   levels=c("Directional","Quadratic","Correlational"),
                                   ordered = TRUE)

focus_gradients$axis_x_labels <- as.character(focus_gradients$term_ord)

max_gradient <- max(focus_gradients$`97.5%`)
min_gradient <- min(focus_gradients$`2.5%`)
gradient_limits <- c(-0.3, 0.75)

legend_labels <- c("Egg + Larval (Complex)","Larval parasitoids","Egg parasitoid (Simple)")

directional <- filter(focus_gradients, Type=="Directional") %>%
  ggplot(., aes(x=term_ord)) +
  geom_linerange(aes(ymin=`2.5%`, ymax=`97.5%`, color=`Food web`), position=position_dodge(width=0.5)) +
  geom_point(aes(y=gradient, fill=`Food web`), color="black", size=3, position=position_dodge(width=0.5), shape=21) +
  #coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  ylab("Selection Gradient") +
  scale_fill_manual(values=cbPalette[c(6,4,5)], labels=legend_labels) +
  scale_color_manual(values=cbPalette[c(6,4,5)], labels=legend_labels) +
  facet_wrap(~Type_ord, ncol=2, scales="free_x") +
  scale_x_discrete(name="", labels=parse(text=c("beta[Diam]","beta[Clutch]","beta[Pref]"))) +
  scale_y_continuous(limits = gradient_limits) +
  theme(legend.title.align = 0.5)

quadratic <- filter(focus_gradients, Type=="Quadratic") %>%
  ggplot(., aes(x=term_ord)) +
  geom_linerange(aes(ymin=`2.5%`, ymax=`97.5%`, color=`Food web`), position=position_dodge(width=0.5)) +
  geom_point(aes(y=gradient, fill=`Food web`), color="black", size=3, position=position_dodge(width=0.5), shape=21) +
  #coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  ylab("Selection Gradient") +
  scale_fill_manual(values=cbPalette[c(6,5)]) + # c(6,4,5) no longer effect on preference
  scale_color_manual(values=cbPalette[c(6,5)]) + # c(6,4,5) no longer effect on preference
  facet_wrap(~Type_ord, ncol=2, scales="free_x") +
  scale_x_discrete(name="", labels=parse(text=c("gamma[Diam:Diam]","gamma[Clutch:Clutch]","gamma[Pref:Pref]"))) +
  scale_y_continuous(limits = gradient_limits)

correlational <- filter(focus_gradients, Type=="Correlational") %>%
  ggplot(., aes(x=term_ord)) +
  geom_linerange(aes(ymin=`2.5%`, ymax=`97.5%`, color=`Food web`), position=position_dodge(width=0.5)) +
  geom_point(aes(y=gradient, fill=`Food web`), color="black", size=3, position=position_dodge(width=0.5), shape=21) +
  #coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  ylab("Selection Gradient") +
  scale_fill_manual(values=cbPalette[c(6,5)]) + # changed from 6,4,5 since larval parasitoids didn't differ for any correlational gradients
  scale_color_manual(values=cbPalette[c(6,5)]) + # same as above
  facet_wrap(~Type_ord, ncol=2, scales="free_x") +
  scale_x_discrete(name="", labels=parse(text=c("gamma[Diam:Clutch]","gamma[Diam:Pref]","gamma[Clutch:Pref]"))) +
  scale_y_continuous(limits = gradient_limits)
```

Standardized selection gradients estimate selection on a trait in terms of the effects on relative fitness in units of (phenotypic) standard deviations of the trait, allowing direct comparisons among traits, fitness components, and study systems (Kingsolver et al. 2001, Am. Nat.).

```{r Selection-Gradients, echo=FALSE, fig.cap="Selection gradients. Points and lines represents means and 95% confidence intervals (n=1,000 bootstrapped samples)."}

# Get legend
gradients_legend <- get_legend(directional)

# Format plots
gradients_plots <- plot_grid(
  directional + theme(legend.position = "none", axis.title = element_blank()),
  quadratic + theme(legend.position = "none", axis.title = element_blank()),
  correlational + theme(legend.position = "none", axis.title = element_blank()), 
  nrow=2, align="hv", labels = "")
gradients_plots_legend <- ggdraw(gradients_plots) + draw_grob(gradients_legend, x = 0.6, y=-0.2) # x = 0.7, y=-0.2
gradients_y_title <- ggdraw() + draw_label("Selection gradient (SDs)", angle = 90)

gradients_figure <- plot_grid(gradients_y_title, gradients_plots_legend, ncol=2, rel_widths = c(0.05,1))
gradients_figure
```


## Selection on the egg parasitoid *Platygaster*

We cannot calculate selection on the egg parasitoids *Platygaster* with the same method as we did for the herbivore *Iteomyia*. This is because the unique biology of host-parasitoid interactions enables us to determine whether the host (herbivore) has survived or not. With the egg parasitoid, we only have a record of the gall it was found in. But, we can take advantage of our treatment which excludes the guild of larval parasitoids. Specifically, we can compare the mean gall phenotype that egg parasitoids are reared from in the absence of larval parasitoids ("before" selection) to the mean gall phenotype in the presence of larval parasitoids ("after" selection). Therefore, we can use this cross-sectional data to quantify directional and quadratic selection differentials acting on the gall phenotypes. In essence, the gall phenotype becomes the extended phenotype of the egg parasitoid, since its attributes can influence the egg parasitoid's survival to its intraguild predator (larval parasitoid).

To quantify the selection differential acting on the egg parasitoid, we used separate linear mixed models with the gall phenotype as the response variable, food-web treatment as the fixed effect, and then the same suite of random effects as for our primary analyses of *Iteomyia* survival (i.e. gall ID, nested within plant ID, nested within plant genotype).

We found no evidence of directional or quadratic selection on either chamber diameter or clutch size; however, we observed positive directional selection on *Iteomyia* female preference as well stabilizing selection on preference.

Appears to be selection for Platygaster to attack larva at high densities in more complex food webs (and a decrease in the variance). This may be a result of the poorer searching ability of parasitoids at very high gall densities, potentially due to saturation. This suggests that the fitness landscape may be dynamic because these selective effects (assuming there is heritable variation in the egg parasitoid) will change the following year. This could be an important discussion point to take into account for future work. This is different from simply altering the strength of selection, which will occur as species move along the fitness landscape, but this result suggests that the nature of the fitness landscape may actually be changing. For example, larval parasitoids could be driving selection on Platygaster to be very efficient at foraging, which will dampen once this pressure is removed, and then could also dampen the selection acting on the galling herbivore.
```{r Selection on Platygaster Traits, cache=TRUE}

## Subset the data to analyse change in gall phenotypes associated with Platygaster
platy_selection_df <- gall_selection.df %>%
  filter(egg_parasitoid > 0) 
platy_selection_df$Foodweb <- relevel(factor(platy_selection_df$Foodweb), ref = "Simple") # this represents the baseline or absence of selection by larval parasitoids

## Linear mixed models of linear selection differentials (change in mean phenotype)
platy_Diam <- lmer(sc.Diam ~ Foodweb + (1|Genotype/Plant_Position/Gall_Number), platy_selection_df)

platy_Clutch <- lmer(sc.log.Clutch ~ Foodweb + (1|Genotype/Plant_Position), platy_selection_df)

platy_Pref <- lmer(sc.sqrt.Pref ~ Foodweb + (1|Genotype), platy_selection_df)

## Levene's test for quadratic selection differentials (change in phenotypic variance)
# Note that this result should be interepreted cautiously since we cannot account for non-independence due to plant genotype, plant ID, or gall ID
platy_Diam_levene <- leveneTest(sc.Diam ~ Foodweb, platy_selection_df)
platy_Clutch_levene <- leveneTest(sc.log.Clutch ~ Foodweb, platy_selection_df)
platy_Pref_levene <- leveneTest(sc.sqrt.Pref ~ Foodweb, platy_selection_df)
```

```{r Levene tests}
platy_Diam_levene
platy_Clutch_levene
platy_Pref_levene
```
```{r}
car::Anova(platy_Diam, test="F")
car::Anova(platy_Clutch, test="F")
car::Anova(platy_Pref, test="F")
```


```{r Plot models of Platygaster selection differentials, echo=FALSE}
visreg_platy_Diam <- visreg(platy_Diam, xvar="Foodweb", gg=TRUE) + ylab("Chamber diameter (SD)") + xlab("")
visreg_platy_Clutch <- visreg(platy_Clutch, xvar="Foodweb", gg=TRUE) + ylab("Clutch size (SD)") + xlab("")
visreg_platy_Pref <- visreg(platy_Pref, xvar="Foodweb", gg=TRUE) + ylab("Female preference (SD)") + xlab("")

plot_grid(visreg_platy_Diam, visreg_platy_Clutch, visreg_platy_Pref, align="hv", ncol=3)
```


```{r Calculate Selection Differentials for Platygaster, cache=TRUE, include=FALSE, eval=FALSE}

## Calculation linear selection differentials
boot_platy_Diam <- bootMer(platy_Diam, FUN = fixef, nsim=n_boots_analysis, parallel="multicore", ncpus=32)
tidy_platy_Diam <- tidy(boot_platy_Diam, conf.int=T) %>% filter(term=="FoodwebComplex") %>% mutate(term="Diam")

boot_platy_Clutch <- bootMer(platy_Clutch, FUN = fixef, nsim=n_boots_analysis, parallel="multicore", ncpus=32)
tidy_platy_Clutch <- tidy(boot_platy_Clutch, conf.int=T) %>% filter(term=="FoodwebComplex") %>% mutate(term="Clutch")

boot_platy_Pref <- bootMer(platy_Pref, FUN = fixef, nsim=n_boots_analysis, parallel="multicore", ncpus=32)
tidy_platy_Pref <- tidy(boot_platy_Pref, conf.int=T) %>% filter(term=="FoodwebComplex") %>% mutate(term="Pref")

platy_linear_selection <- bind_rows(tidy_platy_Diam, tidy_platy_Clutch, tidy_platy_Pref) %>% select(Term=term, Estimate=statistic, `2.5%`=conf.low, `97.5%`=conf.high)
platy_linear_selection$Significance <- c("NS","NS","P < 0.05")

## Calculate quadratic selection differentials
# statistical significance is based on Levene's test of homogeneity of variances
platy_quadratic_selection <- platy_selection_df %>%
  group_by(Foodweb) %>%
  summarise_at(c("sc.Diam","sc.log.Clutch","sc.sqrt.Pref"), var) %>%
  gather(key = Term, value = Variance, -Foodweb) %>%
  spread(Foodweb, Variance) %>%
  mutate(Estimate = Complex - Simple) %>%
  select(Term, Estimate)
platy_quadratic_selection$Term <- c("Diam^2","Pref^2","Clutch^2")
platy_quadratic_selection$Significance <- c("NS","P < 0.05","NS")
```

```{r Table of Platygaster selection differentials, echo=FALSE, eval=FALSE}
platy_selection_differentials <- bind_rows(platy_linear_selection, platy_quadratic_selection)

knitr::kable(platy_selection_differentials, caption="Table of selection differentials acting on the egg parasitoid Platygaster")
```

```{r Get Gall Diameter Relative Fitness Landscape, cache=TRUE, include=FALSE}

newdata_Diam <- bind_rows(
  expand.grid(Foodweb = "Complex", sc.Diam = seq(-1,1,length.out=1000), sc.log.Clutch = 0, sc.sqrt.Pref = 0),
  expand.grid(Foodweb = "Simple", sc.Diam = seq(-1,1,length.out=1000), sc.log.Clutch = 0, sc.sqrt.Pref = 0))

RF_Diam <- bootstrap_fitness(
  logistic_model = model_2, #quad_control, 
  #fixed_effects = "~ sc.Diam + sc.log.Clutch + sc.sqrt.Pref + I(sc.Diam^2) + I(sc.log.Clutch^2) + I(sc.sqrt.Pref^2)",
  newdata = newdata_Diam,
  bootstraps=n_boots_plots)

# Control ----
#RF_control_gall_size <- bootstrap_fitness(
#  logistic_model = focus_nonlinear_foodweb_glmer, #quad_control, 
  #fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2)",
#  newdata = expand.grid(
#     sc.gall_size = seq(-1,1,length.out=1000), 
#     sc.log.clutch_size = 0,
#     sc.log1p.female_preference = 0),
#  bootstraps=n_boots_plots)


# Treatment ----
#RF_treatment_gall_size <- bootstrap_fitness(
#  logistic_model = focus_nonlinear_foodweb_glmer, #quad_treatment, 
  #fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2)",
#  newdata = expand.grid(
#     sc.gall_size = seq(-1,1,length.out=1000),
#     sc.log.clutch_size = 0,
#     sc.log1p.female_preference = 0),
#  bootstraps=n_boots_plots)
```

```{r Get Clutch Size Fitness Landscape, cache=TRUE, include=FALSE}
newdata_Clutch <- bind_rows(
  expand.grid(Foodweb = "Complex", sc.Diam = 0, sc.log.Clutch = seq(-1,1,length.out=1000), sc.sqrt.Pref = 0),
  expand.grid(Foodweb = "Simple", sc.Diam = 0, sc.log.Clutch = seq(-1,1,length.out=1000), sc.sqrt.Pref = 0))

RF_Clutch <- bootstrap_fitness(
  logistic_model = model_2, #quad_control, 
  #fixed_effects = "~ sc.Diam + sc.log.Clutch + sc.sqrt.Pref + I(sc.Diam^2) + I(sc.log.Clutch^2) + I(sc.sqrt.Pref^2)",
  newdata = newdata_Clutch,
  bootstraps=n_boots_plots)

# Control ----
#RF_control_clutch_size <- bootstrap_fitness(
#  logistic_model = model_2, #quad_control, 
  #fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2)",
#  newdata = expand.grid(
#     sc.gall_size = 0,
#     sc.log.clutch_size = seq(-1,1,length.out=1000),
#     sc.log1p.female_preference = 0),
#  bootstraps=n_boots_plots)

# Treatment ----
#RF_treatment_clutch_size <- bootstrap_fitness(
#  logistic_model = model_2, #quad_treatment, 
  #fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2)",
#  newdata = expand.grid(
#     sc.gall_size = 0,
#     sc.log.clutch_size = seq(-1,1,length.out=1000),
#     sc.log1p.female_preference = 0),
#  bootstraps=n_boots_plots)
```

```{r Get Female Preference Fitness Landscape, cache=TRUE, include=FALSE}

newdata_Pref <- bind_rows(
  expand.grid(Foodweb = "Complex", sc.Diam = 0, sc.log.Clutch = 0, sc.sqrt.Pref = seq(-1,1,length.out=1000)),
  expand.grid(Foodweb = "Simple", sc.Diam = 0, sc.log.Clutch = 0, sc.sqrt.Pref = seq(-1,1,length.out=1000)))

RF_Pref <- bootstrap_fitness(
  logistic_model = model_2, #quad_control, 
  #fixed_effects = "~ sc.Diam + sc.log.Clutch + sc.sqrt.Pref + I(sc.Diam^2) + I(sc.log.Clutch^2) + I(sc.sqrt.Pref^2)",
  newdata = newdata_Pref,
  bootstraps=n_boots_plots)


# Control ----
#RF_control_female_preference <- bootstrap_fitness(
#  logistic_model = focus_nonlinear_foodweb_glmer, #quad_control, 
  #fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2)",
#  newdata = expand.grid(
#     sc.gall_size = 0,
#     sc.log.clutch_size = 0, 
#     sc.log1p.female_preference = seq(-1,1,length.out=1000)), 
#  bootstraps=n_boots_plots)

# Treatment ----
#RF_treatment_female_preference <- bootstrap_fitness(
#  logistic_model = focus_nonlinear_foodweb_glmer, #quad_treatment, 
  #fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2)",
#  newdata = expand.grid(
#     sc.gall_size = 0,
#     sc.log.clutch_size = 0,
#     sc.log1p.female_preference = seq(-1,1,length.out=1000)), 
#  bootstraps=n_boots_plots)

```


```{r Get Clutch Size x Female Preference Landscape, cache=TRUE, include=FALSE}

newdata_Clutch.Pref <- bind_rows(
  expand.grid(Foodweb = "Complex", sc.Diam = 0, sc.log.Clutch = seq(-1,1,length.out=1000), sc.sqrt.Pref = seq(-1,1,length.out=1000)),
  expand.grid(Foodweb = "Simple", sc.Diam = 0, sc.log.Clutch = seq(-1,1,length.out=1000), sc.sqrt.Pref = seq(-1,1,length.out=1000)))

RF_Clutch.Pref <- bootstrap_fitness(
  logistic_model = model_2, #quad_control, 
  #fixed_effects = "~ sc.Diam + sc.log.Clutch + sc.sqrt.Pref + I(sc.Diam^2) + I(sc.log.Clutch^2) + I(sc.sqrt.Pref^2)",
  newdata = newdata_Clutch.Pref,
  bootstraps=NULL)

# Control ----
#RF_control_clutch.x.preference <- bootstrap_fitness(
#  logistic_model = focus_nonlinear_foodweb_glmer, #corr_control, 
  #fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2) + sc.gall_size:sc.log.clutch_size + sc.gall_size:sc.log1p.female_preference + sc.log.clutch_size:sc.log1p.female_preference",
#  newdata = expand.grid(
#     sc.gall_size = 0,
#     sc.log.clutch_size = seq(-1,1,length.out=1000), 
#     sc.log1p.female_preference = seq(-1,1,length.out=1000)), 
#  bootstraps=NULL)

# Treatment ----
#RF_treatment_clutch.x.preference <- bootstrap_fitness(
#  logistic_model = focus_nonlinear_foodweb_glmer, #corr_treatment, 
  #fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2) + sc.gall_size:sc.log.clutch_size + sc.gall_size:sc.log1p.female_preference + sc.log.clutch_size:sc.log1p.female_preference",
#  newdata = expand.grid(
#     sc.gall_size = 0,
#     sc.log.clutch_size = seq(-1,1,length.out=1000),
#     sc.log1p.female_preference = seq(-1,1,length.out=1000)), 
#  bootstraps=NULL)
```


```{r Get Gall Diameter x Clutch Size Landscape, cache=TRUE, include=FALSE}

newdata_Diam.Clutch <- bind_rows(
  expand.grid(Foodweb = "Complex", sc.Diam = seq(-1,1,length.out=1000), sc.log.Clutch = seq(-1,1,length.out=1000), sc.sqrt.Pref = 0),
  expand.grid(Foodweb = "Simple", sc.Diam = seq(-1,1,length.out=1000), sc.log.Clutch = seq(-1,1,length.out=1000), sc.sqrt.Pref=0))

RF_Diam.Clutch <- bootstrap_fitness(
  logistic_model = model_2, #quad_control, 
  #fixed_effects = "~ sc.Diam + sc.log.Clutch + sc.sqrt.Pref + I(sc.Diam^2) + I(sc.log.Clutch^2) + I(sc.sqrt.Pref^2)",
  newdata = newdata_Diam.Clutch,
  bootstraps=NULL)

# Control ----
#RF_control_size.x.clutch <- bootstrap_fitness(
#  logistic_model = focus_nonlinear_foodweb_glmer, #corr_control, 
  #fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2) + sc.gall_size:sc.log.clutch_size + sc.gall_size:sc.log1p.female_preference + sc.log.clutch_size:sc.log1p.female_preference",
 # newdata = expand.grid(
  #   sc.gall_size = seq(-1,1,length.out=1000),
   #  sc.log.clutch_size = seq(-1,1,length.out=1000), 
    # sc.log1p.female_preference = 0), 
  #bootstraps=NULL)

# Treatment ----
#RF_treatment_size.x.clutch <- bootstrap_fitness(
#  logistic_model = focus_nonlinear_foodweb_glmer, #corr_treatment, 
  #fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2) + sc.gall_size:sc.log.clutch_size + sc.gall_size:sc.log1p.female_preference + sc.log.clutch_size:sc.log1p.female_preference",
 # newdata = expand.grid(
  #   sc.gall_size = seq(-1,1,length.out=1000),
   #  sc.log.clutch_size = seq(-1,1,length.out=1000),
    # sc.log1p.female_preference = 0), 
  #bootstraps=NULL)
```

```{r Get Gall Diameter x Female Preference Landscape, cache=TRUE, include=FALSE}

newdata_Diam.Pref <- bind_rows(
  expand.grid(Foodweb = "Complex", sc.Diam = seq(-1,1,length.out=1000), sc.log.Clutch = 0, sc.sqrt.Pref = seq(-1,1,length.out=1000)),
  expand.grid(Foodweb = "Simple", sc.Diam = seq(-1,1,length.out=1000), sc.log.Clutch = 0, sc.sqrt.Pref = seq(-1,1,length.out=1000)))

RF_Diam.Pref <- bootstrap_fitness(
  logistic_model = model_2, #quad_control, 
  #fixed_effects = "~ sc.Diam + sc.log.Clutch + sc.sqrt.Pref + I(sc.Diam^2) + I(sc.log.Clutch^2) + I(sc.sqrt.Pref^2)",
  newdata = newdata_Diam.Pref,
  bootstraps=NULL)

# Control ----
#RF_control_size.x.preference <- bootstrap_fitness(
#  logistic_model = focus_nonlinear_foodweb_glmer, #corr_control, 
  #fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2) + sc.gall_size:sc.log.clutch_size + sc.gall_size:sc.log1p.female_preference + sc.log.clutch_size:sc.log1p.female_preference",
#  newdata = expand.grid(
 #    sc.gall_size = seq(-1,1,length.out=1000),
  #   sc.log.clutch_size = 0, 
   #  sc.log1p.female_preference = seq(-1,1,length.out=1000)), 
  ##bootstraps=NULL)

# Treatment ----
#RF_treatment_size.x.preference <- bootstrap_fitness(
#  logistic_model = focus_nonlinear_foodweb_glmer, #corr_treatment, 
  #fixed_effects = "~ sc.gall_size + sc.log.clutch_size + sc.log1p.female_preference + I(sc.gall_size^2) + I(sc.log.clutch_size^2) + I(sc.log1p.female_preference^2) + sc.gall_size:sc.log.clutch_size + sc.gall_size:sc.log1p.female_preference + sc.log.clutch_size:sc.log1p.female_preference",
 # newdata = expand.grid(
  #   sc.gall_size = seq(-1,1,length.out=1000),
   #  sc.log.clutch_size = 0,
    # sc.log1p.female_preference = seq(-1,1,length.out=1000)), 
  #bootstraps=NULL)
```


```{r Fitness Landscape Plot Helpers, include=FALSE}



## Scale relative fitness across plots ----

# 1D
#RF_gradient_range <- bind_rows(RF_treatment_gall_size$relative_fitness, RF_control_gall_size$relative_fitness,
#          RF_treatment_clutch_size$relative_fitness, RF_control_clutch_size$relative_fitness,
#          RF_treatment_female_preference$relative_fitness, RF_control_female_preference$relative_fitness) %>%
#  select(-sc.log.clutch_size, -sc.log1p.female_preference) %>%
#  gather(ID, relative_fitness, -sc.gall_size) %>%
#  mutate(ID_group = ifelse(ID == "average", "average", "replicate")) %>% 
#  summarise(min = min(relative_fitness), max = max(relative_fitness))
#RF_gradient_scale <- c(0,0.5,1,1.5,2) #,2.5) # adjusted based on range

# 2D
#RF_range <- bind_rows(RF_treatment_clutch.x.preference$relative_fitness, RF_control_clutch.x.preference$relative_fitness,
#          RF_treatment_size.x.clutch$relative_fitness, RF_control_size.x.clutch$relative_fitness,
#          RF_treatment_size.x.preference$relative_fitness, RF_control_size.x.preference$relative_fitness) %>%
#  summarise(min = min(average), max = max(average))

## Scale absolute fitness across plots ----

# 1D
AF_gradient_scale <- c(0,0.25,0.5,0.75,1) # adjusted based on range

# 2D
AF_range <- bind_rows(RF_Clutch.Pref$absolute_fitness, RF_Diam.Clutch$absolute_fitness, RF_Diam.Pref$absolute_fitness) %>%
  summarise(min = min(average), max = max(average))
```

```{r Plot Univariate Landscapes, include=FALSE}
uni_breaks <- c(0.1,0.5,1.0)

# Gall size 
AF_uni_Diam <- RF_Diam$absolute_fitness %>% #bind_rows(mutate(RF_treatment_gall_size$absolute_fitness, Food_Web = "Simple"), 
          #mutate(RF_control_gall_size$absolute_fitness, Food_Web = "Complex")) %>%
  select(-sc.log.Clutch, -sc.sqrt.Pref) %>%
  gather(ID, absolute_fitness, -sc.Diam, -Foodweb) %>%
  mutate(ID_group = ifelse(ID == "average", "average", "replicate")) %>% 
  ggplot(., aes(x=sc.Diam, y=absolute_fitness, group=interaction(ID,Foodweb), color=Foodweb, alpha=ID_group, size=ID_group)) +
  geom_line() +
  scale_alpha_manual(values=c(1,0.2), guide=FALSE) +
  scale_size_manual(values=c(1.5,0.25), guide=FALSE) +
  xlab("Chamber diameter (SDs)") +
  ylab("Mean larva survival") +
  scale_color_manual(values = treatment_colors, name = "Food web") +
  scale_x_continuous(breaks=c(-1,-0.5,0,0.5,1), labels = c(-1,-0.5,0,0.5,1)) +
  scale_y_log10(breaks=uni_breaks, labels=uni_breaks) + annotation_logticks(sides = "l")+
  coord_cartesian(ylim=c(0.05,1)) # c(0.07,1)
#AF_uni_size
  #scale_y_continuous(breaks = AF_gradient_scale, limits = c(min(AF_gradient_scale), max(AF_gradient_scale)), trans = "log")

# Clutch size
AF_uni_Clutch <- RF_Clutch$absolute_fitness %>% #bind_rows(mutate(RF_treatment_clutch_size$absolute_fitness, Food_Web = "Simple"), 
          #mutate(RF_control_clutch_size$absolute_fitness, Food_Web = "Complex")) %>%
  select(-sc.Diam, -sc.sqrt.Pref) %>%
  gather(ID, absolute_fitness, -sc.log.Clutch, -Foodweb) %>%
  mutate(ID_group = ifelse(ID == "average", "average", "replicate")) %>% 
  ggplot(., aes(x=sc.log.Clutch, y=absolute_fitness, group=interaction(ID,Foodweb), color=Foodweb, alpha=ID_group, size=ID_group)) +
  geom_line() +
  scale_alpha_manual(values=c(1,0.2), guide=FALSE) +
  scale_size_manual(values=c(1.5,0.25), guide=FALSE) +
  xlab("Clutch size (SDs)") +
  ylab("Mean larva survival") +
  scale_color_manual(values = treatment_colors, name = "Food web") +
  scale_x_continuous(breaks=c(-1,-0.5,0,0.5,1), labels = c(-1,-0.5,0,0.5,1)) +
  scale_y_log10(breaks=uni_breaks, labels=uni_breaks) + annotation_logticks(sides = "l") +
  coord_cartesian(ylim=c(0.05,1)) # c(0.07,1)
  #scale_y_continuous(breaks = AF_gradient_scale, limits = c(min(AF_gradient_scale), max(AF_gradient_scale)), trans = "log")

# Female preference
AF_uni_Pref <- RF_Pref$absolute_fitness %>% #bind_rows(mutate(RF_treatment_female_preference$absolute_fitness, Food_Web = "Simple"), 
          #mutate(RF_control_female_preference$absolute_fitness, Food_Web = "Complex")) %>%
  select(-sc.Diam, -sc.log.Clutch) %>%
  gather(ID, absolute_fitness, -sc.sqrt.Pref, -Foodweb) %>%
  mutate(ID_group = ifelse(ID == "average", "average", "replicate")) %>% 
  ggplot(., aes(x=sc.sqrt.Pref, y=absolute_fitness, group=interaction(ID,Foodweb), color=Foodweb, alpha=ID_group, size=ID_group)) +
  geom_line() +
  scale_alpha_manual(values=c(1,0.2), guide=FALSE) +
  scale_size_manual(values=c(1.5,0.25), guide=FALSE) +
  xlab("Female preference (SDs)") +
  ylab("Mean larva survival") +
  scale_color_manual(values = treatment_colors, name = "Food web") +
  scale_x_continuous(breaks=c(-1,-0.5,0,0.5,1), labels = c(-1,-0.5,0,0.5,1)) +
  scale_y_log10(breaks=uni_breaks, labels=uni_breaks) + annotation_logticks(sides = "l") +
  coord_cartesian(ylim=c(0.05,1)) # c(0.07,1)
  #scale_y_continuous(breaks = AF_gradient_scale, limits = c(min(AF_gradient_scale), max(AF_gradient_scale)), trans = "log")
```

```{r Univariate-Fitness-Landscapes, echo=FALSE, fig.cap="Selection gradients acting on gall traits in complex vs. simple food webs. Each panel corresponds to a different gall trait: gall diameter (A); clutch size (B); and female preference (C). Solid lines represent the estimated gradients in complex (orange) and simple (blue) food webs. Transparent lines represent bootstrapped replicates (n=100) to show the uncertainty in estimated gradients. Note that only 100 bootstraps are displayed here, but that inferences are based on 1,000 bootstrapped samples."}

# Get legend
AF_uni_legend <- get_legend(AF_uni_Diam)

# Make plots
AF_uni_plots <- plot_grid(AF_uni_Diam + theme(legend.position = "none", 
                                              axis.text.x = element_text(size=10),
                                              axis.title.x = element_text(size=11)), 
                       AF_uni_Clutch + theme(legend.position = "none",
                                             axis.title.y = element_blank(), 
                                             #axis.text.y = element_blank(),
                                             axis.text.x = element_text(size=10),
                                             axis.title.x = element_text(size=11)),
                       AF_uni_Pref + theme(legend.position = "none", 
                                           axis.title.y = element_blank(), 
                                           #axis.text.y = element_blank(), 
                                           axis.text.x = element_text(size=10),
                                           axis.title.x = element_text(size=11)),
                       labels = "AUTO", ncol = 3, align='hv')

AF_gradients <- plot_grid(AF_uni_plots, AF_uni_legend, ncol = 2, rel_widths = c(1,0.2)) #ggdraw(AF_uni_plots) + draw_grob(AF_uni_legend, x = 0.7, y=-0.2) # draw_grob(AF_uni_legend, x = 0.8, y=0)
AF_gradients
#AF_uni_plots
# save_plot("FL_1D.pdf", AF_uni_plots, base_height = 6.5, base_width = 8)
#save_plot("../figures/fitness_landscapes_1D.png", AF_gradients)#, base_height=6, base_width = 8)
```

```{r Plot Multivariate Fitness Landscape, include=FALSE}

my_breaks <- c(0.2,0.4,0.6,0.8)

# Size x Clutch
AF_plot_Diam.Clutch <- RF_Diam.Clutch$absolute_fitness %>% 
  ggplot(., aes(x=sc.Diam, y=sc.log.Clutch)) +
  geom_raster(aes(fill=average)) +
  facet_wrap(~Foodweb) +
  xlab("Gall diameter (SDs)") +
  ylab("Clutch size (SDs)") +
  scale_x_continuous(labels = c(-1,-0.5,0,0.5,1)) +
  scale_y_continuous(labels = c(-1,-0.5,0,0.5,1)) +
  scale_fill_viridis(name = "Mean larva\nsurvival", trans="log", breaks = my_breaks, labels = my_breaks, limits = c(AF_range$min, AF_range$max))#, 

# Size x Preference
AF_plot_Diam.Pref <- RF_Diam.Pref$absolute_fitness %>% 
  ggplot(., aes(x=sc.Diam, y=sc.sqrt.Pref)) +
  geom_raster(aes(fill=average)) +
  facet_wrap(~Foodweb) +
  xlab("Chamber diameter (SDs)") +
  ylab("Female preference (SDs)") +
  scale_x_continuous(labels = c(-1,-0.5,0,0.5,1)) +
  scale_y_continuous(labels = c(-1,-0.5,0,0.5,1)) +
  scale_fill_viridis(name = "Mean larva\nsurvival", trans="log", breaks = my_breaks, labels = my_breaks, limits = c(AF_range$min, AF_range$max))#, 

# Clutch x Preference
AF_plot_Clutch.Pref <- RF_Clutch.Pref$absolute_fitness %>%
  ggplot(., aes(x=sc.sqrt.Pref, y=sc.log.Clutch)) +
  geom_raster(aes(fill=average)) +
  facet_wrap(~Foodweb) +
  xlab("Female preference (SDs)") +
  ylab("Clutch size (SDs)") +
  scale_x_continuous(labels = c(-1,-0.5,0,0.5,1)) +
  scale_y_continuous(labels = c(-1,-0.5,0,0.5,1)) +
  scale_fill_viridis(name = "Mean larva\nsurvival", trans="log", breaks = my_breaks, labels = my_breaks, limits = c(AF_range$min, AF_range$max)) 
```

```{r Multivariate-Fitness-Landscapes, echo=FALSE, fig.cap="Fitness landscapes of gall traits in complex vs. simple food webs. Each panel corresponds to a different combination of traits: clutch size and gall diameter (A); clutch size and female preference (B); female preference and gall diameter (C). Note that traits for all plots range 1 SD below and above the mean (=0)."}
# Get legend
AF_landscape_legend <- get_legend(AF_plot_Diam.Pref)

# Format plots
AF_landscape_plots <- plot_grid(
  AF_plot_Diam.Clutch + theme(legend.position = "none", 
                              axis.title.y = element_text(size=11),
                              axis.title.x = element_blank(),
                              axis.text = element_text(size=10)),
  AF_plot_Clutch.Pref + theme(legend.position = "none", 
                              axis.title.y = element_blank(), 
                              axis.text = element_text(size=10), 
                              axis.title.x = element_text(size=11)),
  AF_plot_Diam.Pref + theme(legend.position = "none", 
                            axis.text = element_text(size=10),
                            axis.title = element_text(size=11)), 
  nrow=2, align="hv", labels = "AUTO")
AF_landscape_2d <- ggdraw(AF_landscape_plots) + draw_grob(AF_landscape_legend, x = 0.7, y=-0.2)
AF_landscape_2d
#save_plot("AF_landscapes_2d.png", AF_landscape_2d, base_height=6, base_width = 8)
#save_plot("../figures/fitness_landscapes_2D.png", AF_landscape_2d)#, base_height=6, base_width = 8)
```

Note that equation 3 in Phillips and Arnold 1998 is good justification for why quadratic selection cofficients should be multiplied by two (but not correlational ones?)

The G-matrix is essentially a scalar. For my data, since there is no correlational selection, it doesn't matter if there is genetic covariance between the traits, as this will not effect the change in genetic covariances within a generation (because there is no selection). Also, the G_matrix does not qualitatively alter the conclusions that there will be a decrease in additive genetic variance in gall diameter due to the strong directional selection; however, there will be an increase in the additive genetic variance in female preference. Since this is an experiment, we can assume that the G-matrix is the same between treatments

Remember that the diagonals refer to additive genetic CO-variances. Thus, positive or negative values for delta_G give insight to whether selection will act to integrate traits (positive covariance) or create trade-offs (negative covariance).

Assuming that there is positive additive genetic variance and co-variance in these traits (i.e. all values of G-matrix are positive), then the curvature of the fitness landscape can give insight to qualitative changes in the G matrix. This is because the G-matrix acts as a scalar of changes in the fitness landscape.

Create a simple rule. If the confidence interval of the selection gradient overlaps zero, then I set it to zero. Otherwise, I set it to our best estimate of the gradient

```{r Slope and Curvature of the Adaptive Landscape, include=FALSE}

## Create beta-matrix for complex food-web treatment
complex_betas_df <- bias.adj_selection_gradients %>%
  filter(`Food web`=="Complex", term_ord %in% c("Pref","Clutch") | term_ord == "Diam" & adjusted=="Yes") %>% 
  select(term_ord, gradient, low=`2.5%`, high=`97.5%`) %>% data.frame()
rownames(complex_betas_df) <- complex_betas_df$term_ord

complex_betas <- matrix(nrow = 3, ncol = 1, dimnames = list(c("Diam","Clutch","Pref"), c("")))
complex_betas["Diam",] <- ifelse(complex_betas_df["Diam","low"]*complex_betas_df["Diam","high"] > 0, 
                                        complex_betas_df["Diam","gradient"], 0)
complex_betas["Clutch",] <- ifelse(complex_betas_df["Clutch","low"]*complex_betas_df["Clutch","high"] > 0,
                                            complex_betas_df["Clutch","gradient"], 0)
complex_betas["Pref",] <- ifelse(complex_betas_df["Pref","low"]*complex_betas_df["Pref","high"] > 0,
                                        complex_betas_df["Pref","gradient"], 0)
complex_betas <- round(complex_betas, 2)

## Create gamma-matrix for complex food-web treatment
complex_gammas_df <- bias.adj_selection_gradients %>%
  filter(`Food web`=="Complex", term_ord %in% c("Diam^2","Clutch^2","Pref^2","Diam:Clutch","Diam:Pref","Clutch:Pref")) %>% 
  select(term_ord, gradient, low=`2.5%`, high=`97.5%`) %>% data.frame()
rownames(complex_gammas_df) <- complex_gammas_df$term_ord

complex_gammas <- matrix(nrow = 3, ncol = 3, dimnames = list(c("Diam","Clutch","Pref"), c("Diam","Clutch","Pref")))
complex_gammas["Diam","Diam"] <- ifelse(complex_gammas_df["Diam^2","low"]*complex_gammas_df["Diam^2","high"] > 0, 
                                        complex_gammas_df["Diam^2","gradient"], 0)
complex_gammas["Clutch","Clutch"] <- ifelse(complex_gammas_df["Clutch^2","low"]*complex_gammas_df["Clutch^2","high"] > 0,
                                            complex_gammas_df["Clutch^2","gradient"], 0)
complex_gammas["Pref","Pref"] <- ifelse(complex_gammas_df["Pref^2","low"]*complex_gammas_df["Pref^2","high"] > 0,
                                        complex_gammas_df["Pref^2","gradient"], 0)
complex_gammas["Diam","Clutch"] <- ifelse(complex_gammas_df["Diam:Clutch","low"]*complex_gammas_df["Diam:Clutch","high"] > 0,
                                          complex_gammas_df["Diam:Clutch","gradient"], 0)
complex_gammas["Clutch","Diam"] <- complex_gammas["Diam","Clutch"]
complex_gammas["Diam","Pref"] <- ifelse(complex_gammas_df["Diam:Pref","low"]*complex_gammas_df["Diam:Pref","high"] > 0,
                                            complex_gammas_df["Diam:Pref","gradient"], 0)
complex_gammas["Pref","Diam"] <- complex_gammas["Diam","Pref"]
complex_gammas["Clutch","Pref"] <- ifelse(complex_gammas_df["Clutch:Pref","low"]*complex_gammas_df["Clutch:Pref","high"] > 0, 
                                        complex_gammas_df["Clutch:Pref","gradient"], 0)
complex_gammas["Pref","Clutch"] <- complex_gammas["Clutch","Pref"]
complex_gammas <- round(complex_gammas, 2)

## Create matrix of Betas in simple food-web treatment
simple_betas_df <- bias.adj_selection_gradients %>%
  filter(`Food web`=="Simple", term_ord %in% c("Pref","Clutch") | term_ord == "Diam" & adjusted=="Yes") %>% 
  select(term_ord, gradient, low=`2.5%`, high=`97.5%`) %>% data.frame()
rownames(simple_betas_df) <- simple_betas_df$term_ord

simple_betas <- matrix(nrow = 3, ncol = 1, dimnames = list(c("Diam","Clutch","Pref"), c("")))
simple_betas["Diam",] <- ifelse(simple_betas_df["Diam","low"]*simple_betas_df["Diam","high"] > 0, 
                                        simple_betas_df["Diam","gradient"], 0)
simple_betas["Clutch",] <- ifelse(simple_betas_df["Clutch","low"]*simple_betas_df["Clutch","high"] > 0,
                                            simple_betas_df["Clutch","gradient"], 0)
simple_betas["Pref",] <- ifelse(simple_betas_df["Pref","low"]*simple_betas_df["Pref","high"] > 0,
                                        simple_betas_df["Pref","gradient"], 0)
simple_betas <- round(simple_betas, 2)

## Create gamma-matrix for simple food-web treatment
simple_gammas_df <- bias.adj_selection_gradients %>%
  filter(`Food web`=="Simple", term_ord %in% c("Diam^2","Clutch^2","Pref^2","Diam:Clutch","Diam:Pref","Clutch:Pref")) %>% 
  select(term_ord, gradient, low=`2.5%`, high=`97.5%`) %>% data.frame()
rownames(simple_gammas_df) <- simple_gammas_df$term_ord

simple_gammas <- matrix(nrow = 3, ncol = 3, dimnames = list(c("Diam","Clutch","Pref"), c("Diam","Clutch","Pref")))
simple_gammas["Diam","Diam"] <- ifelse(simple_gammas_df["Diam^2","low"]*simple_gammas_df["Diam^2","high"] > 0, 
                                        simple_gammas_df["Diam^2","gradient"], 0)
simple_gammas["Clutch","Clutch"] <- ifelse(simple_gammas_df["Clutch^2","low"]*simple_gammas_df["Clutch^2","high"] > 0,
                                            simple_gammas_df["Clutch^2","gradient"], 0)
simple_gammas["Pref","Pref"] <- ifelse(simple_gammas_df["Pref^2","low"]*simple_gammas_df["Pref^2","high"] > 0,
                                        simple_gammas_df["Pref^2","gradient"], 0)
simple_gammas["Diam","Clutch"] <- ifelse(simple_gammas_df["Diam:Clutch","low"]*simple_gammas_df["Diam:Clutch","high"] > 0,
                                          simple_gammas_df["Diam:Clutch","gradient"], 0)
simple_gammas["Clutch","Diam"] <- simple_gammas["Diam","Clutch"]
simple_gammas["Diam","Pref"] <- ifelse(simple_gammas_df["Diam:Pref","low"]*simple_gammas_df["Diam:Pref","high"] > 0,
                                            simple_gammas_df["Diam:Pref","gradient"], 0)
simple_gammas["Pref","Diam"] <- simple_gammas["Diam","Pref"]
simple_gammas["Clutch","Pref"] <- ifelse(simple_gammas_df["Clutch:Pref","low"]*simple_gammas_df["Clutch:Pref","high"] > 0, 
                                        simple_gammas_df["Clutch:Pref","gradient"], 0)
simple_gammas["Pref","Clutch"] <- simple_gammas["Clutch","Pref"]
simple_gammas <- round(simple_gammas, 2)

## Calculate Curvature of the Fitness landscape
complex_curvature <- complex_gammas - complex_betas %*% t(complex_betas)
simple_curvature <- simple_gammas - simple_betas %*% t(simple_betas)
```

## Slope of adaptive landscape

$$\text{Slope} = \beta = \begin{pmatrix} \beta_{diam} \\ \beta_{clutch} \\ \beta_{pref} \end{pmatrix}$$

$$\text{Slope}_{complex} = \begin{pmatrix} `r complex_betas["Diam", ]` \\ `r complex_betas["Clutch", ]` \\ `r complex_betas["Pref", ]` \end{pmatrix}$$
$$\text{Slope}_{simple} =  \begin{pmatrix} `r simple_betas["Diam", ]` \\ `r simple_betas["Clutch", ]` \\ `r simple_betas["Pref", ]` \end{pmatrix}$$

## Curvature of adaptive landscape

$$\text{Curvature} = \gamma - \beta \beta^\text{T}$$

$$\gamma = \begin{pmatrix} \gamma_{diam} & \gamma_{diam,clutch} & \gamma_{diam,pref} \\ \gamma_{clutch,diam} & \gamma_{clutch} & \gamma_{clutch,pref} \\ \gamma_{pref,diam} & \gamma_{pref,clutch} &\gamma_{pref} \end{pmatrix}$$
$$\gamma_{complex} = \begin{pmatrix} `r complex_gammas["Diam","Diam"]` & `r complex_gammas["Diam","Clutch"]` & `r complex_gammas["Diam","Pref"]` \\  `r complex_gammas["Clutch","Diam"]` & `r complex_gammas["Clutch","Clutch"]` & `r complex_gammas["Clutch","Pref"]` \\  `r complex_gammas["Pref","Diam"]` & `r complex_gammas["Pref","Clutch"]` & `r complex_gammas["Pref","Pref"]` \end{pmatrix}$$
$$\gamma_{simple} = \begin{pmatrix} `r simple_gammas["Diam","Diam"]` & `r simple_gammas["Diam","Clutch"]` & `r simple_gammas["Diam","Pref"]` \\  `r simple_gammas["Clutch","Diam"]` & `r simple_gammas["Clutch","Clutch"]` & `r simple_gammas["Clutch","Pref"]` \\  `r simple_gammas["Pref","Diam"]` & `r simple_gammas["Pref","Clutch"]` & `r simple_gammas["Pref","Pref"]` \end{pmatrix}$$


$$\text{Curvature}_{complex} = \begin{pmatrix} `r complex_curvature["Diam","Diam"]` & `r complex_curvature["Diam","Clutch"]` & `r complex_curvature["Diam","Pref"]` \\  `r complex_curvature["Clutch","Diam"]` & `r complex_curvature["Clutch","Clutch"]` & `r complex_curvature["Clutch","Pref"]` \\  `r complex_curvature["Pref","Diam"]` & `r complex_curvature["Pref","Clutch"]` & `r complex_curvature["Pref","Pref"]` \end{pmatrix}$$

$$\text{Curvature}_{simple} = \begin{pmatrix} `r simple_curvature["Diam","Diam"]` & `r simple_curvature["Diam","Clutch"]` & `r simple_curvature["Diam","Pref"]` \\  `r simple_curvature["Clutch","Diam"]` & `r simple_curvature["Clutch","Clutch"]` & `r simple_curvature["Clutch","Pref"]` \\  `r simple_curvature["Pref","Diam"]` & `r simple_curvature["Pref","Clutch"]` & `r simple_curvature["Pref","Pref"]` \end{pmatrix}$$

## Observed phenotypic variance-covariance matrix

```{r Observe P matrix, include=FALSE}

## setup P-matrix
P_matrix <- matrix(1, nrow=3, ncol=3, dimnames = list(c("Diam","Clutch","Pref"),c("Diam","Clutch","Pref")))

## confirm that variance of phenotypic traits = 1
P_matrix["Diam","Diam"] <- var(gall_selection.df$sc.Diam)
P_matrix["Clutch","Clutch"] <- var(gall_selection.df$sc.log.Clutch)
P_matrix["Pref","Pref"] <- var(gall_selection.df$sc.sqrt.Pref)

## calculate covariance between phenotypic traits
P_matrix["Diam","Clutch"] <- with(gall_selection.df, cov(sc.Diam, sc.log.Clutch))
P_matrix["Clutch","Diam"] <- P_matrix["Diam","Clutch"]

P_matrix["Diam","Pref"] <- with(gall_selection.df, cov(sc.Diam, sc.sqrt.Pref))
P_matrix["Pref","Diam"] <- P_matrix["Diam","Pref"]

P_matrix["Clutch","Pref"] <- with(gall_selection.df, cov(sc.log.Clutch, sc.sqrt.Pref))
P_matrix["Pref","Clutch"] <- P_matrix["Clutch","Pref"]

heritability <- 0.3 # since all traits are scaled to SD (and variance)=1, then a narrow-sense heritability of 0.3 (which is reasonable) corresponds to an additive genetic variance of 0.3 (Vg = h2 * Vp)

G_matrix <- P_matrix * heritability
```

$$\text{P} = \begin{pmatrix} `r round(P_matrix["Diam","Diam"],2)` & `r round(P_matrix["Diam","Clutch"],2)` & `r round(P_matrix["Diam","Pref"],2)` \\  `r round(P_matrix["Clutch","Diam"],2)` & `r round(P_matrix["Clutch","Clutch"],2)` & `r round(P_matrix["Clutch","Pref"],2)` \\  `r round(P_matrix["Pref","Diam"],2)` & `r round(P_matrix["Pref","Clutch"],2)` & `r round(P_matrix["Pref","Pref"],2)` \end{pmatrix}$$
Note that the variance of each phenotypic trait is standardized to 1. If we assume that each phenotypic trait has a narrow-sense heritability ($h^2$) of `r heritability`, then the additive genetic variance of each trait is equal to its narrow-sense heritability. The resulting G-matrix is:

$$\text{G} = \begin{pmatrix} `r round(G_matrix["Diam","Diam"],2)` & `r round(G_matrix["Diam","Clutch"],2)` & `r round(G_matrix["Diam","Pref"],2)` \\  `r round(G_matrix["Clutch","Diam"],2)` & `r round(G_matrix["Clutch","Clutch"],2)` & `r round(G_matrix["Clutch","Pref"],2)` \\  `r round(G_matrix["Pref","Diam"],2)` & `r round(G_matrix["Pref","Clutch"],2)` & `r round(G_matrix["Pref","Pref"],2)` \end{pmatrix}$$
```{r Change in G-matrices, include=FALSE}
complex_G_matrix <- G_matrix + G_matrix %*% complex_curvature %*% G_matrix
simple_G_matrix <- G_matrix + G_matrix %*% simple_curvature %*% G_matrix
```


# Change in complex G-matrix

$$\text{G}_{complex} = \begin{pmatrix} `r round(complex_G_matrix["Diam","Diam"],3)` & `r round(complex_G_matrix["Diam","Clutch"],3)` & `r round(complex_G_matrix["Diam","Pref"],3)` \\  `r round(complex_G_matrix["Clutch","Diam"],3)` & `r round(complex_G_matrix["Clutch","Clutch"],3)` & `r round(complex_G_matrix["Clutch","Pref"],3)` \\  `r round(complex_G_matrix["Pref","Diam"],3)` & `r round(complex_G_matrix["Pref","Clutch"],3)` & `r round(complex_G_matrix["Pref","Pref"],3)` \end{pmatrix}$$

# Change in simple G-matrix

$$\text{G}_{simple} = \begin{pmatrix} `r round(simple_G_matrix["Diam","Diam"],3)` & `r round(simple_G_matrix["Diam","Clutch"],3)` & `r round(simple_G_matrix["Diam","Pref"],3)` \\  `r round(simple_G_matrix["Clutch","Diam"],3)` & `r round(simple_G_matrix["Clutch","Clutch"],3)` & `r round(simple_G_matrix["Clutch","Pref"],3)` \\  `r round(simple_G_matrix["Pref","Diam"],3)` & `r round(simple_G_matrix["Pref","Clutch"],3)` & `r round(simple_G_matrix["Pref","Pref"],3)` \end{pmatrix}$$

```{r Evo dynamics derived from observed phenotypic variance-covariance, include=FALSE, eval=FALSE}

# initial trait values
z_initial <- matrix(0, nrow=3, ncol=1, dimnames = list(c("Diam","Clutch","Pref")))

# checks to see whether disruptive selection on preference is driving the relationship
alt_complex_gammas <- complex_gammas
alt_complex_gammas["Pref","Pref"] <- 0

# basically, controls for differences in mean fitness
alt_simple_betas <- complex_betas 
alt_simple_betas["Clutch", ] <- simple_betas["Clutch", ] * simple_mean_fitness / complex_mean_fitness # best estimate on complex mean fitness scale, need to confirm...

# simulate evolutionary dynamics
complex_evo_dynamics <- evolutionary_dynamics(betas = complex_betas, 
                                              gammas = complex_gammas, 
                                              G_0 = G_matrix,
                                              z_0 = z_initial,
                                              t = n_evo_sims)

simple_evo_dynamics <- evolutionary_dynamics(betas = simple_betas, 
                                             gammas = simple_gammas, 
                                             G_0 = G_matrix,
                                             z_0 = z_initial,
                                             t = n_evo_sims)

## Tidy simulations
complex_z_feasible <- mutate(tidy_evo_sims(complex_evo_dynamics), Foodweb="Complex")

simple_z_feasible <- mutate(tidy_evo_sims(simple_evo_dynamics), Foodweb="Simple")
```

```{r altered parameters, include=FALSE, eval=FALSE}
complex_betas
```


## Walk across the adaptive landscape

```{r Evo-Sim-Hyp-G, include=FALSE, eval=FALSE, echo=FALSE, fig.cap="Evolutionary simulation of a hypothetical G-matrix"}

# Make plots
evosim_AF_plot_Diam.Clutch <- AF_plot_Diam.Clutch +
  geom_line(data=bind_rows(complex_z_feasible, simple_z_feasible), aes(x=Diam, y=Clutch)) +
  geom_point(data=bind_rows(complex_z_feasible, simple_z_feasible), aes(x=Diam, y=Clutch))
  
evosim_AF_plot_Clutch.Pref <- AF_plot_Clutch.Pref +
  geom_line(data=bind_rows(complex_z_feasible, simple_z_feasible), aes(x=Pref, y=Clutch)) +
  geom_point(data=bind_rows(complex_z_feasible, simple_z_feasible), aes(x=Pref, y=Clutch))
  
evosim_AF_plot_Diam.Pref <-  AF_plot_Diam.Pref +
  geom_line(data=bind_rows(complex_z_feasible, simple_z_feasible), aes(x=Diam, y=Pref)) +
  geom_point(data=bind_rows(complex_z_feasible, simple_z_feasible), aes(x=Diam, y=Pref))

# Get legend
evosim_AF_landscape_legend <- get_legend(evosim_AF_plot_Diam.Pref)

# Format plots
evosim_AF_landscape_plots <- plot_grid(
  evosim_AF_plot_Diam.Clutch + theme(legend.position = "none", 
                              axis.title.y = element_text(size=11),
                              axis.title.x = element_blank(),
                              axis.text = element_text(size=10)),
 evosim_AF_plot_Clutch.Pref + theme(legend.position = "none", 
                              axis.title.y = element_blank(), 
                              axis.text = element_text(size=10), 
                              axis.title.x = element_text(size=11)),
  evosim_AF_plot_Diam.Pref + theme(legend.position = "none", 
                            axis.text = element_text(size=10),
                            axis.title = element_text(size=11)), 
  nrow=2, align="hv", labels = "AUTO")
evosim_AF_landscape_2d <- ggdraw(evosim_AF_landscape_plots) + draw_grob(evosim_AF_landscape_legend, x = 0.7, y=-0.2)
evosim_AF_landscape_2d
```


## Compare evolvabilities of hypothetical G-matrix over time

Since my covariance is standardized, it should be okay to calculate the mean squared correlation as an overall measure of trait integration.

```{r Compare changes in hypothetical G-matric over time, echo=FALSE, include=FALSE, eval=FALSE}
last(complex_z_feasible$Time)/last(simple_z_feasible$Time)

complex_evolvability <- c()
complex_conditional.evolvability <- c()
complex_constraints <- c()
complex_autonomy <- c()
complex_MeanSquaredCorrelation <- c()
for(i in 1:last(complex_z_feasible$Time)){
  complex_evolvability[i] <- MeanMatrixStatistics(complex_evo_dynamics$G[[i]])["evolvability"] 
  complex_conditional.evolvability[i] <- MeanMatrixStatistics(complex_evo_dynamics$G[[i]])["conditional.evolvability"]
  complex_constraints[i] <- MeanMatrixStatistics(complex_evo_dynamics$G[[i]])["constraints"]
  complex_autonomy[i] <- MeanMatrixStatistics(complex_evo_dynamics$G[[i]])["autonomy"]
  complex_MeanSquaredCorrelation[i] <- MeanMatrixStatistics(complex_evo_dynamics$G[[i]])["MeanSquaredCorrelation"]
}

simple_evolvability <- c()
simple_conditional.evolvability <- c()
simple_constraints <- c()
simple_autonomy <- c()
simple_MeanSquaredCorrelation <- c()
for(i in 1:last(simple_z_feasible$Time)){
  simple_evolvability[i] <- MeanMatrixStatistics(simple_evo_dynamics$G[[i]])["evolvability"] 
  simple_conditional.evolvability[i] <- MeanMatrixStatistics(simple_evo_dynamics$G[[i]])["conditional.evolvability"]
  simple_constraints[i] <- MeanMatrixStatistics(simple_evo_dynamics$G[[i]])["constraints"] 
  simple_autonomy[i] <- MeanMatrixStatistics(simple_evo_dynamics$G[[i]])["autonomy"]
  simple_MeanSquaredCorrelation[i] <- MeanMatrixStatistics(simple_evo_dynamics$G[[i]])["MeanSquaredCorrelation"]
}

gather_G_matrix_data <- bind_rows(
  data.frame(Time=1:last(complex_z_feasible$Time), Foodweb="Complex", 
             evolvability=complex_evolvability,
             conditional.evolvability=complex_conditional.evolvability,
             constraints=complex_constraints,
             autonomy=complex_autonomy,
             MeanSquaredCorrelation=complex_MeanSquaredCorrelation),
  data.frame(Time=1:last(simple_z_feasible$Time), Foodweb="Simple",
             evolvability=simple_evolvability,
             conditional.evolvability=simple_conditional.evolvability,
             constraints=simple_constraints,
             autonomy=simple_autonomy,
             MeanSquaredCorrelation=simple_MeanSquaredCorrelation)) %>%
  gather(key=G_metric, value=value, -Time, -Foodweb)


gather_G_matrix_data %>%
  ggplot(., aes(x=Time, y=value, color=Foodweb)) +
  geom_point() +
  geom_line() +
  scale_color_manual(values=treatment_colors) +
  facet_wrap(~G_metric, ncol=2, scales = "free_y")

#bind_rows(data.frame(Time=1:last(complex_z_feasible$Time), Foodweb="Complex", conditional.evolvability=complex_conditional.evolvability),
#          data.frame(Time=1:last(simple_z_feasible$Time), Foodweb="Simple", conditional.evolvability=simple_conditional.evolvability)) %>%
#  ggplot(., aes(x=Time, y=conditional.evolvability, color=Foodweb)) +
#  geom_point() +
#  geom_line() +
#  scale_color_manual(values=treatment_colors)

#bind_rows(data.frame(Time=1:last(complex_z_feasible$Time), Foodweb="Complex", constraints=complex_constraints),
#          data.frame(Time=1:last(simple_z_feasible$Time), Foodweb="Simple", constraints=simple_constraints)) %>%
#  ggplot(., aes(x=Time, y=constraints, color=Foodweb)) +
#  geom_point() +
#  geom_line() +
#  scale_color_manual(values=treatment_colors)

#bind_rows(data.frame(Time=1:last(complex_z_feasible$Time), Foodweb="Complex", autonomy=complex_autonomy),
#          data.frame(Time=1:last(simple_z_feasible$Time), Foodweb="Simple", autonomy=simple_autonomy)) %>%
#  ggplot(., aes(x=Time, y=autonomy, color=Foodweb)) +
#  geom_point() +
#  geom_line() +
#  scale_color_manual(values=treatment_colors)
```


## More walks across the adaptive landscape

```{r Generate random G matrices and simulate Evo Dynamics, include=FALSE, eval=FALSE}

## Define the maximum additive genetic variance
max_add_G <- 0.5

## Number of G-matrix simulations
n_G_sims <- 200 # 1000

## Simulate G-matrices

## ALTERNATIVE APPROACH: RandomMatrix(num.traits=3, num.matrices = 1, min.var=0, max.var=0.5)

# additive genetic variance is sampled from a random uniform distribution and varies between 0 and max_add_G
# additive genetic covariances can be positive or negative with a maximum absolute value determined by the product of additive genetic variances.
sim_G <- list()
for(i in 1:n_G_sims){
  sim_G[[i]] <- diag(x = runif(n=3, min = 0, max = max_add_G), nrow = 3)
  sim_G[[i]][1,2] <- runif(n=1, min=-(sim_G[[i]][1,1]*sim_G[[i]][2,2]), max=(sim_G[[i]][1,1]*sim_G[[i]][2,2]))
  sim_G[[i]][2,1] <- sim_G[[i]][1,2]
  sim_G[[i]][1,3] <- runif(n=1, min=-(sim_G[[i]][1,1]*sim_G[[i]][3,3]), max=(sim_G[[i]][1,1]*sim_G[[i]][3,3]))
  sim_G[[i]][3,1] <- sim_G[[i]][1,3]
  sim_G[[i]][2,3] <- runif(n=1, min=-(sim_G[[i]][2,2]*sim_G[[i]][3,3]), max=(sim_G[[i]][2,2]*sim_G[[i]][3,3]))
  sim_G[[i]][3,2] <- sim_G[[i]][2,3]
}

## Simulations for complex food-web treatment
complex_evo_sims <- lapply(X = sim_G, FUN = function(x) evolutionary_dynamics(betas = complex_betas, # test_betas, #
                                                                              gammas = complex_gammas, # test_gammas, #
                                                                              G_0 = x, z_0 = z_initial, t = n_evo_sims))

tidy_complex_sims <- lapply(X = complex_evo_sims, FUN = tidy_evo_sims)

tidier_complex_sims <- list()
for(i in 1:length(tidy_complex_sims)){
  tidier_complex_sims[[i]] <- mutate(tidy_complex_sims[[i]], simulation = i, Foodweb="Complex")
}

tidiest_complex_sims <- bind_rows(tidier_complex_sims)

## Simulations for simple food-web treatment
simple_evo_sims <- lapply(X = sim_G, FUN = function(x) evolutionary_dynamics(betas = simple_betas, # simple_betas
                                                                             gammas = simple_gammas, # test_gammas, #
                                                                             G_0 = x, z_0 = z_initial, t = n_evo_sims))

tidy_simple_sims <- lapply(X = simple_evo_sims, FUN = tidy_evo_sims)

tidier_simple_sims <- list()
for(i in 1:length(tidy_simple_sims)){
  tidier_simple_sims[[i]] <- mutate(tidy_simple_sims[[i]], simulation = i, Foodweb="Simple")
}

tidiest_simple_sims <- bind_rows(tidier_simple_sims)

## Combine evolutionary simulations for plotting
combine_tidied_evo_sims <- bind_rows(tidiest_complex_sims, tidiest_simple_sims)

sims_to_subsample <- sample(unique(combine_tidied_evo_sims$simulation), 100)

sub_tidied_evo_sims <- combine_tidied_evo_sims %>% filter(simulation %in% sims_to_subsample) # subsample 100 for plotting
```

```{r Plot evo sims of many G-matrices, include=FALSE, eval=FALSE}
evosim.manyG_AF_plot_Diam.Clutch <- AF_plot_Diam.Clutch +
  geom_line(data=sub_tidied_evo_sims, aes(x=Diam, y=Clutch, group=simulation), alpha=0.1)
  
evosim.manyG_AF_plot_Clutch.Pref <- AF_plot_Clutch.Pref +
  geom_line(data=sub_tidied_evo_sims, aes(x=Pref, y=Clutch, group=simulation), alpha=0.1)
  
evosim.manyG_AF_plot_Diam.Pref <-  AF_plot_Diam.Pref +
  geom_line(data=sub_tidied_evo_sims, aes(x=Diam, y=Pref, group=simulation), alpha=0.1)
```

```{r Evo-Sim-Many-G, include=FALSE, eval=FALSE, fig.cap="Evolutionary simulation of a range of G-matrices"}
# Get legend
evosim.manyG_AF_landscape_legend <- get_legend(evosim.manyG_AF_plot_Diam.Pref)

# Format plots
evosim.manyG_AF_landscape_plots <- plot_grid(
  evosim.manyG_AF_plot_Diam.Clutch + theme(legend.position = "none", 
                              axis.title.y = element_text(size=11),
                              axis.title.x = element_blank(),
                              axis.text = element_text(size=10)),
 evosim.manyG_AF_plot_Clutch.Pref + theme(legend.position = "none", 
                              axis.title.y = element_blank(), 
                              axis.text = element_text(size=10), 
                              axis.title.x = element_text(size=11)),
  evosim.manyG_AF_plot_Diam.Pref + theme(legend.position = "none", 
                            axis.text = element_text(size=10),
                            axis.title = element_text(size=11)), 
  nrow=2, align="hv", labels = "AUTO")
evosim.manyG_AF_landscape_2d <- ggdraw(evosim.manyG_AF_landscape_plots) + draw_grob(evosim.manyG_AF_landscape_legend, x = 0.7, y=-0.2)
evosim.manyG_AF_landscape_2d
```

## Multivariate trait differences

```{r Multivariate trait differences, include=FALSE, eval=FALSE}
library(vegan)

multivariate_trait_evolution <- combine_tidied_evo_sims %>%
  group_by(simulation, Foodweb) %>%
  summarise_at(vars(Diam, Clutch, Pref), funs(last)) %>%
  ungroup()

multivariate_trait_evolution %>%
  group_by(Foodweb) %>%
  summarise_at(vars(Diam, Clutch, Pref), funs(mean, sd))

multivariate_trait_distance <- vegdist(x = select(multivariate_trait_evolution, Diam, Clutch, Pref), method = "euclidean")
# multivariate_traits <- adonis(multivariate_trait_distance ~ Foodweb, data = multivariate_trait_evolution)

trait_disper <- betadisper(d = multivariate_trait_distance, group = multivariate_trait_evolution$Foodweb)
anova(trait_disper)
plot(trait_disper)
boxplot(trait_disper)
```


## How does the adaptive landscape influence the rate of evolution?

Here we are going to see how fast it took for the *Iteomyia* to hit the edge of the adaptive landscape across many different G-matrices.
```{r Rate of phenotypic evolution, include=FALSE, eval=FALSE}
evo_sim_duration <-combine_tidied_evo_sims %>%
  group_by(simulation, Foodweb) %>%
  summarise_at(vars(Time), funs(last))

which(evo_sim_duration$Time == n_evo_sims) # note that a boundary was hit on the adaptive landscape for all simulations prior to the simulation duration

evo_sim_duration %>%
  ggplot(., aes(x=Foodweb, y=Time, group=simulation)) +
  geom_point() + 
  geom_line() +
  scale_y_log10() +
  stat_summary(fun.y = "mean", color="red", geom="point", size=5, mapping=aes(group=Foodweb))

# only 10 times out of 500 simulations where it took longer to hit the boundary in the complex food web (so in general, its faster)
spread(evo_sim_duration, Foodweb, Time) %>%
  filter(Complex > Simple)

wide_evo_sim_duration <- spread(evo_sim_duration, Foodweb, Time) %>%
  mutate(Diff = Simple - Complex, Diff.Percent = Diff/Complex, Diff.Fold = Simple/Complex)

round(mean(wide_evo_sim_duration$Diff.Fold),1)
```

In general, *Iteomyia* hit the edge of the adaptive landscape faster in the complex vs. simple food web.

```{r Intuition about evolvability, include=FALSE, eval=FALSE}
base_matrix <- matrix(c(1,0,0,
                        0,1,0,
                        0,0,1), nrow=3, ncol=3)
base_G <- 0.5

G_1 <- base_G*base_matrix
MeanMatrixStatistics(G_1)
G_2 <- G_1
G_2[2,1] <- -G_1[1,1]*G_1[2,2]
G_2[1,2] <- G_2[2,1]
MeanMatrixStatistics(G_2)
G_3 <- G_2
G_3[3,1] <- -G_2[1,1]*G_2[3,3]
G_3[1,3] <- G_3[3,1]
MeanMatrixStatistics(G_3)
G_4 <- G_3
G_4[3,2] <- -G_3[2,2]*G_3[3,3]
G_4[2,3] <- G_4[3,2]
MeanMatrixStatistics(G_4)

G_5 <- base_G*base_matrix
MeanMatrixStatistics(G_5)
G_6 <- G_5
G_6[2,1] <- G_5[1,1]*G_5[2,2]
G_6[1,2] <- G_6[2,1]
MeanMatrixStatistics(G_6)
G_7 <- G_6
G_7[3,1] <- G_6[1,1]*G_6[3,3]
G_7[1,3] <- G_7[3,1]
MeanMatrixStatistics(G_7)
G_8 <- G_7
G_8[3,2] <- G_7[2,2]*G_7[3,3]
G_8[2,3] <- G_8[3,2]
MeanMatrixStatistics(G_8)

bind_rows(MeanMatrixStatistics(G_1), MeanMatrixStatistics(G_2), MeanMatrixStatistics(G_3), #MeanMatrixStatistics(G_4),
          MeanMatrixStatistics(G_5), MeanMatrixStatistics(G_6), MeanMatrixStatistics(G_7), MeanMatrixStatistics(G_8)) %>%
  mutate(G_name = c(1:3,5:8), base_G = base_G) %>%
  select(G_name, evolvability, conditional.evolvability, autonomy, constraints)
```

```{r Intuition about matrix multiplication, include=FALSE, eval=FALSE}

beta <- matrix(c(0.2,0,0.1), nrow = 3)
- (beta %*% t(beta)) # decrease in genetic covariance between traits 1 and 3

beta2 <- matrix(c(0.2,0,-0.1), nrow = 3)
- (beta2 %*% t(beta2)) # increase in genetic covariance between traits 1 and 3

cov.test <- matrix(1, nrow = 3, ncol=3)*0.5
cov.test[2,1] <- cov.test[1,1]*cov.test[2,2]
cov.test[1,2] <- cov.test[2,1]
cov.test[3,1] <- cov.test[1,1]*cov.test[3,3]
cov.test[1,3] <- cov.test[3,1]
cov.test[2,3] <- cov.test[3,3]*cov.test[2,2]
cov.test[3,2] <- cov.test[2,3]

sim_data <- MASS::mvrnorm(n=10, mu=rep(0,3), Sigma=cov.test)
plot(sim_data[,1] ~ sim_data[,2])
```


```{r Compare evolvabilities at end of simulation, include=FALSE, eval=FALSE}

complex_G_end <- list()
simple_G_end <- list()
for(i in 1:n_evo_sims){ #n_evo_sims
  
  complex_time_end <- filter(evo_sim_duration, Foodweb=="Complex", simulation == i)$Time
  simple_time_end <- filter(evo_sim_duration, Foodweb=="Simple", simulation == i)$Time
  
  if(isSymmetric(complex_evo_sims[[i]]$G[[complex_time_end]])==TRUE){
    complex_G_end[[i]] <- data.frame(t(MeanMatrixStatistics(complex_evo_sims[[i]]$G[[complex_time_end]]))) %>% select(evolvability, conditional.evolvability, autonomy, constraints, MeanSquaredCorrelation)
  } else {complex_G_end[[i]] <- data.frame(evolvability=NA, conditional.evolvability=NA, autonomy=NA, constraints=NA, MeanSquaredCorrelation=NA)}
  
  if(isSymmetric(simple_evo_sims[[i]]$G[[simple_time_end]])==TRUE){
    simple_G_end[[i]] <- data.frame(t(MeanMatrixStatistics(simple_evo_sims[[i]]$G[[simple_time_end]]))) %>% select(evolvability, conditional.evolvability, autonomy, constraints, MeanSquaredCorrelation)
  } else {simple_G_end[[i]] <- data.frame(evolvability=NA, conditional.evolvability=NA, autonomy=NA, constraints=NA, MeanSquaredCorrelation=NA)}
}

tidy_G_matrix_stats <- bind_rows(
  mutate(bind_rows(complex_G_end), sim = 1:n_evo_sims, Foodweb="Complex"),
  mutate(bind_rows(simple_G_end), sim = 1:n_evo_sims, Foodweb="Simple")) %>%
  gather(key=G_metric, value=value, -sim, -Foodweb)

tidy_G_matrix_stats %>%
  ggplot(., aes(x=Foodweb, y=value, group=sim)) +
  geom_point() + 
  geom_line() +
  stat_summary(fun.y = "mean", color="red", geom="point", size=5, mapping=aes(group=Foodweb)) +
  facet_wrap(~G_metric, ncol=2, scales="free_y")

#tidy_G_matrix_stats %>%
#  ggplot(., aes(x=Foodweb, y=evolvability, group=sim)) +
#  geom_point() + 
#  geom_line() +
#  stat_summary(fun.y = "mean", color="red", geom="point", size=5, mapping=aes(group=Foodweb))

#tidy_G_matrix_stats %>%
#  ggplot(., aes(x=Foodweb, y=conditional.evolvability, group=sim)) +
#  geom_point() + 
#  geom_line() +
#  stat_summary(fun.y = "mean", color="red", geom="point", size=5, mapping=aes(group=Foodweb))

#tidy_G_matrix_stats %>%
#  ggplot(., aes(x=Foodweb, y=autonomy, group=sim)) +
#  geom_point() + 
#  geom_line() +
#  stat_summary(fun.y = "mean", color="red", geom="point", size=5, mapping=aes(group=Foodweb))

#tidy_G_matrix_stats %>%
#  ggplot(., aes(x=Foodweb, y=constraints, group=sim)) +
#  geom_point() + 
#  geom_line() +
#  stat_summary(fun.y = "mean", color="red", geom="point", size=5, mapping=aes(group=Foodweb))

#evolvability_stats <- tidy_G_matrix_stats %>%
#  select(sim, Foodweb, evolvability) %>%
#  spread(Foodweb, evolvability) %>%
#  mutate(Diff.mag = Complex/Simple)

#mean(evolvability_stats$Diff.mag, na.rm=T) # Resulting G-matrix is 2x more evolvable in complex vs. simple food web.
```



```{r Mortality, include=FALSE, eval=FALSE}
# 8-10% mortality induced by intraguild predators
mean(control_df$platy)
mean(treatment_df$platy)
mean(eggptoid_control_df$platy)

# Gall mortality to Platy
1 - mean(treatment_df$pupa)

# Gall mortality to Ectos

# Platy mortality to intraguild predation
mean(treatment_df$platy) - mean(control_df$platy) 

mean(control_df$ectos)
mean(treatment_df$ectos)
mean(ectoptoid_control_df$ectos)

mean(control_df$pupa)
mean(treatment_df$pupa)
mean(eggptoid_control_df$pupa)
mean(ectoptoid_control_df$pupa)
```



<!--$$logit(E(W))=\mu+\beta_{diameter}+\beta_{clutch}+\beta_{preference}+$$
$$logit(E(W))=\mu+treatment+s(diam):treat+s(clutch)+s(pref)+diam:cluch+diam:pref+clutch:pref+(1|Genotype/Plant/Gall)$$-->

<!-- We used generalized linear mixed models (GLMMs, @Bolker2009) to test the effects of food-web complexity on the shape of the fitness landscape. 
Larva survival (0 or 1) was our response variable and measure of fitness. 
<!-- Need to clean up the language part of this section without it being too complicated and confusing. I should also include tests of non-linear selection gradients. -->
<!-- We specified our food-web treatment, each gall trait, two-way interactions between gall traits, as well interactions between gall trait and food-web treatment, as fixed effects to fully explore the effects of food-web complexity on the fitness landscape. 
This analysis implicitly assumes that selection is linear, which we felt was a necessary trade-off for exploring the shape of the fitness landscape. 
To account for the correlated structure of clutch size (gall level) and female preference (plant level) as well as any other independent effects of willow genotype on parasitism rates, we specified gall ID nested within plant ID nested within plant genotype as random intercepts in our statistical models. -->




```{r OLD TEXT, include=FALSE, eval=FALSE}
$\chi^2_{`r foodweb_test$[2,"Chi.Df"]`}=`r foodweb_test$[2,"statistic"]`, P=`r foodweb_test$[2,"p.value"]`$). 

Two key patterns emerged from our analyses. First, fewer phenotypic traits were under selection in the complex vs. simple food web. 
In both complex and simple food webs, gall diameter was under strong directional selection, with larger galls resulting in higher larval survival (complex $\beta_{diam}=$`r paste0(filter(summary_beta_control, Phenotype=="Gall diameter")$Estimate," [",filter(summary_beta_control, Phenotype=="Gall diameter")$lower_2.5,",",filter(summary_beta_control, Phenotype=="Gall diameter")$upper_97.5,"]")`; simple $\beta_{diam}=$ `r paste0(filter(summary_beta_treatment, Phenotype=="Gall diameter")$Estimate," [",filter(summary_beta_treatment, Phenotype=="Gall diameter")$lower_2.5,",",filter(summary_beta_treatment, Phenotype=="Gall diameter")$upper_97.5,"]")`)(Fig. \ref{fig:Univariate_Landscapes}A). 

In the complex food web, we found that there was no selection acting on clutch size

In simple food webs, both clutch size and female preference experience directional selection, with smaller clutch sizes ($\beta_{clutch}=$
`r paste0(filter(summary_beta_treatment, Phenotype=="Clutch size")$Estimate," [",filter(summary_beta_treatment, Phenotype=="Clutch size")$lower_2.5,",",filter(summary_beta_treatment, Phenotype=="Clutch size")$upper_97.5,"]")`
and weaker preferences ($\beta_{pref}=$
`r paste0(filter(summary_beta_treatment, Phenotype=="Female preference")$Estimate," [",filter(summary_beta_treatment, Phenotype=="Female preference")$lower_2.5,",",filter(summary_beta_treatment, Phenotype=="Female preference")$upper_97.5,"]")`
) resulting in higher larval survival (blue lines in Fig. \ref{fig:Univariate_Landscapes}B,C).
In contrast, there was no evidence of selection on clutch size ($\beta_{clutch}=$
`r paste0(filter(summary_beta_control, Phenotype=="Clutch size")$Estimate," [",filter(summary_beta_control, Phenotype=="Clutch size")$lower_2.5,",",filter(summary_beta_control, Phenotype=="Clutch size")$upper_97.5,"]")`
) or female preference ($\beta_{pref}=$
`r paste0(filter(summary_beta_control, Phenotype=="Female preference")$Estimate," [",filter(summary_beta_control, Phenotype=="Female preference")$lower_2.5,",",filter(summary_beta_control, Phenotype=="Female preference")$upper_97.5,"]")`
) in complex food webs (orange lines in Fig. \ref{fig:Univariate_Landscapes}B,C). The absence of selection on clutch size and female preference was likely a result of conflicting selection pressures imposed by each guild of parasitoids due to their different functional relationships with gall traits. Together, these different patterns of selection resulted in an ideal combination of traits having higher fitness in the simple food web (large diameter, smaller clutches, weaker preference), whereas there was a larger combination of trait values that had equal fitness in the complex food web (Fig. \ref{fig:Multivariate_Landscapes}).
We did not find any strong evidence for nonlinear or correlational selection gradients acting on gall traits in either food-web treatment.
The second major pattern was that the overall intensity of selection was stronger in the complex vs. simple food web. This result appeared to be driven by selection on gall diameter in the complex food web, which was more than 
`r round(filter(summary_beta_control, Phenotype=="Gall diameter")$Estimate/filter(summary_beta_treatment, Phenotype=="Gall diameter")$Estimate,1)`
$\times$ larger than any other selection gradient in our analyses. 

-->
```

## Contributions of egg parasitoids to selection gradients

To identify the mechanisms by which food-web treatment altered selection gradients, we refit our models so that the complex food-web treatment only contained cases of parasitisms from egg parasitoids. Therefore, these analyses identify the change in apparent selection imposed by the egg parasitoid (egg parasitoid from simple food web; egg parasitoid from complex food web).


```{r Egg vs. egg Parasitoids Model, cache=TRUE}

# excludes cases of egg-parasitism from Complex food web
egg.vs.egg_df <- filter(gall_selection.df, Foodweb == "Simple" | Foodweb == "Complex" & ectos < 1) #%>% 
 # mutate(Foodweb = ifelse(Foodweb == "Simple", "Egg", "egg"))

egg.vs.egg_df$Foodweb <- relevel(factor(egg.vs.egg_df$Foodweb), ref = "Simple") # this represents the baseline or absence of selection by larval parasitoids

egg.egg_model_1 <- update(model_1, data=egg.vs.egg_df)
summary(egg.egg_model_1)
```

```{r egg vs egg ggplot explore}
densities <- gall_selection.df %>%
  distinct(Foodweb, Genotype, Plant_Position, sc.sqrt.Pref, Density_per_100_shoots)

survival <- gall_selection.df %>%
  group_by(Foodweb, Plant_Position) %>%
  summarise_at(vars(gall_survival, egg_parasitoid, ectos), funs(sum, n())) %>%
  ungroup() %>%
  mutate(ptoids_sum = egg_parasitoid_sum + ectos_sum)

left_join(densities, survival) %>%
  filter(Foodweb=="Complex") %>%
  ggplot(., aes(x=sc.sqrt.Pref, y=ectos_sum/ptoids_sum)) +
  geom_point(aes(size=ptoids_sum), shape=21) +
  geom_smooth(method = "glm", formula = y ~ x + I(x^2), method.args = list(family="binomial")) #+
  #scale_x_continuous(limits=c(-2,1.25))

left_join(densities, survival) %>%
  filter(Foodweb=="Complex") %>%
  ggplot(., aes(x=sc.sqrt.Pref, y=egg_parasitoid_sum/ptoids_sum)) +
  geom_point(aes(size=ptoids_sum), shape=21) +
  geom_smooth(method = "glm", formula = y ~ x + I(x^2), method.args = list(family="binomial")) 

left_join(densities, survival) %>%
  ggplot(., aes(x=sc.sqrt.Pref, y=gall_survival_sum/gall_survival_n, color=Foodweb)) +
  geom_point(aes(size=gall_survival_n), shape=21) +
  geom_smooth(method = "glm", formula = y ~ x + I(x^2), method.args = list(family="binomial"))

left_join(densities, survival) %>%
  ggplot(., aes(x=sc.sqrt.Pref, y=gall_survival_n, color=Foodweb)) +
  geom_point(aes(size=gall_survival_n), shape=21) +
  geom_smooth(method = "lm", formula = y ~ x, aes(weight=gall_survival_n))

left_join(densities, survival) %>%
  filter(Foodweb=="Complex") %>%
  ggplot(., aes(x=sc.sqrt.Pref)) +
  #geom_point(aes(size=ptoids_sum), shape=21) +
  geom_smooth(method = "glm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=gall_survival_sum/gall_survival_n), color="red", method.args = list(family="binomial")) +
  geom_smooth(method = "glm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=egg_parasitoid_sum/gall_survival_n), color="black", method.args = list(family="binomial")) +
  geom_smooth(method = "glm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=ectos_sum/gall_survival_n), color="green", method.args = list(family="binomial")) + 
  scale_x_continuous(limits=c(-1,1))

left_join(densities, survival) %>%
  filter(Foodweb=="Simple") %>%
  ggplot(., aes(x=sc.sqrt.Pref)) +
  #geom_point(aes(size=ptoids_sum), shape=21) +
  geom_smooth(method = "glm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=gall_survival_sum/gall_survival_n), color="red", method.args = list(family="binomial")) +
  geom_smooth(method = "glm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=egg_parasitoid_sum/gall_survival_n), color="black", method.args = list(family="binomial")) +  # geom_smooth(method = "lm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=ectos_sum/gall_survival_n), color="green")
  scale_x_continuous(limits=c(-1,1))


# in the complex food web, there is a positive relationship between the number of gall samples and gall density (makes sense); there is the opposite pattern in the simple foodweb...
density_n_lm <- lm(gall_survival_n ~ sc.sqrt.Pref*Foodweb, left_join(densities, survival))
visreg::visreg(density_n_lm, xvar="sc.sqrt.Pref", by="Foodweb")
summary(density_n_lm)
wt_density_n_lm <- lm(gall_survival_n ~ sc.sqrt.Pref*Foodweb, left_join(densities, survival), weights = gall_survival_n)
visreg::visreg(wt_density_n_lm, xvar="sc.sqrt.Pref", by="Foodweb")
summary(wt_density_n_lm)

# good thing is that I get the same qualitative answer with or without weighting
test_glm <- glm(gall_survival_sum/gall_survival_n ~ Foodweb*(sc.sqrt.Pref + I(sc.sqrt.Pref^2)), left_join(densities, survival), family="quasibinomial")
visreg::visreg(test_glm, xvar="sc.sqrt.Pref", by="Foodweb", scale="response")
summary(test_glm)

wt_test_glm <- glm(gall_survival_sum/gall_survival_n ~ Foodweb*(sc.sqrt.Pref + I(sc.sqrt.Pref^2)), left_join(densities, survival), family="quasibinomial", weights = gall_survival_n)
visreg::visreg(wt_test_glm, xvar="sc.sqrt.Pref", by="Foodweb", scale="response")
summary(wt_test_glm)

# now with just egg parasitoids
egg.densities <- egg.vs.egg_df %>%
  distinct(Foodweb, Plant_Position, sc.sqrt.Pref)

egg.survival <- egg.vs.egg_df %>%
  group_by(Foodweb, Plant_Position) %>%
  summarise_at(vars(gall_survival, egg_parasitoid, ectos), funs(sum, n())) %>%
  ungroup() %>%
  mutate(ptoids_sum = egg_parasitoid_sum + ectos_sum)

egg.test_glm <- glm(gall_survival_sum/gall_survival_n ~ Foodweb*(sc.sqrt.Pref + I(sc.sqrt.Pref^2)), left_join(egg.densities, egg.survival), family="quasibinomial")
visreg::visreg(egg.test_glm, xvar="sc.sqrt.Pref", by="Foodweb", scale="response")
summary(egg.test_glm)

egg.wt_test_glm <- glm(gall_survival_sum/gall_survival_n ~ Foodweb*(sc.sqrt.Pref + I(sc.sqrt.Pref^2)), left_join(egg.densities, egg.survival), family="quasibinomial", weights = gall_survival_n)
visreg::visreg(egg.wt_test_glm, xvar="sc.sqrt.Pref", by="Foodweb", scale="response")
summary(egg.wt_test_glm)

## now use raw densities
sqrt.raw_complex <- left_join(densities, survival) %>%
  filter(Foodweb=="Complex") %>%
  #filter(Density_per_100_shoots>0 & sqrt(Density_per_100_shoots)<9.5) %>%
  ggplot(., aes(x=sqrt(Density_per_100_shoots))) +
  #geom_point(aes(size=ptoids_sum), shape=21) +
  geom_smooth(method = "glm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=gall_survival_sum/gall_survival_n), color="red", method.args = list(family="binomial")) +
  geom_smooth(method = "glm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=egg_parasitoid_sum/gall_survival_n), color="black", method.args = list(family="binomial")) +
  geom_smooth(method = "glm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=ectos_sum/gall_survival_n), color="green", method.args = list(family="binomial")) +
  scale_y_continuous(limits=c(0,1)) + scale_x_continuous(limits=c(0,10)) +
      geom_vline(xintercept=mean(sqrt(densities$Density_per_100_shoots))) +
    geom_vline(xintercept=mean(sqrt(densities$Density_per_100_shoots)) + sd(sqrt(densities$Density_per_100_shoots)), linetype="dotted") +
    geom_vline(xintercept=mean(sqrt(densities$Density_per_100_shoots)) - sd(sqrt(densities$Density_per_100_shoots)), linetype="dotted") 
  #facet_wrap(~Genotype, ncol=2, nrow=4)

sqrt.raw_simple <- left_join(densities, survival) %>%
    filter(Foodweb=="Simple") %>%
    #filter(Density_per_100_shoots>0 & sqrt(Density_per_100_shoots)<9.5) %>%
    ggplot(., aes(x=sqrt(Density_per_100_shoots))) +
    #geom_point(aes(size=ptoids_sum), shape=21) +
    geom_smooth(method = "glm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=gall_survival_sum/gall_survival_n), color="red", method.args = list(family="binomial")) +
    geom_smooth(method = "glm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=egg_parasitoid_sum/gall_survival_n), color="black", method.args = list(family="binomial")) +
    scale_y_continuous(limits=c(0,1)) + scale_x_continuous(limits=c(0,10)) +
    geom_vline(xintercept=mean(sqrt(densities$Density_per_100_shoots))) +
    geom_vline(xintercept=mean(sqrt(densities$Density_per_100_shoots)) + sd(sqrt(densities$Density_per_100_shoots)), linetype="dotted") +
    geom_vline(xintercept=mean(sqrt(densities$Density_per_100_shoots)) - sd(sqrt(densities$Density_per_100_shoots)), linetype="dotted") 
   # facet_wrap(~Genotype, ncol=2, nrow=4)

plot_grid(sqrt.raw_complex, sqrt.raw_simple, ncol=2)

raw_complex <- left_join(densities, survival) %>%
  filter(Foodweb=="Complex") %>%
  #filter(Density_per_100_shoots>0 & sqrt(Density_per_100_shoots)<9.5) %>%
  ggplot(., aes(x=(Density_per_100_shoots))) +
  #geom_point(aes(size=ptoids_sum), shape=21) +
  geom_smooth(method = "glm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=gall_survival_sum/gall_survival_n), color="red", method.args = list(family="binomial")) +
  geom_smooth(method = "glm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=egg_parasitoid_sum/gall_survival_n), color="black", method.args = list(family="binomial")) +
  geom_smooth(method = "glm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=ectos_sum/gall_survival_n), color="green", method.args = list(family="binomial")) +
  scale_y_continuous(limits=c(0,1)) + scale_x_continuous(limits=c(0,100)) +
      geom_vline(xintercept=mean((densities$Density_per_100_shoots))) +
    geom_vline(xintercept=mean((densities$Density_per_100_shoots)) + sd((densities$Density_per_100_shoots)), linetype="dotted") +
    geom_vline(xintercept=mean((densities$Density_per_100_shoots)) - sd((densities$Density_per_100_shoots)), linetype="dotted") 
  #facet_wrap(~Genotype, ncol=2, nrow=4)

  raw_simple <- left_join(densities, survival) %>%
    filter(Foodweb=="Simple") %>%
    #filter(Density_per_100_shoots>0 & sqrt(Density_per_100_shoots)<9.5) %>%
    ggplot(., aes(x=(Density_per_100_shoots))) +
    #geom_point(aes(size=ptoids_sum), shape=21) +
    geom_smooth(method = "glm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=gall_survival_sum/gall_survival_n), color="red", method.args = list(family="binomial")) +
    geom_smooth(method = "glm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=egg_parasitoid_sum/gall_survival_n), color="black", method.args = list(family="binomial")) +
    scale_y_continuous(limits=c(0,1)) + scale_x_continuous(limits=c(0,100)) +
    geom_vline(xintercept=mean((densities$Density_per_100_shoots))) +
    geom_vline(xintercept=mean((densities$Density_per_100_shoots)) + sd((densities$Density_per_100_shoots)), linetype="dotted") +
    geom_vline(xintercept=mean((densities$Density_per_100_shoots)) - sd((densities$Density_per_100_shoots)), linetype="dotted") 
   # facet_wrap(~Genotype, ncol=2, nrow=4)

plot_grid(raw_complex, raw_simple, ncol=2)

log1p.raw_complex <- left_join(densities, survival) %>%
  filter(Foodweb=="Complex") %>%
  #filter(Density_per_100_shoots>0 & sqrt(Density_per_100_shoots)<9.5) %>%
  ggplot(., aes(x=log1p(Density_per_100_shoots))) +
  #geom_point(aes(size=ptoids_sum), shape=21) +
  geom_smooth(method = "glm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=gall_survival_sum/gall_survival_n), color="red", method.args = list(family="binomial")) +
  geom_smooth(method = "glm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=egg_parasitoid_sum/gall_survival_n), color="black", method.args = list(family="binomial")) +
  geom_smooth(method = "glm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=ectos_sum/gall_survival_n), color="green", method.args = list(family="binomial")) +
  scale_y_continuous(limits=c(0,1)) + #scale_x_continuous(limits=c(0,100)) +
      geom_vline(xintercept=mean(log1p(densities$Density_per_100_shoots))) +
    geom_vline(xintercept=mean(log1p(densities$Density_per_100_shoots)) + sd(log1p(densities$Density_per_100_shoots)), linetype="dotted") +
    geom_vline(xintercept=mean(log1p(densities$Density_per_100_shoots)) - sd(log1p(densities$Density_per_100_shoots)), linetype="dotted") 
  #facet_wrap(~Genotype, ncol=2, nrow=4)

log1p.raw_simple <- left_join(densities, survival) %>%
    filter(Foodweb=="Simple") %>%
    #filter(Density_per_100_shoots>0 & sqrt(Density_per_100_shoots)<9.5) %>%
    ggplot(., aes(x=log1p(Density_per_100_shoots))) +
    #geom_point(aes(size=ptoids_sum), shape=21) +
    geom_smooth(method = "glm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=gall_survival_sum/gall_survival_n), color="red", method.args = list(family="binomial")) +
    geom_smooth(method = "glm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=egg_parasitoid_sum/gall_survival_n), color="black", method.args = list(family="binomial")) +
    scale_y_continuous(limits=c(0,1)) +# scale_x_continuous(limits=c(0,100)) +
    geom_vline(xintercept=mean(log1p(densities$Density_per_100_shoots))) +
    geom_vline(xintercept=mean(log1p(densities$Density_per_100_shoots)) + sd(log1p(densities$Density_per_100_shoots)), linetype="dotted") +
    geom_vline(xintercept=mean(log1p(densities$Density_per_100_shoots)) - sd(log1p(densities$Density_per_100_shoots)), linetype="dotted") 
   # facet_wrap(~Genotype, ncol=2, nrow=4)

plot_grid(log1p.raw_complex, log1p.raw_simple, ncol=2)

left_join(densities, survival) %>%
  ggplot(., aes(x=sqrt(Density_per_100_shoots))) +
    #geom_point(aes(size=ptoids_sum), shape=21) +
    geom_smooth(method = "glm", formula = y ~ x + I(x^2), aes(weight=gall_survival_n, y=gall_survival_sum/gall_survival_n, color=Foodweb), method.args = list(family="binomial")) +
  scale_y_continuous(limits=c(0,1)) + scale_x_continuous(limits=c(0,10)) +
    geom_vline(xintercept=mean(sqrt(densities$Density_per_100_shoots))) +
    geom_vline(xintercept=mean(sqrt(densities$Density_per_100_shoots)) + sd(sqrt(densities$Density_per_100_shoots)), linetype="dotted") +
    geom_vline(xintercept=mean(sqrt(densities$Density_per_100_shoots)) - sd(sqrt(densities$Density_per_100_shoots)), linetype="dotted") 

ggplot(densities, aes(x=Genotype, y=Density_per_100_shoots, fill=Foodweb)) + geom_boxplot()
ggplot(densities, aes(x=Genotype, y=sc.sqrt.Pref, fill=Foodweb)) + geom_boxplot()

summary(lm(Density_per_100_shoots ~ Foodweb, filter(densities, Density_per_100_shoots>0)))
summary(lm(sqrt(Density_per_100_shoots) ~ Foodweb, filter(densities, Density_per_100_shoots>0)))
car::Anova(lmer(sqrt(Density_per_100_shoots) ~ Foodweb + (1|Genotype), filter(densities, Density_per_100_shoots>0)), test="F")
summary(lm(sc.sqrt.Pref ~ Foodweb, densities))

with(densities, table(Foodweb, Density_per_100_shoots))

ggplot(densities, aes(x=Density_per_100_shoots, fill=Foodweb)) + geom_density(alpha=0.5)
ggplot(densities, aes(x=sqrt(Density_per_100_shoots), fill=Foodweb)) + geom_density(alpha=0.5)
ggplot(densities, aes(x=sc.sqrt.Pref, fill=Foodweb)) + geom_density(alpha=0.5)

shapiro.test(densities$Density_per_100_shoots)
shapiro.test(sqrt(densities$Density_per_100_shoots))
shapiro.test(log1p(densities$Density_per_100_shoots))

clutches <- gall_selection.df %>%
  distinct(Foodweb, Genotype, Plant_Position, sc.log.Clutch, gall_individuals)
shapiro.test((clutches$gall_individuals))
shapiro.test(sqrt(clutches$gall_individuals))
shapiro.test(log(clutches$gall_individuals))

shapiro.test((gall_selection.df$Gall_Height_mm))
shapiro.test(sqrt(gall_selection.df$Gall_Height_mm))
shapiro.test(log(gall_selection.df$Gall_Height_mm))
```


```{r Egg vs. Egg Bootstrap Model 1, include=FALSE, cache=TRUE}
egg.egg_boot_model_1 <- bootMer(egg.egg_model_1, FUN = fixef, nsim=n_boots_analysis, parallel="multicore", ncpus=32)

egg.egg_tidy_model_1 <- tidy(egg.egg_boot_model_1, conf.int=T) %>% 
  # filter terms that only matter for this analysis
  filter(term %in% c("I(sc.Diam^2)","I(sc.log.Clutch^2)","I(sc.sqrt.Pref^2)",
                     "sc.Diam:sc.log.Clutch","sc.Diam:sc.sqrt.Pref","sc.log.Clutch:sc.sqrt.Pref",
                     "FoodwebComplex:I(sc.Diam^2)","FoodwebComplex:I(sc.log.Clutch^2)","FoodwebComplex:I(sc.sqrt.Pref^2)",
                     "FoodwebComplex:sc.Diam:sc.log.Clutch","FoodwebComplex:sc.Diam:sc.sqrt.Pref","FoodwebComplex:sc.log.Clutch:sc.sqrt.Pref"))
```

There is no strong evidence that egg parasitism differs for nonlinear terms between complex and simple food webs. Although close perhaps for sc.Diam.

```{r Egg vs. Egg Plot Effect of Food-web on Nonlinear Terms in Model 1, echo=FALSE}
knitr::kable(egg.egg_tidy_model_1)

egg.egg_plot_model_1 <- egg.egg_tidy_model_1 %>%
  mutate(Food_web = ifelse(grepl("FoodwebComplex", .$term)==TRUE,"Complex","Simple")) %>%
  filter(Food_web == "Complex")

egg.egg_plot_model_1$term_plot <- factor(egg.egg_plot_model_1$term,
                                levels=c("FoodwebComplex:I(sc.Diam^2)","FoodwebComplex:I(sc.log.Clutch^2)","FoodwebComplex:I(sc.sqrt.Pref^2)","FoodwebComplex:sc.Diam:sc.log.Clutch","FoodwebComplex:sc.Diam:sc.sqrt.Pref","FoodwebComplex:sc.log.Clutch:sc.sqrt.Pref"),
                                ordered=TRUE)

egg.egg_plot_model_1 %>%
  ggplot(., aes(x=term_plot)) +
  geom_linerange(aes(ymin=conf.low, ymax=conf.high)) +
  geom_point(aes(y=statistic), shape=21, size=3, fill="grey") +
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  scale_x_discrete(name="", limits = rev(levels(egg.egg_plot_model_1$term_plot))) +
  ylab("Coefficient (logit scale)")

visreg::visreg(egg.egg_model_1, xvar="sc.sqrt.Pref", by="Foodweb", scale = "response")
```

Now we assess their contribution to the effect of food-web treatment on the linear terms.

```{r Fit Egg vs. egg Parasitoid Model 3, cache=TRUE}
egg.egg_model_3 <- update(model_3, data=egg.vs.egg_df) 
```


```{r Bootstrap Egg vs. egg Parasitoid Model 4, cache=TRUE, include=FALSE}
boot_egg.egg_model_3 <- bootMer(egg.egg_model_3, FUN = fixef, nsim=n_boots_analysis, parallel="multicore", ncpus=32)

tidy_egg.egg_model_3 <- tidy(egg.egg_model_3, conf.int=T) # boot_egg.egg_model_3
```

Here, we observe clear evidence of conflicting selection pressures on clutch size. This results in net zero selection gradient acting on clutch size in the complex food web.
```{r Plot Egg vs. egg Parasitoid Model 4, echo=FALSE}
egg.egg_plot_model_3 <- tidy_egg.egg_model_3 %>%
  mutate(Food_web = ifelse(grepl("FoodwebComplex:", .$term)==TRUE,"Complex","Simple")) %>%
  filter(Food_web == "Complex")

egg.egg_plot_model_3$term_plot <- factor(egg.egg_plot_model_3$term,
                                levels=c("FoodwebComplex:sc.Diam","FoodwebComplex:sc.log.Clutch","FoodwebComplex:sc.sqrt.Pref"),
                                ordered=TRUE)

egg.egg_plot_model_3 %>%
  ggplot(., aes(x=term_plot)) +
  geom_linerange(aes(ymin=conf.low, ymax=conf.high)) +
  geom_point(aes(y=estimate), shape=21, size=3, fill="grey") + # y=statistic
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  scale_x_discrete(name="", limits = rev(levels(egg.egg_plot_model_3$term_plot))) +
  ylab("Coefficient (logit scale)")
```

```{r Fit Egg vs. egg Parasitoid adjusted Model 4, cache=TRUE, eval=FALSE}
egg.egg_model_4_adj <- update(model_4_adj, data=egg.vs.egg_df)
```

This reduced model returns the same qualitative result as before. Specifically, that the linear effect of clutch size depends on food-web treatment. Note also that egg survival is significantly higher in the simple food web compared to the complex food web (dotted line). These are the regression coefficients we will use when calculating directional selection gradients ($\beta$).

```{r Bootstrap Egg vs. egg Parasitoid adjuted Model 4, cache=TRUE, include=FALSE, eval=FALSE}
boot_egg.egg_model_4_adj <- bootMer(egg.egg_model_4_adj, FUN = fixef, nsim=n_boots_analysis, parallel="multicore", ncpus=32)

tidy_egg.egg_model_4_adj <- tidy(boot_egg.egg_model_4_adj, conf.int=T) 
```

Here, we observe clear evidence of conflicting selection pressures on clutch size. This results in net zero selection gradient acting on clutch size in the complex food web.
```{r Plot Egg vs. egg Parasitoid adjusted Model 4, echo=FALSE, eval=FALSE}
tidy_egg.egg_model_4_adj$term_ord <- factor(tidy_egg.egg_model_4_adj$term, 
                                levels = c("(Intercept)","FoodwebSimple","sc.Diam","FoodwebSimple:sc.log.Clutch","FoodwebSimple:sc.log.Clutch","sc.sqrt.Pref"),
                                ordered = TRUE)

plot_egg.egg_model_4_adj <- tidy_egg.egg_model_4_adj %>%
  filter(term != "(Intercept)") %>%
  droplevels() 

plot_egg.egg_model_4_adj %>%
  ggplot(., aes(x=term_ord)) +
  geom_linerange(aes(ymin=conf.low, ymax=conf.high)) +
  geom_point(aes(y=statistic), size=3, shape=21, fill="grey") +
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  scale_x_discrete(name="", limits = rev(levels(plot_egg.egg_model_4_adj$term_ord))) +
  ylab("Coefficient (logit scale)")
```

## CALCULATE SELECTION GRADIENTS FOR EGG VS. egg PARASITOIDS

```{r Organize and Transform egg vs. egg parasitoid Coefficients, include=FALSE, eval=FALSE}
tidy_egg.egg_coefs <- bind_rows(
  select(tidy_egg.egg_model_2_adj, term, estimate, conf.low, conf.high), 
  select(tidy_egg.egg_model_4_adj, term, estimate=statistic, conf.low, conf.high)) %>%
  filter(term != "(Intercept)", term != "FoodwebLarval") # remove main effects

# Tidy common coefficients
tidy_egg.egg_common_coefs <- tidy_egg.egg_coefs %>%
  filter(term!="FoodwebEgg:I(sc.sqrt.Pref^2)", term!="Foodwebegg:I(sc.sqrt.Pref^2)",
         term!="FoodwebEgg:sc.log.Clutch",term!="FoodwebLarval:sc.log.Clutch")

# Tidy unique coefficients to each food-web
egg_quad_pref <- filter(tidy_egg.egg_coefs, term %in% "FoodwebEgg:I(sc.sqrt.Pref^2)")
egg_quad_pref$term <- "I(sc.sqrt.Pref^2)"
egg_quad_pref <- filter(tidy_egg.egg_coefs, term %in% "FoodwebLarval:I(sc.sqrt.Pref^2)")
egg_quad_pref$term <- "I(sc.sqrt.Pref^2)"

egg_clutch <- filter(tidy_egg.egg_coefs, term %in% "FoodwebEgg:sc.log.Clutch")
egg_clutch$term <- "sc.log.Clutch"
egg_clutch <- filter(tidy_egg.egg_coefs, term %in% "FoodwebLarval:sc.log.Clutch")
egg_clutch$term <- "sc.log.Clutch"
```


```{r Calculate Egg vs. egg parasitoid Selection Gradients, include=FALSE, eval=FALSE}

# Estimate mean fitness and mean "brackets" for each food-web treatment (see Janzen and Stern 1998 equation 4 for details about "brackets")
egg_predict <- predict(egg.egg_model_2, newdata=filter(egg.vs.egg_df, Foodweb=="egg"), type="response")
egg_mean_brackets <- mean(egg_predict * (1 - egg_predict))
egg_mean_fitness <- mean(egg_predict)

egg_predict <- predict(egg.egg_model_2, newdata=filter(egg.vs.egg_df, Foodweb=="Egg"), type="response")
egg_mean_brackets <- mean(egg_predict * (1 - egg_predict))
egg_mean_fitness <- mean(egg_predict)

# Double-check that using a different model (e.g. egg.egg_model_4) doesn't influence estimes of mean "brackets" and mean fitness. Using "Complex" food-web treatment as an example, but it doesn't matter 
alt_egg.egg_predict <- predict(egg.egg_model_4, newdata=filter(egg.vs.larval_df, Foodweb=="Larval"), type="response")
alt_egg.larval_mean_brackets <- mean(alt_egg.larval_predict * (1 - alt_egg.larval_predict))
alt_egg.larval_mean_fitness <- mean(alt_egg.larval_predict)
test_egg.larval_mean_brackets <- larval_mean_brackets
test_egg.larval_mean_fitness <- larval_mean_fitness
test_egg.larval_mean_brackets - alt_egg.larval_mean_brackets # virtually the same
test_egg.larval_mean_fitness - alt_egg.larval_mean_fitness # virtually the same

tidy_egg_grads <- bind_rows(tidy_egg.larval_common_coefs, egg_quad_pref, egg_clutch) %>%
  mutate(Multiplier = ifelse(grepl("\\^2", .$term)==TRUE, 2, 1)) %>% # double all quadratic gradients so they are on the same scale as other directional and correlational selection gradients (detailed explanation in Stinchcombe et al. 2008)
  transmute(term=term,
            gradient = egg_mean_brackets * estimate / egg_mean_fitness * Multiplier,
            `2.5%` = egg_mean_brackets * conf.low / egg_mean_fitness * Multiplier,
            `97.5%` = egg_mean_brackets * conf.high / egg_mean_fitness * Multiplier)

tidy_larval_grads <- bind_rows(tidy_egg.larval_common_coefs, larval_quad_pref, larval_clutch) %>%
    mutate(Multiplier = ifelse(grepl("\\^2", .$term)==TRUE, 2, 1)) %>% # double all quadratic gradients so they are on the same scale as other directional and correlational selection gradients (detailed explanation in Stinchcombe et al. 2008)
  transmute(term=term,
            gradient = larval_mean_brackets * estimate / larval_mean_fitness * Multiplier,
            `2.5%` = larval_mean_brackets * conf.low / larval_mean_fitness * Multiplier,
            `97.5%` = larval_mean_brackets * conf.high / larval_mean_fitness * Multiplier)

egg.larval_selection_gradients <- bind_rows(
  mutate(tidy_egg_grads, `Food web`="Egg"),
  mutate(tidy_larval_grads, `Food web`="Larval")) #%>%
  #mutate(Type = ifelse(grepl("\\^2", .$term)==TRUE, "Quadratic", ifelse(grepl(":", .$term)==TRUE, "Correlational", "Directional")))
```


```{r Table of Egg vs. Egg Parasitoid Selection Gradients, echo=FALSE, eval=FALSE}
egg.larval_selection_gradients$term_ord <- factor(egg.larval_selection_gradients$term, 
                                   levels=c("sc.Diam","sc.log.Clutch","sc.sqrt.Pref","I(sc.Diam^2)","I(sc.log.Clutch^2)","I(sc.sqrt.Pref^2)","sc.Diam:sc.log.Clutch","sc.Diam:sc.sqrt.Pref","sc.log.Clutch:sc.sqrt.Pref"),
                                   labels=c("Diam","Clutch","Pref","Diam^2","Clutch^2","Pref^2","Diam:Clutch","Diam:Pref","Clutch:Pref"),
                                   ordered = TRUE)

egg.larval_selection_gradients_table <- egg.larval_selection_gradients %>%
  transmute(Term=term_ord, Parasitoid=`Food web`, Gradient=round(gradient,2), `2.5%`=round(`2.5%`,2), `97.5%`=round(`97.5%`,2)) %>% 
  arrange(Term)

knitr::kable(egg.larval_selection_gradients_table, caption = "Table of Egg vs. Larval Parasitoid Selection Gradients")
```

```{r Plot of Egg vs. Egg Parasitoid Selection Gradients, echo=FALSE, eval=FALSE}
egg.larval_selection_gradients %>%
  ggplot(., aes(x=term_ord)) +
  geom_linerange(aes(ymin=`2.5%`, ymax=`97.5%`, color=`Food web`), position=position_dodge(width=0.3)) +
  geom_point(aes(y=gradient, fill=`Food web`), color="black", shape=21, size=3, position=position_dodge(width=0.3)) +
  coord_flip() +
  geom_hline(yintercept=0, linetype="dotted") +
  scale_x_discrete(name="", limits = rev(levels(egg.larval_selection_gradients$term_ord))) +
  ylab("Selection Gradient") +
  scale_fill_manual(name="Parasitoid", values=treatment_colors[c(2,1)]) +
  scale_color_manual(name="Parasitoid", values=treatment_colors[c(2,1)]) 
```